<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>AswinBlue</title>
    <link>https://aswinblue.github.io/Blog/</link>
    <description>Recent content on AswinBlue</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language><atom:link href="https://aswinblue.github.io/Blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Database</title>
      <link>https://aswinblue.github.io/Blog/post/databases/database/</link>
      <pubDate>Thu, 20 Mar 2025 22:03:29 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/databases/database/</guid>
      <description>&lt;h1 id=&#34;database&#34;&gt;Database&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;데이터를 효율적으로 저장하여 관리하는 시스템을 Database라고 한다.&lt;/li&gt;
&lt;li&gt;Database 를 체계적으로 조작하기 위해서 DBMS(DataBase Management System) 을 사용한다.&lt;/li&gt;
&lt;li&gt;Database는 형태에 따라 크게 Relational Database (관계형 DB), Non-Relational Database(비관계형 DB) 로 분류된다.
&lt;ul&gt;
&lt;li&gt;Relational Database : 테이블 형태로 데이터를 관리&lt;/li&gt;
&lt;li&gt;Non-Relational Database : key-value 세트로 구성된 형태로 데이터를 관리(ex: json format)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rdbms-relational-database-management-system&#34;&gt;RDBMS (Relational Database Management System)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Relational Database 조작을 위한 시스템을 의미한다.&lt;/li&gt;
&lt;li&gt;Codds 에서 정의한 12가지 정의에 따르도록 설계된다. (보통은 선두의 2가지 규칙만 필수로 따른다.)&lt;/li&gt;
&lt;li&gt;SQL (Structured Query Language) 이라는 쿼리 언어를 사용하여 Database를 조작한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-structured-query-language&#34;&gt;SQL (Structured Query Language)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RDBMS의 데이터를 정의하고 질의, 수정 등을 하기 위해 고안된 언어로, 다음 세가지 종류의 언어를 포함한다.
&lt;ul&gt;
&lt;li&gt;DDL (Data Definition Language) : 데이터를 정의하기 위한 언어로 데이터베이스의 생성/수정/삭제 등의 행위를 수행&lt;/li&gt;
&lt;li&gt;DML (Data Manipulation Language) : 데이터를 조작하기 위한 언어로 실제 데이터베이스 내에 존재하는 데이터에 대해 조회/저장/수정/삭제 등의 행위를 수행&lt;/li&gt;
&lt;li&gt;DCL(Data Control Language) : 접근 권한을 설정하기 위한 언어&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nosql&#34;&gt;NoSQL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Non-Relational Database&lt;/code&gt; 를 위한 언어로, &lt;code&gt;Non-Relational DBMS&lt;/code&gt; 라고도 불린다.&lt;/li&gt;
&lt;li&gt;SQL를 사용하지 않고 복잡하지 않은 데이터를 저장해 단순 검색 및 추가 검색 작업을 위해 매우 최적화되었고, 저장공간이 크다는 것이 특징이다.&lt;/li&gt;
&lt;li&gt;key-value 조합으로 데이터에 접근하기에 문법이 따로 없다는 것도 장점이다.&lt;/li&gt;
&lt;li&gt;MongoDB, Redis, CouchDB 등이 해당된다.
&lt;ul&gt;
&lt;li&gt;MongoDB : Json 형태로 테이블 관리&lt;/li&gt;
&lt;li&gt;Redis : 메모리 기반 DBMS로 속도가 빨라 임시데이터 캐싱 용도로 주로 사용&lt;/li&gt;
&lt;li&gt;CouchDB : 이는 웹 기반의 DBMS로, REST API 형식으로 요청을 처리&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;문법&#34;&gt;문법&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MongoDB 데이터 삽입&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit</title>
      <link>https://aswinblue.github.io/Blog/post/webhacking/exploit/</link>
      <pubDate>Tue, 11 Mar 2025 20:54:59 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webhacking/exploit/</guid>
      <description>&lt;h1 id=&#34;공격-방법-분류&#34;&gt;공격 방법 분류&lt;/h1&gt;
&lt;h2 id=&#34;server-side-공격-방법&#34;&gt;Server side 공격 방법&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Injection (인젝션)
&lt;ul&gt;
&lt;li&gt;서버의 처리 과정 중 사용자가 입력한 데이터가 시스템의 다른 기능을 주거나 문법적으로 사용되어 발생하는 취약점&lt;/li&gt;
&lt;li&gt;injection 공격의 종류
&lt;ul&gt;
&lt;li&gt;SQL Injection&lt;/li&gt;
&lt;li&gt;Command Injection&lt;/li&gt;
&lt;li&gt;SSTI (Server Side Template Injection)&lt;/li&gt;
&lt;li&gt;Path Traversal&lt;/li&gt;
&lt;li&gt;SSRF (Server Side Request Forgery)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ORM과 같이 검증된 SQL 라이브러리를 사용하여 방어가 필요하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;File vulnerability
&lt;ul&gt;
&lt;li&gt;서버의 파일 시스템에 사용자가 원하는 행위를 할 수 있을 때 발생하는 취약점&lt;/li&gt;
&lt;li&gt;system(PHP), child_process(Node JS), os.system(Python) 등 OS command를 실행하는 함수를 호출하지 않는 방법이 가장 좋으나, 입력 필터링이나 대체 라이브러리를 사용하는 방법으로 위협을 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Business Logic Vulnerability (비즈니스 로직 취약점)
&lt;ul&gt;
&lt;li&gt;인젝션, 파일 관련 취약점들과는 다르게 정상적인 흐름을 악용하는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Language specific Vulnerability (PHP, Python, NodeJS)
&lt;ul&gt;
&lt;li&gt;웹 어플리케이션에서 사용하는 언어의 특성으로 인해 발생하는 취약점&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Misconfiguration
&lt;ul&gt;
&lt;li&gt;잘못된 설정으로 인해 발생하는 취약점
&lt;ul&gt;
&lt;li&gt;Debug mode를 설정한 채로 배포하는 경우&lt;/li&gt;
&lt;li&gt;임시/백업 파일을 삭제하지 않은 경우
&lt;ul&gt;
&lt;li&gt;백업파일 종류
&lt;ul&gt;
&lt;li&gt;bak : 백업 파일, 대부분의 에디터에서 사용함&lt;/li&gt;
&lt;li&gt;config : 설정 파일, 비밀 키들이 존재하는 경우가 많음&lt;/li&gt;
&lt;li&gt;sql : sql schema 파일, 데이터 베이스 구조를 알아낼 수 있음&lt;/li&gt;
&lt;li&gt;sh : shell script 파일&lt;/li&gt;
&lt;li&gt;~ : bluefish 에디터 백업 파일&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;서비스와는 무관한 파일들을 제거해서 위협을 없앨 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VCS 프로그램으로 인한 임시 파일들을 정리해야 한다.
&lt;ul&gt;
&lt;li&gt;.git, .hg 등의 파일이 있다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kost/dvcs-ripper&#34;&gt;https://github.com/kost/dvcs-ripper&lt;/a&gt; 정보를 참조하여 진단이 가능하다.&lt;/li&gt;
&lt;li&gt;웹 서버의 설정으로 VCS 파일의 경로의 접근을 막는 방법도 가능하다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;location ~ /\.(git|hg) {
  deny all;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;네트워크 바인딩을 0.0.0.0 으로 세팅하는 경우
&lt;ul&gt;
&lt;li&gt;편의를 위해 세팅한 설정을 운영 환경이 변경되었음에도 그대로 유지하여 발생할 수 있는 취약점이다.&lt;/li&gt;
&lt;li&gt;내부 망에서만 접근할 수 있는 서비스는 mask를 제대로 설정 해 주고, 허용할 포트를 제외한 설정은 모두 삭제하도록 하여 위협을 제거한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;취약점&#34;&gt;취약점&lt;/h1&gt;
&lt;h2 id=&#34;xss-cross-site-scripting&#34;&gt;XSS (Cross Site Scripting)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;공격자가 웹 리소스에 악성 스크립트를 삽입해 이용자의 웹 브라우저에서 해당 스크립트를 실행하는 공격이다.&lt;/li&gt;
&lt;li&gt;XSS 취약점이 존재하는 사이트에 공격자는 origin 권한으로 악성 스크립트가 포함된 페이지를 만들어서 이용자가 악성 스크립트가 포함된 페이지를 방문하면 공격자의 악성 스크립트가 동작해 정보를 탈취하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;공격-경로&#34;&gt;공격 경로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XSS 공격은 이용자가 삽입한 내용을 출력하는 기능에서 발생한다.
&lt;ul&gt;
&lt;li&gt;악성 태그를 필터링하는 HTML Sanitization을 사용하거나 엔티티 코드로 치환하는 방법으로 XSS를 예방할 수 있다.&lt;/li&gt;
&lt;li&gt;Flask는 &lt;code&gt;render_template&lt;/code&gt; 함수를 사용하여 인자를 HTML 엔티티코드로 변환하여 출력하는 방식으로 XSS를 방지한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;아래와 같이 입력값을 그대로 출력하게 되면, 입력값으로 script 를 전달해 공격에 사용할 수 있다.
&lt;ul&gt;
&lt;li&gt;서버의 코드
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@app.route(&amp;#34;/vulnerable&amp;#34;)
def vulnerable():
    param = request.args.get(&amp;#34;param&amp;#34;, &amp;#34;&amp;#34;) # 이용자가 입력한 인자를 가져옴
    return param # 이용자의 입력값을 화면 상에 표시
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;공격자 입력1. 다른 페이지로 redirection
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;script&amp;gt;location.href = &amp;#34;/another_page?param=PARAM1&amp;#34;;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;공격자 입력2. cookie 정보 출력
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;script&amp;gt;document.cookie&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;xss-공격-종류&#34;&gt;XSS 공격 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;XSS 는 악성 스크립트의 위치와 침투 경로에 따라 아래와 같이 구분된다.
&lt;ul&gt;
&lt;li&gt;Stored XSS : XSS에 사용되는 악성 스크립트가 서버에 저장되고 서버의 응답에 담겨오는 XSS
&lt;ul&gt;
&lt;li&gt;게시물과 댓글에 악성 스크립트를 포함해 업로드하는 방식이 있음&lt;/li&gt;
&lt;li&gt;불특정 다수에게 보여지기 때문에 파급력이 크다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Reflected XSS : XSS에 사용되는 악성 스크립트가 URL에 삽입되고 서버의 응답에 담겨오는 XSS
&lt;ul&gt;
&lt;li&gt;게시판 서비스에서 작성된 게시물을 조회하기 위한 검색창에서 스크립트를 포함해 검색하는 방식이 있음&lt;/li&gt;
&lt;li&gt;검색 결과를 응답에 포함하는 일부 서비스에서 발생 가능&lt;/li&gt;
&lt;li&gt;공격을 위해서는 다른 이용자를 악성 스크립트가 포함된 링크에 접속하도록 유도해야 함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DOM-based XSS : XSS에 사용되는 악성 스크립트가 URL Fragment에 삽입되는 XSS&lt;/li&gt;
&lt;li&gt;Universal XSS : 클라이언트의 브라우저 혹은 브라우저의 플러그인에서 발생하는 취약점으로 SOP 정책을 우회하는 XSS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;csrf-cross-site-request-forgery&#34;&gt;CSRF (Cross Site Request Forgery)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;어떤 사이트에서 이용자의 신원 정보가 포함된 쿠키를 사용한다면, 타인의 쿠키를 탈취하여 변조된 명령을 서버로 번달하는 공격 방식이다.
&lt;ul&gt;
&lt;li&gt;이용자의 신원 정보가 포함된 쿠키는 일종의 서명과 같은 역할을 하기 때문에, 쿠키가 특정 명령에 대한 이용자의 본인 인증 역할을 수행할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2차 인증을 수행하지 않고 cookie로만 인증을 하는 사이트에 대해 공격이 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;XSS&lt;/code&gt;는 인증 정보인 세션 및 쿠키 탈취를 목적으로 서버에서 스크립트를 실행 하는 방식인 반면, &lt;code&gt;CSRF&lt;/code&gt;는 이용자가 임의 페이지에 HTTP 요청을 보내는 것을 목적으로 하는 공격이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;공격-경로-1&#34;&gt;공격 경로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 태그나 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그를 활용해서 사용자가 의도하지 않은 명령을 서버에 요청하는 script를 실행시킬 수 있다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/* img 태그 활용 요청 전달 */
&amp;lt;img src=&amp;#39;http://bank.dreamhack.io/sendmoney?to=Dreamhack&amp;amp;amount=1337&amp;#39; width=0px height=0px&amp;gt;`
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/* javascript 공격 예시 */
/* 새 창 띄우기 */
window.open(&amp;#39;http://bank.dreamhack.io/sendmoney?to=Dreamhack&amp;amp;amount=1337&amp;#39;);
/* 현재 창 주소 옮기기 */
location.href = &amp;#39;http://bank.dreamhack.io/sendmoney?to=Dreamhack&amp;amp;amount=1337&amp;#39;;
location.replace(&amp;#39;http://bank.dreamhack.io/sendmoney?to=Dreamhack&amp;amp;amount=1337&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sql-injection&#34;&gt;SQL Injection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;조작된 SQL 쿼리를 서버에 주입하여 인증을 우회하거나, 데이터베이스의 정보를 유출하는 공격행위&lt;/li&gt;
&lt;li&gt;Blind SQL Injection : SQL Injection 의 한 종류로, DBMS가 답변 가능한 형태로 질문을 수행하여 스무고개 게임과 같이 정답을 유추해 나가는 공격 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nosql-injection&#34;&gt;NoSQL Injection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NoSQL은 데이터 타입으로 &amp;lsquo;오브젝트&amp;rsquo; 라는 개념을 갖는다. 오브젝트 타입의 입력값을 처리할 때에는 쿼리 연산자를 사용할 수 있고, 이 부분의 취약점을 활용한 것이 NoSQL Injection 이다.&lt;/li&gt;
&lt;li&gt;NodeJs를 예를 들면 아래와 같이 url에 object를 대입할 수 있다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 서버 코드 예시
const express = require(&amp;#39;express&amp;#39;);
const app = express();
app.get(&amp;#39;/&amp;#39;, function(req,res) {
    console.log(&amp;#39;data:&amp;#39;, req.query.data, &amp;#39; / type:&amp;#39;, typeof req.query.data);
    res.send(&amp;#39;done&amp;#39;);
});
const server = app.listen(3000, function(){
    console.log(&amp;#39;app.listen&amp;#39;);
});
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 결과 예시
http://localhost:3000/?data=1234
data: 1234
type: string

http://localhost:3000/?data[]=1234
data: [ &amp;#39;1234&amp;#39; ]
type: object

http://localhost:3000/?data[]=1234&amp;amp;data[]=5678
data: [ &amp;#39;1234&amp;#39;, &amp;#39;5678&amp;#39; ] 
type: object

http://localhost:3000/?data[5678]=1234
data: { &amp;#39;5678&amp;#39;: &amp;#39;1234&amp;#39; } 
type: object

http://localhost:3000/?data[5678]=1234&amp;amp;data=0000
data: { &amp;#39;5678&amp;#39;: &amp;#39;1234&amp;#39;, &amp;#39;0000&amp;#39;: true } 
type: object

http://localhost:3000/?data[5678]=1234&amp;amp;data[]=0000
data: { &amp;#39;0&amp;#39;: &amp;#39;0000&amp;#39;, &amp;#39;5678&amp;#39;: &amp;#39;1234&amp;#39; } 
type: object

http://localhost:3000/?data[5678]=1234&amp;amp;data[1111]=0000
data: { &amp;#39;1111&amp;#39;: &amp;#39;0000&amp;#39;, &amp;#39;5678&amp;#39;: &amp;#39;1234&amp;#39; } 
type: object
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;이 방법으로 아래와 같이 &amp;lsquo;data&amp;rsquo; 객체 안에 NoSQL 쿼리가 들어가도록 url을 설정할 수도 있다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://aswinblue.github.io/Blog/post/databases/database/#%eb%ac%b8%eb%b2%95&#34;&gt;NoSQL 문법 참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://localhost:3000/?data[$eq]=A
data: { &amp;#34;$eq&amp;#34;: &amp;#34;A&amp;#34; } 
type: object
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;command-injection&#34;&gt;Command Injection&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;공격자가 클라이언트 인터페이스를 통해 서버측에 시스템 명령어를 전달하여 실행시켜 공격을 수행하는 기법&lt;/li&gt;
&lt;li&gt;PHP의 &lt;code&gt;system&lt;/code&gt;, Node JS의 &lt;code&gt;child_process&lt;/code&gt;, 파이썬의 &lt;code&gt;os.system&lt;/code&gt; 과 같이 시스템 명령어를 수행하는 함수에 이용자가 임의의 인자를 전달할 수 있을 때 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;명령어 입력란에 다른 명령어를 입력하는 기법에는 다음의 &lt;code&gt;메타문자&lt;/code&gt; 들을 활용할 수 있다.
&lt;ol&gt;
&lt;li&gt;명령어 치환
&lt;ul&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;``&lt;/code&gt; 사이에 든 문자는 새로운 명령어 라인으로 인식한다.
&lt;ul&gt;
&lt;li&gt;ex) echo `ls`
&lt;ul&gt;
&lt;li&gt;ls 명령어가 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;$()&lt;/code&gt; 사이에 든 문자는 새로운 명령어 라인으로 인식한다.
&lt;ul&gt;
&lt;li&gt;ex) echo $(ls)
&lt;ul&gt;
&lt;li&gt;ls 명령어가 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;명령어 연속 실행&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;||&lt;/code&gt; 를 사용하면, || 앞과 || 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다.
&lt;ul&gt;
&lt;li&gt;한 줄에 둘 이상의 명령어를 실행시킬 수 있다.&lt;/li&gt;
&lt;li&gt;ex) mkdir FILE || cd FILE
&lt;ul&gt;
&lt;li&gt;FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 를 사용하면, &amp;amp;&amp;amp; 앞과 &amp;amp;&amp;amp; 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다.
&lt;ul&gt;
&lt;li&gt;ex) mkdir FILE &amp;amp;&amp;amp; cd FILE
&lt;ul&gt;
&lt;li&gt;FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;;&lt;/code&gt; 를 사용하면, ; 앞과 ; 뒤를 다른 명령어 라인으로 인식하고 각각 실행한다.
&lt;ul&gt;
&lt;li&gt;ex) mkdir FILE ; cd FILE
&lt;ul&gt;
&lt;li&gt;FILE 디렉터리를 만들고 FILE 디렉터리 안으로 이동하는 명령을 한줄로 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;파이프
&lt;ul&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;|&lt;/code&gt; 를 사용하면 | 앞의 명령어 실행 결과를 | 뒤의 명령어 실행시 입력으로 설정할 수 있다.
&lt;ul&gt;
&lt;li&gt;ex) cat FILE | less
&lt;ul&gt;
&lt;li&gt;FILE 내용을 출력한 것을 less 명령으로 나눠서 볼 수 있도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;뒷내용 무시
&lt;ul&gt;
&lt;li&gt;리눅스 쉘에서 &lt;code&gt;#&lt;/code&gt;을 사용하면 # 뒤의 내용은 주석처리되어 무시된다.
&lt;ul&gt;
&lt;li&gt;ex) ls #a&amp;quot;sdfa&amp;quot;sd&amp;rsquo;fas&amp;quot;&amp;rsquo;&amp;ldquo;df
&lt;ul&gt;
&lt;li&gt;구문 오류 없이 ls 명령이 잘 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;문자열을 whitelist 처리하거나 blacklist 처리하여 공격을 방어할 수 있다.
&lt;ul&gt;
&lt;li&gt;정규식을 통해 IP 주소 포멧을 whitelist 로 지정하는 코드
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import re, os, ...
...
chk_ip = re.compile(&amp;#39;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&amp;#39;)
if bool(chk_ip.match(ip)):
    return run_system(f&amp;#39;ping -c 3 {ip}&amp;#39;)
else:
    return &amp;#39;ip format error&amp;#39;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;허용되면 안되는 문자열을 blacklist 로 지정하는 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;if &amp;#39;\&amp;#39;&amp;#39; in ip:
    return &amp;#39;not allowed character&amp;#39;
return run_system(f&amp;#39;ping -c 3 \&amp;#39;{ip}\&amp;#39;&amp;#39;)  # shell command 상에서 모든 입력을 문자열로 처리하는 Single Quotes (&amp;#39;)를 사용해야 함
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;system(PHP), child_process(Node JS), os.system(Python) 등 OS command를 실행하는 함수 외 대체 라이브러리를 사용하는 방법으로 위협을 줄일 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;file-vulnerability&#34;&gt;File Vulnerability&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;공격자의 파일을 웹 서비스의 파일 시스템에 업로드 혹은 하는 과정에서 발생하는 보안 취약점&lt;/li&gt;
&lt;li&gt;파일 업로드/다운로드 서비스를 개발시 이용자가 업로드한 파일을 데이터베이스에 저장하는 것보다는 서버의 파일 시스템에 저장하는 것이 개발하기 쉽고, 관리 효율도 높지만 File Vulnerability를 주의해야 한다.&lt;/li&gt;
&lt;li&gt;원격 코드 실행, 민감정보 탈취 등이 수행될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;File Upload Vulnerability&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Youtube Downloader</title>
      <link>https://aswinblue.github.io/Blog/post/projects/youtube_downloader/</link>
      <pubDate>Sun, 09 Mar 2025 20:40:01 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/projects/youtube_downloader/</guid>
      <description>&lt;h1 id=&#34;youtoube-download&#34;&gt;Youtoube Download&lt;/h1&gt;
&lt;p&gt;Window OS에서 Python으로 Youtube 영상을 다운로드 하는 방법&lt;/p&gt;
&lt;h2 id=&#34;1-python-code-작성&#34;&gt;1. Python Code 작성&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;yt-dlp 패키지를 다운받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pip install yt-dlp&lt;/code&gt; 명령으로 손쉽게 다운로드 가능하다.&lt;/li&gt;
&lt;li&gt;github 주소는 다음과 같다. : &lt;a href=&#34;https://github.com/yt-dlp/yt-dlp&#34;&gt;https://github.com/yt-dlp/yt-dlp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;코드를 작성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;아래는 샘플 코드이다.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;yt_dlp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;time&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;##########&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 설정&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;##########&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 최대 재시도 횟수&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;MAX_RETRIES&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 재시도 사이의 대기 시간 (초)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;RETRY_DELAY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 다운로드 리스트&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;download_lists&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;FOLDER_NAME&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 다운로드 받을 폴더 이름&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;https://www.youtube.com/watch?v=CJuIRe_1c2g&amp;amp;list=RDMM&amp;amp;start_radio=1&amp;amp;rv=R4CecLdF11E&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 다운로드 할 playlist URL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;SAMPLE2&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;https://www.youtube.com/watch?v=66l5r_IEZrI&amp;amp;list=RDGMEMYH9CUrFO7CfLJpaD7UR85w&amp;amp;start_radio=1&amp;amp;rv=CJuIRe_1c2g&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;##########&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 다운로드 시작&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;##########&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;idx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;download_lists&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;# &amp;#39;폴더이름/영상제목.확장자&amp;#39; 형식으로 다운로드&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;output_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;./&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;/&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%(title)s&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%(ext)s&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;ydl_opt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;outtmpl&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;format&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;bestaudio/best&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 다운로드할 포맷 지정&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;s1&#34;&gt;&amp;#39;download_archive&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;downloaded.txt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 다운로드 아카이브 파일 지정(미리 다운받은 항목들을 체크하여 중복으로 받지 않도록 하는 기록파일)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;postprocessors&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;key&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;FFmpegExtractAudio&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;preferredcodec&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;mp3&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# mp3포멧으로 변환&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;s1&#34;&gt;&amp;#39;preferredquality&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;192&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}],&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;verbose&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 자세한 디버깅 정보 출력&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;s1&#34;&gt;&amp;#39;ignoreerrors&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# 다운로드 오류 무시&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attempt&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_RETRIES&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;yt_dlp&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;YoutubeDL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ydl_opt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ydl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;ydl&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;download&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;:: 다운로드 완료&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;except&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;:: 다운로드 실패 (&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;attempt&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MAX_RETRIES&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;): &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;attempt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_RETRIES&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;:: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RETRY_DELAY&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;초 후 다시 시도합니다...&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RETRY_DELAY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;sa&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;:: 최대 재시도 횟수를 초과했습니다. 다운로드를 중단합니다.&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;모든 항목 다운로드 완료&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;다른것들은 수정할 필요 없고, &lt;code&gt;download_lists&lt;/code&gt; 에 다운로드 할 Youtube 재생목록을 넣어준다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cookie</title>
      <link>https://aswinblue.github.io/Blog/post/webhacking/cookie/</link>
      <pubDate>Sun, 09 Mar 2025 16:10:13 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webhacking/cookie/</guid>
      <description>&lt;h1 id=&#34;cookie&#34;&gt;Cookie&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTTP의 특징(Connectionless, Stateless) 때문에 Web Server 는 HTTP로 요청된 패킷들이 어떤 Web Client에서 전달된 것인지 구분할 수 없다.
&lt;ul&gt;
&lt;li&gt;IP 주소와 User-Agent 등의 정보는 매번 변경될 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Client의 정보와 요청의 내용을 구체화하기 위해, Server는 Client 마다 고유한 Cookie를 발급하고, Client는 Server에 요청을 보낼 때마다 Cookie를 같이 전송한다.&lt;/li&gt;
&lt;li&gt;Server는 Request 패킷에 들어있는 Cookie 를 통해 Client의 정보와 상태를 기록한다.&lt;/li&gt;
&lt;li&gt;Cookie 는 key-value 로 구성된 파일이며, Client 에 저장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cookie의-단점&#34;&gt;Cookie의 단점&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;4KB의 크기 제한&lt;/li&gt;
&lt;li&gt;쿠키로 인해 웹의 반응성이 느려질 수 있음&lt;/li&gt;
&lt;li&gt;도메인 내의 모든 페이지가 같은 쿠키를 전달 받음&lt;/li&gt;
&lt;li&gt;HTTP 프로토콜로 Cookie 요청시 암호화 되지 않아 보안이 취약함&lt;/li&gt;
&lt;li&gt;쿠키는 사용자의 로컬에 텍스트로 저장 되어있어 쉽게 내용 확인이 가능함&lt;/li&gt;
&lt;li&gt;악의적인 Client 가 Cookie 를 변조할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;modern-storage-apis&#34;&gt;Modern Storage APIs&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cookie 의 단점을 해결하기 위해 사용되는 방법이다.&lt;/li&gt;
&lt;li&gt;Local storage, Session storage 등이 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;session&#34;&gt;Session&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Session 은 Server 에서 생성한 랜덤한 문자열이고, Server 가 Client 마다 고유한 값을 발급한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Web</title>
      <link>https://aswinblue.github.io/Blog/post/webhacking/web/</link>
      <pubDate>Thu, 06 Mar 2025 22:46:50 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webhacking/web/</guid>
      <description>&lt;h1 id=&#34;web&#34;&gt;Web&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTTP를 이용하여 정보를 공유하는 인터넷 기반 서비스를 Web이라 한다.&lt;/li&gt;
&lt;li&gt;정보 제공자를 Web Server, 정보 수신자를 Web Client라 칭한다.&lt;/li&gt;
&lt;li&gt;현재의 웹은 단순 정보 제공을 떠나 서비스를 제공하는 형태로 발전하고 있으며, &lt;code&gt;Front end&lt;/code&gt; 와 &lt;code&gt;Back end&lt;/code&gt; 로 역할이 나뉘어지고 있다.
&lt;ul&gt;
&lt;li&gt;Front end : &lt;code&gt;Web resource&lt;/code&gt;로 구성된 사용자에게 직접 보여지는 부분&lt;/li&gt;
&lt;li&gt;Back end : 사용자에게 직접 보여지지는 않지만 서비스 제공을 위해 구동되는 부분&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web-resource&#34;&gt;Web Resource&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;웹에 갖춰진 정보 자산을 의미하며, 사용자에게 제공되어 화면을 구성하는데 사용된다.&lt;/li&gt;
&lt;li&gt;고유한 식별자인 Uniform Resource Identifier (URI)를 가진다.&lt;/li&gt;
&lt;li&gt;대표적인 웹 리소스의 종류
&lt;ul&gt;
&lt;li&gt;Hyper Text Markup Language (HTML) : 태그와 속성을 통한 구조화된 문서 작성에 사용. &lt;a href=&#34;https://aswinblue.github.io/Blog/post/webapplication/html/&#34;&gt;설명 참조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Cascading Style Sheets (CSS) : 웹 문서의 외형을 조절하는데 사용. &lt;a href=&#34;https://aswinblue.github.io/Blog/post/webapplication/css/&#34;&gt;설명 참조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScript (JS) : 이용자의 브라우저에서 실행되는 코드로 front end 의 동작을 결정. &lt;a href=&#34;https://aswinblue.github.io/Blog/post/webapplication/javascript/&#34;&gt;설명 참조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;li&gt;image&lt;/li&gt;
&lt;li&gt;video&lt;/li&gt;
&lt;li&gt;font&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;web-browser&#34;&gt;Web browser&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Client 의 위치에서 Server 와 HTTP 통신을 수행해주고 그 결과를 가시화 해 주는 도구로, 사용자가 HTTP 통신을 직접 알지 못해도 Web을 사용할 수 있게 해 준다.&lt;/li&gt;
&lt;li&gt;동작 순서
&lt;ol&gt;
&lt;li&gt;URL 분석&lt;/li&gt;
&lt;li&gt;DNS 요청&lt;/li&gt;
&lt;li&gt;HTTP Request&lt;/li&gt;
&lt;li&gt;get HTTP Respond&lt;/li&gt;
&lt;li&gt;리소스 다운로드 및 웹 랜더링&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dev-tool&#34;&gt;Dev Tool&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Web browser 에서 사용할 수 있는 개발자 도구&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + U&lt;/code&gt; : 소스코드 보기 단축키&lt;/li&gt;
&lt;li&gt;&lt;code&gt;console.log&lt;/code&gt; : 콘솔창에 로그 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document.cookie&lt;/code&gt; : 콘솔창에서 쿠키 출력&lt;/li&gt;
&lt;li&gt;&lt;code&gt;location.href&lt;/code&gt; : 전체 URL 을 반환하거나, URL을 업데이트&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;urluniform-resource-locator&#34;&gt;URL(Uniform Resource Locator)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;웹에 있는 리소스의 위치를 표현하는 문자열&lt;/li&gt;
&lt;li&gt;URL 의 구성 요소
&lt;ul&gt;
&lt;li&gt;Scheme: 웹 서버와 어떤 프로토콜로 통신할지 나타냅니다.&lt;/li&gt;
&lt;li&gt;Host: Authority의 일부로, 접속할 웹 서버의 주소에 대한 정보를 가지고 있습니다.&lt;/li&gt;
&lt;li&gt;Port: Authority의 일부로, 접속할 웹 서버의 포트에 대한 정보를 가지고 있습니다.&lt;/li&gt;
&lt;li&gt;Path: 접근할 웹 서버의 리소스 경로로 &amp;lsquo;/&amp;lsquo;로 구분됩니다.&lt;/li&gt;
&lt;li&gt;Query: 웹 서버에 전달하는 파라미터이며 URL에서 &amp;lsquo;?&amp;rsquo; 뒤에 위치합니다.&lt;/li&gt;
&lt;li&gt;Fragment: 메인 리소스에 존재하는 서브 리소스를 접근할 때 이를 식별하기 위한 정보를 담고 있습니다. &amp;lsquo;#&amp;rsquo; 문자 뒤에 위치합니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;domain-name&#34;&gt;Domain name&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;숫자의 조합으로 이루어진 IP 주소를 사람이 읽기 쉬운 형태의 문자열로 대체한 형태&lt;/li&gt;
&lt;li&gt;Domain name 을 사용하기 위해서는 DNS가 필요하다.&lt;/li&gt;
&lt;li&gt;DNS(Domain Name Server) 에 Domain name 을 질의하면 DNS 는 매핑되는 IP 를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;콘솔의 nslookup  명령으로 domain name 정보를 확인할 수 있다.&lt;br&gt;
ex) &lt;code&gt;nslookup google.com&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTTP</title>
      <link>https://aswinblue.github.io/Blog/post/webhacking/http/</link>
      <pubDate>Thu, 06 Mar 2025 20:17:24 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webhacking/http/</guid>
      <description>&lt;h1 id=&#34;httphyper-text-transfer-protocol&#34;&gt;HTTP(Hyper Text Transfer Protocol)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;서버와 클라이언트의 데이터 교환을 요청(Request)과 응답(Response) 형식으로 정의한 프로토콜로, 웹 서비스의 근간이 되는 텍스트 교환 프로토콜이다.&lt;/li&gt;
&lt;li&gt;주로 클라이언트가 요청을 하면 서버가 응답을 해 주는 방식이며, 서버는 클라이언트의 요청을 받기 위해 socket 통신으로 80번 (혹은 8080번) 포트를 상시 열어놓고 대기한다.&lt;/li&gt;
&lt;li&gt;HTTP 프로토콜은 ISO 7계층 중 Application layer에 해당하며, transport layer 에 TCP 프로토콜을 사용할 떄 80번 포트를 HTTP 프로토콜 용으로 할당받는다.
&lt;ul&gt;
&lt;li&gt;0 ~ 1023 번 까지 port는 well-known 포트로, 시스템 혹은 네트워크에서 공공연히 사용되는 프로토콜들의 포트들이 할당되어 있고, HTTP 프로토콜도 그 중 하나이다.&lt;/li&gt;
&lt;li&gt;80번 포트에 HTTP가, 443 포트에 HTTPS가 할당되어 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Connectionless&lt;/code&gt;와 &lt;code&gt;Stateless&lt;/code&gt; 라는 특징이 있다.
&lt;ul&gt;
&lt;li&gt;Connectionless: 하나의 요청에 하나의 응답을 한 후 연결을 종료하는 것을 의미합니다. 특정 요청에 대한 연결은 이후의 요청과 이어지지 않고 새 요청이 있을 때 마다 항상 새로운 연결을 맺음.&lt;/li&gt;
&lt;li&gt;Stateless: 통신이 끝난 후 상태 정보를 저장하지 않는 것을 의미합니다. 이전 연결에서 사용한 데이터를 다른 연결에서 요구할 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프로토콜-상세&#34;&gt;프로토콜 상세&lt;/h2&gt;
&lt;h3 id=&#34;패킷-구조&#34;&gt;패킷 구조&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;headers
&lt;ul&gt;
&lt;li&gt;headers는 &lt;code&gt;CRLF&lt;/code&gt;(Carriage Return Line Feed) 로 한 줄을 구분하며, 첫 줄은 &lt;code&gt;Start line&lt;/code&gt;, 이후 나머지 줄들은 모두 &lt;code&gt;header&lt;/code&gt; 라 부른다.&lt;/li&gt;
&lt;li&gt;headers 의 끝은 빈 줄로 나타낸다.&lt;/li&gt;
&lt;li&gt;headers 는 &lt;code&gt;field&lt;/code&gt; 와 &lt;code&gt;value&lt;/code&gt; 로 구성되어 HTTP 메시지의 속성 또는 body 의 속성을 나타낸다.&lt;/li&gt;
&lt;li&gt;HTTP 메시지에는 0개 이상의 headers 가 존재할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;body
&lt;ul&gt;
&lt;li&gt;headers 의 마지막 &lt;code&gt;CRLF&lt;/code&gt; 다음 모든 줄을 body라 칭한다.&lt;/li&gt;
&lt;li&gt;상대방에게 전하려는 실제 데이터가 들어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;패킷-종류&#34;&gt;패킷 종류&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc2616.html#section-5&#34;&gt;HTTP 패킷 참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Request
&lt;ul&gt;
&lt;li&gt;시작줄에 Method, Request target, HTTP version 가 작성되며, 띄어쓰기로 구분된다.&lt;/li&gt;
&lt;li&gt;Method
&lt;ul&gt;
&lt;li&gt;GET:  특정 리소스의 표시를 요청합니다. GET을 사용하는 요청은 오직 데이터를 받기만 합니다.&lt;/li&gt;
&lt;li&gt;HEAD: GET 메서드의 요청과 동일한 응답을 요구하지만, 응답 본문을 포함하지 않습니다.&lt;/li&gt;
&lt;li&gt;POST: 특정 리소스에 엔티티를 제출할 때 쓰입니다. 이는 종종 서버의 상태의 변화나 부작용을 일으킵니다.&lt;/li&gt;
&lt;li&gt;PUT: 목적 리소스 모든 현재 표시를 요청 payload로 바꿉니다.&lt;/li&gt;
&lt;li&gt;DELETE: 특정 리소스를 삭제합니다.&lt;/li&gt;
&lt;li&gt;CONNECT: 목적 리소스로 식별되는 서버로의 터널을 맺습니다.&lt;/li&gt;
&lt;li&gt;OPTIONS: 목적 리소스의 통신을 설정하는 데 쓰입니다.&lt;/li&gt;
&lt;li&gt;TRACE: 목적 리소스의 경로를 따라 메시지 loop-back 테스트를 합니다.&lt;/li&gt;
&lt;li&gt;PATCH: 리소스의 부분만을 수정하는 데 쓰입니다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Request Target
&lt;ul&gt;
&lt;li&gt;URI라고도 불리며, 서비스 내에서 메소드를 처리할 하위 대상을 지정하는 용도이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP version
&lt;ul&gt;
&lt;li&gt;프로토콜의 버전을 나타낸다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Response
&lt;ul&gt;
&lt;li&gt;요청에 대한 회신을 담아내는 패킷으로, 요청 결과를 숫자로 표현한 상태 코드를 담고 있다.&lt;/li&gt;
&lt;li&gt;상태 코드는 첫 숫자에 따라 아래와 같은 의미를 지닌다.
&lt;ul&gt;
&lt;li&gt;1xx: 요청을 제대로 받았고, 처리가 진행 중임&lt;/li&gt;
&lt;li&gt;2xx: 요청이 제대로 처리됨
&lt;ul&gt;
&lt;li&gt;200(OK): 성공&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3xx: 요청을 처리하려면, 클라이언트가 추가 동작을 취해야 함.
&lt;ul&gt;
&lt;li&gt;302(Found): 다른 URL로 갈 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;4xx: 클라이언트가 잘못된 요청을 보내어 처리에 실패
&lt;ul&gt;
&lt;li&gt;400(Bad Request): 요청이 문법에 맞지 않음&lt;/li&gt;
&lt;li&gt;401(Unauthorized): 클라이언트가 요청한 리소스에 대한 인증이 실패함&lt;/li&gt;
&lt;li&gt;403(Forbidden): 클라이언트가 리소스에 요청할 권한이 없음&lt;/li&gt;
&lt;li&gt;404(Not Found): 리소스가 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;5xx: 클라이언트의 요청은 유효하지만, 서버에 에러가 발생하여 처리에 실패
&lt;ul&gt;
&lt;li&gt;500(Internal Server Error): 서버가 요청을 처리하다가 에러가 발생함&lt;/li&gt;
&lt;li&gt;503(Service Unavailable): 서버가 과부하로 인해 요청을 처리할 수 없음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.rfc-editor.org/rfc/rfc2616.html#section-6&#34;&gt;상태코드 참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;httpshttp-over-secure-socket-layer&#34;&gt;HTTPS(HTTP over Secure socket layer)&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTTP는 평문으로 전달하기 때문에, 패킷이 유출되면 중요 정보가 노출될 수 있다.&lt;/li&gt;
&lt;li&gt;보안 위협을 방지하기 위해 TLS(Transport Layer Security) 프로토콜을 도입한 HTTP의 변형 프로토콜이 HTTPS 이다.&lt;/li&gt;
&lt;li&gt;평문 대신 암호화된 구문을 전송하며 복호화를 위한 키가 있어야 내용을 읽을 수 있다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Unit Test</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/unit_test/</link>
      <pubDate>Mon, 19 Aug 2024 04:00:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/unit_test/</guid>
      <description>&lt;h1 id=&#34;unit-test&#34;&gt;Unit Test&lt;/h1&gt;
&lt;h2 id=&#34;테스트의-속성&#34;&gt;테스트의 속성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;좋은 단위 테스트를 작성하기 위해서는 아래 세 가지 기준을 만족해야 한다.
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;가독성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;3A(Arrange / Act / Assert) 순서대로 test case 코드가 작성되어 있어야 한다.&lt;/li&gt;
&lt;li&gt;test case 가 어떤 동작을 검증하는지 알 수 있어야 한다.
&lt;ul&gt;
&lt;li&gt;test case 의 이름을 명확하게 작성 필요&lt;/li&gt;
&lt;li&gt;최신 test framework (java 에서 사용하는 spock)에서는 자연어로 test case 이름을 작성할 수 있도록 지원하는 경우도 있다. (google test 는 미지원)&lt;/li&gt;
&lt;li&gt;test case 실행 시 printf 문을 한 번 출력 하도록 규칙을 정하여 사용할 수 있다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define SPEC(msg) printf(&amp;#34;[SPEC] %s\n&amp;#34;, msg)
TEST(SampleTestCase, SampleTest) {
    SPEC(&amp;#34;이 테스트는 무엇을 하는 테스트 입니다&amp;#34;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;코드를 보지 않고 오류의 원인을 알 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;자연여와 가깝게 테스트 코드를 표현하는 것이 유리하다.
&lt;ul&gt;
&lt;li&gt;함수 이름을 자연어로 상세히 지정&lt;/li&gt;
&lt;li&gt;에러 메시지를 자연어로 출력&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;유지보수성&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Window_programming</title>
      <link>https://aswinblue.github.io/Blog/post/windowapp/window_programming/</link>
      <pubDate>Sun, 12 May 2024 16:02:25 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/windowapp/window_programming/</guid>
      <description>&lt;h1 id=&#34;window-programming&#34;&gt;Window Programming&lt;/h1&gt;
&lt;h2 id=&#34;pe&#34;&gt;PE&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;윈도우는 실행 가능한 목적 파일을 &lt;code&gt;PE&lt;/code&gt; 포멧이라 칭한다. (리눅스의 ELF 와 유사)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PE&lt;/code&gt; 파일은 header 와 section 으로 구성된다.&lt;/li&gt;
&lt;li&gt;section 에는 이름, 크기, 로드될 주소의 오프셋, 속성과 권한 등의 정보가 들어있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PE&lt;/code&gt; 파일에 들어가야 할 필수 section 은 없지만, &amp;lsquo;.text&amp;rsquo;, &amp;lsquo;.data&amp;rsquo;, &amp;lsquo;.rdata&amp;rsquo; section 이 주로 사용된다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;: 실행 가능한 기계코드가 위치하는 영역 (읽기, 쓰기 가능)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;: 컴파일 시점에 정해진 전역 변수들이 위치하는 영역 (읽기, 쓰기 가능)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rdata&lt;/code&gt;: 컴파일 시점에 값이 정해진 전역 상수와 참조할 DLL 및 외부 함수들의 정보가 위치하는 영역 (읽기만 가능)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;윈도우가 실행되면 &lt;code&gt;PE&lt;/code&gt; 파일의 데이터들이 메모리에 적재된다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Reverse Engineering</title>
      <link>https://aswinblue.github.io/Blog/post/systemhacking/reverse_engineering/</link>
      <pubDate>Sun, 12 May 2024 14:42:07 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/systemhacking/reverse_engineering/</guid>
      <description>&lt;h1 id=&#34;reverse-engineering&#34;&gt;Reverse Engineering&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;software 를 분석하여 소스코드를 역으로 생성 해 내는 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;software-분석-방법&#34;&gt;software 분석 방법&lt;/h2&gt;
&lt;h3 id=&#34;static-analysis&#34;&gt;Static analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로그램을 실행시키지 않고 수행하는 분석이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;프로그램의 전체 구조를 파악하기 쉬우며, 환경적 제약 사항에 자유롭고, 악성 코드의 위협으로부터 안전하다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;난독화 적용시 분석이 어려워 진다는 단점이 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;정적분석에 사용되는 툴로는 &lt;code&gt;IDA&lt;/code&gt; 가 있다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;IDA&lt;/code&gt; 는 프리웨어로 &lt;a href=&#34;https://hex-rays.com/ida-free/&#34;&gt;https://hex-rays.com/ida-free/&lt;/a&gt; 에서 다운 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;dynamic-analysis&#34;&gt;Dynamic analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;프로그램을 실행시키며 수행하는 분석이다.&lt;/li&gt;
&lt;li&gt;프로그램의 개략적인 동작을 빠르게 확인 할 수 있다.&lt;/li&gt;
&lt;li&gt;정적 분석과 반대로 프로그램 실행에 필요한 환경 구성이 어려울 수 있다.&lt;/li&gt;
&lt;li&gt;안티 디버깅 기법 적용된 프로그램은 디버깅이 불가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ida&#34;&gt;IDA&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;리버스 엔지니어링 툴&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;단축어&#34;&gt;단축어&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;shift + F12
&lt;ul&gt;
&lt;li&gt;문자열 검색, String 탭으로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;상호참조 확인, 변수 또는 함수가 사용되는 곳의 위치를 확인&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F5
&lt;ul&gt;
&lt;li&gt;어셈블리를 C 언어 형태로 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;특정 주소 혹은 라인으로 이동&lt;/li&gt;
&lt;li&gt;디컴파일 된 함수 이름 위에 커서를 놓고 g 를 누르면 어셈블리 상 함수 라인을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;함수 이름을 적어도 함수 위치로 이동된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ESC
&lt;ul&gt;
&lt;li&gt;이전 커서 위치로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Ctrl + Enter
&lt;ul&gt;
&lt;li&gt;다음 커서 위치로 이동&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;변수 이름 바꾸기&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Y&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;변수 타입 설정&lt;/li&gt;
&lt;li&gt;함수 매개변수 변경, 함수 매개변수 타입 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F2
&lt;ul&gt;
&lt;li&gt;어셈블리 혹은 C 언어 라인에서는 break point(중단점) 설정&lt;/li&gt;
&lt;li&gt;stack 또는 hex View 에서는 값 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F9&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;실행 (run)&lt;/li&gt;
&lt;li&gt;프로그램을 실행시켜 동적 분석을 수행할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;F8&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;한 단계 실행 (next)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;F7&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;함수 내부로 진입 (step int)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;Ctrl + F2&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;디버깅 중단&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;14&#34;&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;hex 데이터를 문자로 변환&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;15&#34;&gt;
&lt;li&gt;Shift + E&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;선택한 값을 원하는 형태로 변환하여 추출(export)&lt;/li&gt;
&lt;li&gt;hex 데이터를 문자열로 추출할 때 유용하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;화면&#34;&gt;화면&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;IDA View&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Exploit</title>
      <link>https://aswinblue.github.io/Blog/post/systemhacking/exploit/</link>
      <pubDate>Mon, 11 Mar 2024 20:46:33 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/systemhacking/exploit/</guid>
      <description>&lt;h1 id=&#34;exploit&#34;&gt;Exploit&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pwntool&lt;/code&gt;의 &lt;code&gt;checksec&lt;/code&gt; 명령어로 어떤 보안이 적용되었는지 확인 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;shell-code&#34;&gt;Shell Code&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.&lt;/li&gt;
&lt;li&gt;Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 &amp;lsquo;Shell Code&amp;rsquo; 라 칭한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;환경세팅&#34;&gt;환경세팅&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../pwntool/#%EC%84%A4%EC%B9%98&#34;&gt;pwntools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../pwntool/#checksec&#34;&gt;checksec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../pwntool/#shellcraft&#34;&gt;shellcraft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;../pwntool/#ropgadget&#34;&gt;ROPgadget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aswinblue.github.io/Blog/post/systemhacking/pwntool/#one_gadget&#34;&gt;one_gadget&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://aswinblue.github.io/Blog/post/systemhacking/pwntool/#patchelf&#34;&gt;patchelf&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;취약점-공격-순서&#34;&gt;취약점 공격 순서&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;바이너리를 분석하여 보호기법을 확인한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;checksec&lt;/code&gt; 명령어를 사용하여 바이너리에 적용된 보호기법을 확인하고, 적용 불가능한 exploit 기법을 추려낸다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../pwntool/#checksec&#34;&gt;checksec 참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldd&lt;/code&gt; 명령을 활용하여 의존성 관계를 확인한다.
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../Linux/linux_command/#%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A0%A8&#34;&gt;ldd 명령&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;코드를 확인하여 취약점 및 구조(stack 형태)을 파악한다&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;stack은 함수에서 선언된 순서대로 할당되지 않음에 주의하며, 무조건 assembly어를 통해 stack 주소에서 특정 변수의 위치를 확인하도록 한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pwntool</title>
      <link>https://aswinblue.github.io/Blog/post/systemhacking/pwntool/</link>
      <pubDate>Sat, 09 Mar 2024 10:09:44 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/systemhacking/pwntool/</guid>
      <description>&lt;h1 id=&#34;pwntool&#34;&gt;pwntool&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;시스템 해킹을 위해 제작된 파이썬 라이브러리&lt;/li&gt;
&lt;li&gt;바이너리를 실행하고 특정 input을 집어넣어 해킹(exploit)을 할수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리눅스의 apt와 파이썬의 pip 명령으로 설치가 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
$ python3 -m pip install --upgrade pip
$ python3 -m pip install --upgrade pwntools
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.pwntools.com/en/latest/&#34;&gt;공식 메뉴얼&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;docker를 사용한 설치 방법
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM ubuntu:18.04

ENV PATH=&amp;#34;${PATH}:/usr/local/lib/python3.6/dist-packages/bin&amp;#34;
ENV LC_CTYPE=C.UTF-8

RUN apt update
RUN apt install -y \
   gcc \
   git \
   python3 \
   python3-pip \
   ruby \
   sudo \
   tmux \
   vim \
   wget

# install pwndbg
WORKDIR /root
RUN git clone https://github.com/pwndbg/pwndbg
WORKDIR /root/pwndbg
RUN git checkout 2023.03.19
RUN ./setup.sh

# install pwntools
RUN pip3 install --upgrade pip
RUN pip3 install pwntools

# install one_gadget command
RUN gem install one_gadget

WORKDIR /root
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;에러-발생시-해결&#34;&gt;에러 발생시 해결&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;partially initialized module &#39;pwndbg&#39; has no attribute &#39;lib&#39;&lt;/code&gt; 에러 발생시에는 쉘 명령어에 &lt;code&gt;export LANG=C.UTF-8&lt;/code&gt; 를 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;사용법&#34;&gt;사용법&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;from pwn import *&lt;/code&gt; 을 통해 모듈을 로딩한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행&#34;&gt;실행&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;process / remote
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target = process(파일경로)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;로컬 파일을 exploit 하기위한 대상으로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;env&lt;/code&gt; 인자를 추가하여 프로그램 동작시 적용될 환경변수를 설정할 수 있다.
&lt;ul&gt;
&lt;li&gt;다음은 libc 파일을 원하는 경로에서 링킹 하도록 설정하는 구문이다. :  &lt;code&gt;target = process(&#39;./a.out&#39;, env= {&amp;quot;LD_PRELOAD&amp;quot; : &amp;quot;./libc.so.6&amp;quot;})&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;target = remote(&#39;목적지 ip&#39;, 목적지 port)&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;ip:port 에 연결된 소켓을 exploit target으로 설정한다.&lt;/li&gt;
&lt;li&gt;원격으로 접속한 목적지의 파일을 exploit 할 때 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터-송수신&#34;&gt;데이터 송수신&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;send&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Assembly_basic</title>
      <link>https://aswinblue.github.io/Blog/post/assembly/assembly_basic/</link>
      <pubDate>Wed, 21 Feb 2024 20:10:48 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/assembly/assembly_basic/</guid>
      <description>&lt;h1 id=&#34;assembly&#34;&gt;Assembly&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;기계어로 1대1 대응 가능한 언어로, human readable 한 언어 중 가장 기계어에 가까운 언어이다. 기계어로 컴파일 직전에 어셈블리어로 변환을 거친다.&lt;/li&gt;
&lt;li&gt;operation code(명령어) 와 operand(피연산자) 로 구성된다.&lt;/li&gt;
&lt;li&gt;명령어는 데이터 이동, 산술연산, 논리연산, 비교, 분기, 스택, 프로시저, 시스템콜의 종류가 있다.&lt;/li&gt;
&lt;li&gt;피연산자 자리에는 상수(Immediate Value), 레지스터(Register), 메모리(Memory)가 올 수 있다.
&lt;ul&gt;
&lt;li&gt;숫자를 넣으면 상수이다.&lt;/li&gt;
&lt;li&gt;[] 로 둘러싸인 숫자는 메모리이다.&lt;/li&gt;
&lt;li&gt;메모리 피연산자 앞에는 메모리의 크기를 나타내는 크기 지정자(Size Directive)가 붙을 수 있다.
&lt;ul&gt;
&lt;li&gt;BYTE: 8bit
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;BYTE PTR rax&lt;/code&gt; : rax 레지스터의 데이터를 1바이트만큼 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;WORD: 16bit
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WORD PTR [0x8048000]&lt;/code&gt; : 0x8048000의 데이터를 2바이트만큼 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DWORD: 32bit&lt;/li&gt;
&lt;li&gt;QWORD: 64bit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;명령어&#34;&gt;명령어&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;mov
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;값&amp;quot;을 레지스터리나 메모리에 저장하는 명령&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov dst, src&lt;/code&gt; : src 값을 dst에 덮어씀
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mov rdi, rsi&lt;/code&gt; : rsi의 값을 rdi에 대입&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov QWORD PTR[rdi], rsi&lt;/code&gt; : rsi의 값을 rdi가 가리키는 주소에 대입&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov QWORD PTR[rdi + 8 * rcx], rsi&lt;/code&gt; : rsi의 값을 (rdi + 8 * rcx)가 가리키는 주소에 대입&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dst = 레지스터, src = 레지스터 : src가 가리키는 주소의 값을 dst가 가리키는 주소의 값에 덮어씀&lt;/li&gt;
&lt;li&gt;dst = 메모리, src = 레지스터 : src가 가리키는 주소의 값을 dst가 가리키는 주소의 값에 덮어씀&lt;/li&gt;
&lt;li&gt;dst = 레지스터, src = 메모리 : src가 가리키는 주소의 값을 dst가 가리키는 주소의 값에 덮어씀&lt;/li&gt;
&lt;li&gt;dst = 메모리, src = 메모리 : 불가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov dst, [mem + 4]&lt;/code&gt; : mem + 4 주소에 저장된 값을 dst에 덮어씀&lt;/li&gt;
&lt;li&gt;dst 값으로는 주소나 포인터가 올 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;lea
&lt;ul&gt;
&lt;li&gt;&amp;ldquo;주소&amp;quot;를 레지스터리나 메모리에 저장하는 명령&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lea dst, src&lt;/code&gt; : src값을 dst에 덮어씀 (src는 주소값)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lea rsi, [rbx + 8 * rcx]&lt;/code&gt; : (rbx + 8 * rcx) 를 rsi에 대입&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lea dst, [mem + 4]&lt;/code&gt; : mem 값에 4를 더한 값을 dst에 덮어씀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;add
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add dst, src&lt;/code&gt; : dst 에 있는 값에 src 값을 더해 dst에 덮어씀&lt;/li&gt;
&lt;li&gt;dst는 주소, src는 값&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;sub
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sub dst, src:&lt;/code&gt; : dst 에 있는 값에 src 값을 빼고 dst 주소에 덮어씀&lt;/li&gt;
&lt;li&gt;dst는 주소, src는 값&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;inc
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;inc op&lt;/code&gt; : op 에 있는 값을 1 증가시킴&lt;/li&gt;
&lt;li&gt;op는 주소&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;dec
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dec op&lt;/code&gt; : op 에 있는 값을 1 감소시킴&lt;/li&gt;
&lt;li&gt;op는 주소&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;and
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;and dst, src&lt;/code&gt; : src와 dst 값을 and 연산한 결과를 dst에 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;or
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;or dst, src&lt;/code&gt; : src와 dst 값을 or 연산한 결과를 dst에 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;xor
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;xor dst, src&lt;/code&gt; : src와 dst 값을 xor 연산한 결과를 dst에 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;not&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;not op&lt;/code&gt; : op 값을 not 연산한 값을 op에 저장&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;comp
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmp rax, rbx&lt;/code&gt; : rax 값과 rbx 값을 비교한 후, 결과에 따라 플래그 설정&lt;/li&gt;
&lt;li&gt;if rax == rbx: ZF = 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;test
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;test rax, rbx&lt;/code&gt; : rax 값과 rbx 값을 and 연산 후, 결과에 따라 플래그 설정&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jmp
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jmp addr&lt;/code&gt; : addr 주소로 rip를 이동한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;je
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;je addr&lt;/code&gt; : 직전에 비교한 &lt;code&gt;cmp rax rbx&lt;/code&gt; 연산에서  rax == rbx 라면 addr로 rip 를 이동한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;jg
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;jg addr&lt;/code&gt; : 직전에 비교한 &lt;code&gt;cmp rax rbx&lt;/code&gt; 연산에서  rax &amp;gt; rbx 라면 addr로 rip 를 이동한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;push
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;push val&lt;/code&gt; : 스택의 최상단에 &amp;lsquo;val&amp;rsquo; 값을 집어넣는다.&lt;/li&gt;
&lt;li&gt;rsp 를 한칸 위로 옮기고, 그 위치에 &amp;lsquo;val&amp;rsquo;을 대입한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsp -= 8; [rsp] = val&lt;/code&gt; 동작과 동일하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push val&lt;/code&gt; 형태로는 4byte 데이터밖에 주입할 수 없으므로, 4byte를 초과하는 데이터를 주입할 때는 값을 레지스터에 대입하고, 레지스터를 push한다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;   mov rax 0x0102030405060708
   push rax
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;pop
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pop rax&lt;/code&gt; : 스택의 최상단에 있는 값을 &amp;lsquo;rax&amp;rsquo; 주소에 대입한다.&lt;/li&gt;
&lt;li&gt;rsp 위치의 값을 반환하고, rsp 를 한칸 밑으로 옮긴다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rsp += 8; reg = [rsp-8]&lt;/code&gt; 동작과 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;call
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;call addr&lt;/code&gt; &amp;lsquo;addr&amp;rsquo; 위치의 프로시저를 호출&lt;/li&gt;
&lt;li&gt;&amp;lsquo;push&amp;rsquo; 명령과 &amp;lsquo;jump&amp;rsquo; 명령으로 구현할 수 있다.
&lt;ul&gt;
&lt;li&gt;스택에 다음 실행 주소를 push한다. (push rip + 8)&lt;/li&gt;
&lt;li&gt;rip를 실행시키고 싶은 명령어가 적힌 주소로 이동한다. (jump)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;leave&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;rsp를 rbp + 8 위치로 이동한다.&lt;/li&gt;
&lt;li&gt;rbp도 갱신한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mov rsp, rbp; pop rbp&lt;/code&gt; 명령과 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;20&#34;&gt;
&lt;li&gt;ret
&lt;ul&gt;
&lt;li&gt;rip를 rsp가 가리키는 스택의 주소에 담긴 값으로 이동한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop rip&lt;/code&gt; 명령과 동일하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;시스템콜&#34;&gt;시스템콜&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;운영체제는 하드웨어 및 소프트웨어를 총괄하며, 접근 권한을 제한하여 해킹으로부터 컴퓨터를 보호하기 위해 커널 모드와 유저 모드로 권한을 분리한다.&lt;/li&gt;
&lt;li&gt;시스템 콜은 유저모드에서 시스템에게 커널 모드에서 실행할 수 있는 동작들을 요청하는 동작이다.
&lt;ul&gt;
&lt;li&gt;유저가 시스템 콜을 호출하면 커널은 이를 실행하고, 결과를 유저에게 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;레지스터&#34;&gt;레지스터&lt;/h2&gt;
&lt;h3 id=&#34;범용-레지스터&#34;&gt;범용 레지스터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;../../computerscience/computer_science/#x86-64-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0&#34;&gt;x86-64 아키텍처 레지스터 참조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;r0 ~ r15까지 존재하며, r0 ~ r7 까지는 이름이 붙고, r8부터 r15까지는 숫자로 부른다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;rax : (Extended Accumulator Register) 사칙연산에서 자동으로 피연산자의 값이 저장된다.
&lt;ul&gt;
&lt;li&gt;논리 연산(덧셈, 뺄셈 등)의 결과값이 저장된다.&lt;/li&gt;
&lt;li&gt;피연산자와 별개로 데이터가 저장된다.&lt;/li&gt;
&lt;li&gt;시스템 콜의 실질적인 번호를 가리킴&lt;/li&gt;
&lt;li&gt;시스템 콜의 반환값도 rax에 저장됨&lt;/li&gt;
&lt;li&gt;x64구조에서 rax 를 사용하고, x86구조에서는 eax 를 사용했다.&lt;/li&gt;
&lt;li&gt;ax : eax가 사용되기 이전, CPU의 word가 16bit 일 때 사용되던 레지스터&lt;/li&gt;
&lt;li&gt;큰 의미는 없지만 관습처럼 사용되며 eax에서 하위 2byte를 자른 값을 나타낸다.&lt;/li&gt;
&lt;li&gt;ax 는 다시 ah와 al로 한 byte씩 나뉜다.
&lt;ul&gt;
&lt;li&gt;ah : ax에서 상위 1byte&lt;/li&gt;
&lt;li&gt;al : ax에서 하위 1byte&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;byte_8&lt;/th&gt;
          &lt;th&gt;byte_7&lt;/th&gt;
          &lt;th&gt;byte_6&lt;/th&gt;
          &lt;th&gt;byte_5&lt;/th&gt;
          &lt;th&gt;byte_4&lt;/th&gt;
          &lt;th&gt;byte_3&lt;/th&gt;
          &lt;th&gt;byte_2&lt;/th&gt;
          &lt;th&gt;byte_1&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;rax_8&lt;/td&gt;
          &lt;td&gt;rax_7&lt;/td&gt;
          &lt;td&gt;rax_6&lt;/td&gt;
          &lt;td&gt;rax_5&lt;/td&gt;
          &lt;td&gt;rax_4&lt;/td&gt;
          &lt;td&gt;rax_3&lt;/td&gt;
          &lt;td&gt;rax_2&lt;/td&gt;
          &lt;td&gt;rax_1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;eax_4&lt;/td&gt;
          &lt;td&gt;eax_3&lt;/td&gt;
          &lt;td&gt;eax_2&lt;/td&gt;
          &lt;td&gt;eax_1&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;ax_2&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;-&lt;/td&gt;
          &lt;td&gt;ah&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rbx(ebx) : (Extended Base register)메모리 주소를 저장하는 용도로 사용&lt;/li&gt;
&lt;li&gt;rcx(ecx) : (Extended Counter Register)CPU loop counter&lt;/li&gt;
&lt;li&gt;rdx(edx) : 시스템 콜 실행 시 세 번째 인자의 주소 / (Extended Data Register)&lt;/li&gt;
&lt;li&gt;rsi : 시스템 콜 실행시 두 번째 인자의 주소 / (source index) 데이터 이동시 원본을 가리키는 주소
&lt;ul&gt;
&lt;li&gt;x64구조에서 rsi 를 사용하고, x86구조에서는 esi 를 사용했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rdi : 함수 실행시 첫 번째 인자의 주소 / 시스템 콜 실행시 첫 번째 인자의 주소 / (destination index) 데이터 이동시 목적지를 가리키는 주소
&lt;ul&gt;
&lt;li&gt;x64구조에서 rdi 를 사용하고, x86구조에서는 edi 를 사용했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rbp : (Base Register Pointer)스택 복귀 주소
&lt;ul&gt;
&lt;li&gt;rbp 주소에는 함수가 종료되고 함수를 호출한 함수(caller) 의 스택 프레임으로 rbp를 이동하기 위한 주소 SFP(Stack Frame Pointer) 가 저장된다. 함수 호출시 호출자(caller)의 SFP를 stack에 넣고, 실행된 함수가 끝날 때 이를 pop하여 함수가 호출된 코드 라인으로 복귀할 수 있다.&lt;/li&gt;
&lt;li&gt;즉, 함수 호출 시마다 &lt;code&gt;push rbp&lt;/code&gt; 코드를 보게 될 것이다.&lt;/li&gt;
&lt;li&gt;x64구조에서 rbp 를 사용하고, x86구조에서는 ebp 를 사용했다.&lt;/li&gt;
&lt;li&gt;ebp : 스택 프레임 최하단의 주소값 (Base pointer register)
&lt;ul&gt;
&lt;li&gt;x86에서 사용하는 값으로, x64에서는 rbp로 대체된다.&lt;/li&gt;
&lt;li&gt;새로운 함수가 호출 될 경우, EBP 값이 스택에 push되어, 이전 함수의 EBP값이 스택에 쌓이게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;rsp : 스택의 최상단의 주소
&lt;ul&gt;
&lt;li&gt;x64구조에서 rsp 를 사용하고, x86구조에서는 esp 를 사용했다.&lt;/li&gt;
&lt;li&gt;esp : 스택 최상단의 주소값 (Stack pointer register)
&lt;ul&gt;
&lt;li&gt;PUSH, POP, SUB, CALL 명령을 수행 할 때 마다 자동으로 변경된다.&lt;/li&gt;
&lt;li&gt;PUSH, POP 의 기준이 되는 포인터이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;r8 ~ r15까지는 따로 명칭이 없다.&lt;/li&gt;
&lt;li&gt;각 레지스터들은 64비트 일때 하위 32비트(=32bit 시스템에서 사용하는 명칭), 하위 16bit, 하위 8bit 를 칭하는 명칭이 각각 존재한다.
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;64비트&lt;/th&gt;
          &lt;th&gt;하위32비트&lt;/th&gt;
          &lt;th&gt;하위16비트&lt;/th&gt;
          &lt;th&gt;하위8비트&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;rax&lt;/td&gt;
          &lt;td&gt;eax&lt;/td&gt;
          &lt;td&gt;ax&lt;/td&gt;
          &lt;td&gt;al&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rbx&lt;/td&gt;
          &lt;td&gt;ebx&lt;/td&gt;
          &lt;td&gt;bx&lt;/td&gt;
          &lt;td&gt;bl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rcx&lt;/td&gt;
          &lt;td&gt;ecx&lt;/td&gt;
          &lt;td&gt;cx&lt;/td&gt;
          &lt;td&gt;cl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rdx&lt;/td&gt;
          &lt;td&gt;edx&lt;/td&gt;
          &lt;td&gt;dx&lt;/td&gt;
          &lt;td&gt;dl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rsi&lt;/td&gt;
          &lt;td&gt;esi&lt;/td&gt;
          &lt;td&gt;si&lt;/td&gt;
          &lt;td&gt;sil&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rdi&lt;/td&gt;
          &lt;td&gt;edi&lt;/td&gt;
          &lt;td&gt;di&lt;/td&gt;
          &lt;td&gt;dil&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rbp&lt;/td&gt;
          &lt;td&gt;ebp&lt;/td&gt;
          &lt;td&gt;bp&lt;/td&gt;
          &lt;td&gt;bpl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;rsp&lt;/td&gt;
          &lt;td&gt;esp&lt;/td&gt;
          &lt;td&gt;sp&lt;/td&gt;
          &lt;td&gt;spl&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;r8&lt;/td&gt;
          &lt;td&gt;r8d&lt;/td&gt;
          &lt;td&gt;r8w&lt;/td&gt;
          &lt;td&gt;r8b&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;r9&lt;/td&gt;
          &lt;td&gt;r9d&lt;/td&gt;
          &lt;td&gt;r9w&lt;/td&gt;
          &lt;td&gt;r9b&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
          &lt;td&gt;&amp;hellip;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;r15&lt;/td&gt;
          &lt;td&gt;r15d&lt;/td&gt;
          &lt;td&gt;r15w&lt;/td&gt;
          &lt;td&gt;r15b&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;세그먼트-레지스터&#34;&gt;세그먼트 레지스터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cs, ss, ds, es, fs, gs
&lt;ul&gt;
&lt;li&gt;cs : code segment&lt;/li&gt;
&lt;li&gt;ds : data segment&lt;/li&gt;
&lt;li&gt;es : extra segment&lt;/li&gt;
&lt;li&gt;fs, gs : 앞선 세 개의 segment를 만들고 여유분 두개를 추가한 것. cs/ds/es는 CPU가 명확한 사용 용도를 가지는 반면 fs/gs는 정해진 용도가 없어 OS가 임의로 사용 가능
&lt;ul&gt;
&lt;li&gt;리눅스에서는 fs segment register를 Thread Local Storage(TLS) 의 포인터로 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;명령어-포인터-레지스터&#34;&gt;명령어 포인터 레지스터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Instruction Pointer Register, IP&lt;/li&gt;
&lt;li&gt;rip : 현재 명령 실행 주소
&lt;ul&gt;
&lt;li&gt;x64구조에서 rip 를 사용하고, x86구조에서는 eip 를 사용했다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;플래그-레지스터&#34;&gt;플래그 레지스터&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;CF(Carry Flag) : 부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 1로 세팅&lt;/li&gt;
&lt;li&gt;ZF(Zero Flag) : 연산의 결과가 0일 경우 1로 세팅&lt;/li&gt;
&lt;li&gt;SF(Sign Flag) : 연산의 결과가 음수일 경우 1로 세팅&lt;/li&gt;
&lt;li&gt;OF(Overflow Flag) : 부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 1로 세팅&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프로시저&#34;&gt;프로시저&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;특정 주소의 명령어를 실행하도록 하는 코드이다.&lt;/li&gt;
&lt;li&gt;프로시저를 사용하면 가독성이 높아지고, 반복되는 코드를 절약할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;section&#34;&gt;Section&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;object 파일 안에서 재배치 될 수 있는 가장 작은 단위를 섹션(section) 이라 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;objdump -h&lt;/code&gt; 로 목적파일의 Section을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;스택프레임&#34;&gt;스택프레임&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;각 함수들은 실행되면서 지역변수와 임시 값들을 저장해야 하는데, 이 값들은 스택 영역에 저장된다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Delver</title>
      <link>https://aswinblue.github.io/Blog/post/projects/delver/</link>
      <pubDate>Tue, 30 Jan 2024 21:21:43 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/projects/delver/</guid>
      <description>&lt;h1 id=&#34;delver&#34;&gt;Delver&lt;/h1&gt;
&lt;p&gt;시작날짜: March 18, 2023&lt;br&gt;
종료날짜: March 28, 2023&lt;/p&gt;
&lt;h2 id=&#34;목표&#34;&gt;목표&lt;/h2&gt;
&lt;p&gt;python 기반 웹 scrapping 및 결과를 slack 에 전송하는 slack bot&lt;/p&gt;
&lt;h2 id=&#34;요구사항&#34;&gt;요구사항&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AWS lambda를 사용하여 동작&lt;/li&gt;
&lt;li&gt;매 시간마다 동작하도록 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;delver-web-scrapper-작성&#34;&gt;[Delver]🔨 Web scrapper 작성&lt;/h1&gt;
&lt;h2 id=&#34;1-구현-내용&#34;&gt;1. 구현 내용&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;beautiful soup를 사용하여 특정 web을 scrap
(API 참조: &lt;a href=&#34;https://beautiful-soup-4.readthedocs.io/en/latest/&#34;&gt;https://beautiful-soup-4.readthedocs.io/en/latest/&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;여러 사이트에 호환되도록 구조를 설정&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://aswinblue.github.io/Blog/IMAGE_DELVER_WEB_SCRAPPER/Untitled.png&#34; alt=&#34;사이트별 속성을 json 형태로 기록&#34;  /&gt;
&lt;/p&gt;
&lt;p&gt;사이트별 속성을 json 형태로 기록&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://aswinblue.github.io/Blog/IMAGE_DELVER_WEB_SCRAPPER/Untitled1.png&#34; alt=&#34;json 형태를 읽어 코드 변경 없이 사이트 추가할 수 있는 구조로 작성&#34;  /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>FlickThrough</title>
      <link>https://aswinblue.github.io/Blog/post/projects/flick_through/</link>
      <pubDate>Tue, 30 Jan 2024 21:12:32 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/projects/flick_through/</guid>
      <description>&lt;h1 id=&#34;flick-through&#34;&gt;Flick Through&lt;/h1&gt;
&lt;p&gt;github: &lt;a href=&#34;https://github.com/AswinBlue/FlickThrough&#34;&gt;https://github.com/AswinBlue/FlickThrough&lt;/a&gt;&lt;br&gt;
Link : aswinblue.github.io/FlickThrough/&lt;br&gt;
시작날짜: August 21, 2023&lt;/p&gt;
&lt;h2 id=&#34;목표&#34;&gt;목표&lt;/h2&gt;
&lt;p&gt;텍스트 파일을 읽어 단어 단위로 슬라이드 쇼를 수행하는 앱 제작&lt;/p&gt;
&lt;h2 id=&#34;요구사항&#34;&gt;요구사항&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;텍스트 파일의 공백과 줄바꿈을 기준으로 단어를 나누고 이를 화면에 출력&lt;/li&gt;
&lt;li&gt;출력은 한 단어씩 이루어 지며 분당 300개를 기본으로, 속도는 조절 가능&lt;/li&gt;
&lt;li&gt;단어 자르는건 커스텀 가능&lt;/li&gt;
&lt;li&gt;특정 문자마다 딜레이 다르게 줄 수 있도록 설정&lt;/li&gt;
&lt;li&gt;스크린샷 혹은 클립보드의 내용도 사용할 수 있도록 함&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;기능-구현&#34;&gt;기능 구현&lt;/h1&gt;
&lt;h2 id=&#34;1-구현-내용&#34;&gt;1. 구현 내용&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;UI 구성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;텍스트가 출력될 텍스트박스, 진행률 표시바, 시작/일시정지 버튼, 속도 조절 스크롤바, 파일 읽기 버튼을 구성&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>IPC</title>
      <link>https://aswinblue.github.io/Blog/post/linux/ipc/</link>
      <pubDate>Thu, 27 Jul 2023 20:37:08 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/ipc/</guid>
      <description>&lt;h1 id=&#34;ipc-inter-process-communicatrion&#34;&gt;IPC (Inter Process Communicatrion)&lt;/h1&gt;
&lt;h2 id=&#34;signal&#34;&gt;Signal&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Signal은 프로세스간 동기화를 위해 프로세스간 전송하는 신호를 의미한다.&lt;/li&gt;
&lt;li&gt;Software Interrupt 라고도 한다.&lt;/li&gt;
&lt;li&gt;커널에서 &lt;code&gt;kill -&amp;lt;SIGNAL_NUMBER&amp;gt; &amp;lt;PROCESS_ID&amp;gt;&lt;/code&gt; 명령으로 특정 PROCESS_ID에 ISGNAL_NUMBER에 해당하는 signal을 전달할 수 있다.&lt;/li&gt;
&lt;li&gt;signal은 총 64까지 정의되어 있고 1&lt;del&gt;31까지가 일반적으로 사용하는 signal이다. 34&lt;/del&gt;63은 고성능 네트워크 통신을 위한 시그널이다. (32, 33는 미정의)
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;kill -l&lt;/code&gt;  명령으로 signal 리스트를 확인할 수 있다.
&lt;ol&gt;
&lt;li&gt;SIGHUP&lt;/li&gt;
&lt;li&gt;SIGINT : 인터럽트, Ctrl+C 명령으로 전송 가능&lt;/li&gt;
&lt;li&gt;SIGQUIT Coredump시 발생&lt;/li&gt;
&lt;li&gt;SIGILL : Illegal instruction&lt;/li&gt;
&lt;li&gt;SIGTRAP : debugger is tracing&lt;/li&gt;
&lt;li&gt;SIGABRT : Abort process&lt;/li&gt;
&lt;li&gt;SIGBUS : bus error&lt;/li&gt;
&lt;li&gt;SIGFPE : Floating point exception&lt;/li&gt;
&lt;li&gt;SIGKILL : 강제 종료&lt;/li&gt;
&lt;li&gt;SIGUSR1	: User-defined signal 1, 마음대로 사용 가능&lt;/li&gt;
&lt;li&gt;SIGSEGV	: invalid virtual memory reference&lt;/li&gt;
&lt;li&gt;SIGUSR2 : User-defined signal 2, 마음대로 사용 가능&lt;/li&gt;
&lt;li&gt;SIGPIPE	: 반대편이 연결되지 않은 pip에 신호 전송시 발생하는 에러&lt;/li&gt;
&lt;li&gt;SIGALRM : alarm() 함수에 의해 발생한 시그널 1&lt;/li&gt;
&lt;li&gt;SIGTERM : 종료 요청, SIGKILL(9)보다 안전한 종료 방법, SIGINT와 유사한 성능&lt;/li&gt;
&lt;li&gt;SIGSTKFLT : Stack fault&lt;/li&gt;
&lt;li&gt;SIGCHLD : 자식 process가 종료될 때 부모에게 전달하는 신호&lt;/li&gt;
&lt;li&gt;SIGCONT : SIGSTOP 에 의해 정지된 경우, 다시 시작하라는 신호&lt;/li&gt;
&lt;li&gt;SIGSTOP : process 정지&lt;/li&gt;
&lt;li&gt;SIGTSTP : process 일시정지, Ctrl+Z 명령으로 전송 가능&lt;/li&gt;
&lt;li&gt;SIGTTIN	: background 에 있을 때 read 요청을 받은 경우 발생&lt;/li&gt;
&lt;li&gt;SIGTTOU : background 에 있을 때 write 요청을 받은 경우 발생&lt;/li&gt;
&lt;li&gt;SIGURG : 긴급 통신을 받은 경우 (Out Of Band)&lt;/li&gt;
&lt;li&gt;SIGXCPU : 설정된 CPU 사용량을 초과하여 프로세스가 동작 한 경우&lt;/li&gt;
&lt;li&gt;SIGXFSZ : 파일 크기가 허용된 크기를 초과한 경우&lt;/li&gt;
&lt;li&gt;SIGVTALRM : 프로세스 실행시간 관리를 위한 시그널1&lt;/li&gt;
&lt;li&gt;SIGPROF : 프로세스 실행시간 관리를 위한 시그널2&lt;/li&gt;
&lt;li&gt;SIGWINCH : Window change&lt;/li&gt;
&lt;li&gt;SIGIO, SIGPOLL : Input/output is now possible&lt;/li&gt;
&lt;li&gt;SIGPWR, SIGLOST : Power failure&lt;/li&gt;
&lt;li&gt;SIGUNUSED, SIGSYS : Unused signal.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;signal-library-in-c&#34;&gt;Signal Library in C&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;signal.h&lt;/code&gt; 에 정의된 signal 함수로 signal을 무시(ignore)하거나, 시그널 발생시 특정 함수를 동작(catch)시키도록 설정할 수 있다.&lt;/li&gt;
&lt;li&gt;처리되지 않은 (ignore 또는 catch 처리) signal을 받으면 기본적으로 해당 프로세스는 종료한다.&lt;/li&gt;
&lt;li&gt;SIGKILL(강제종료 용도)과 SIGSTOP(디버깅시 일시정지 용도)시그널을 제외한 모든 시그널을 무시할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;signal(SIGNAL, PID)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;pid &amp;gt; 0 : PID에 SIGNAL 전달&lt;/li&gt;
&lt;li&gt;pid &amp;lt; 0 : PID의 절댓값에 해당하는 groupId를 가진 프로세스들에 SIGNAL 전달&lt;/li&gt;
&lt;li&gt;pid == 0 : 자신과 같은 groupId를 가진 프로세스들에 SIGNAL 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;alarm(TIME)&lt;/code&gt; : TIME초 이후 SIGALRM 시그널 발생
&lt;ul&gt;
&lt;li&gt;alarm timer가 만기되기 전 새로운 alarm을 호출하면 값을 덮어쓴다. 대신 alarm 함수는 남은 시간을 반환 한다.&lt;/li&gt;
&lt;li&gt;alarm(0) 을 호출하면 알림이 취소된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;시그널 처리 flag는 bit연산으로 관리된다.&lt;/li&gt;
&lt;li&gt;sigset_t 타입의 bit 하나하나들은 1~64까지의 signal을 의미하고, 아래와 같이 set을 연산하여 process에서 signal을 설정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;sigemptyset(siget_t* SET)&lt;/code&gt; : SET 모든 비트를 0으로 세팅.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigfillset(int SIGNAL, sigset_t* SET)&lt;/code&gt; : | 연산으로 SET 에서 SIGNAL에 해당하는 비트만 1로 세팅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigdelset(int SIGNAL, sigset_t* SET)&lt;/code&gt; : &amp;amp; 연산으로 SIGNAL에 해당하는 비트만 0으로 세팅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigismember(int SIGNAL, sigset_t* SET)&lt;/code&gt; : SET에서 SIGNAL비트가 1로 세팅되었다면 true 반환&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sigprocmask(int HOW, siget_t* NEW, sigset_t* OLD)&lt;/code&gt; : 특정 SIGNAL을 무시하도록 설정할 수 있다.
&lt;ul&gt;
&lt;li&gt;필요할 경우 OLD에 siget_t* 타입 변수를 집어넣으면 현재 프로세스에 설정된 set을 담아낸다.&lt;/li&gt;
&lt;li&gt;SIG_BLOCK : NEW에 set된 signal들을 추가로 무시한다.&lt;/li&gt;
&lt;li&gt;SIG_UNBLOCK : NEW에 set 된 signal들의 무시처리를 해제한다.&lt;/li&gt;
&lt;li&gt;SIG_SETMASK : 기존 값에 상관없이 NEW에 set 된 signal들만 무시하도록 set을 덮어쓴다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;signal 을 처리하여 signal에 의해 process가 정지되지 않는 구간을 &lt;code&gt;임계영역&lt;/code&gt; 이라 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pipe&#34;&gt;Pipe&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;프로세스간 단방향 통신을 위해 프로세스들의 표준 입출력을 서로 교차하여 연결하는 기법이다.&lt;/li&gt;
&lt;li&gt;프로세스간 데이터 전송시 주로 사용된다.&lt;/li&gt;
&lt;li&gt;flow control이 기본적으로 제공된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pipe-library-in-c&#34;&gt;Pipe Library in C&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;pipe(int[2] fd)&lt;/code&gt; : 파일 디스크립터 두개를 생성하고, 단방향 통신을 생성함&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Thread</title>
      <link>https://aswinblue.github.io/Blog/post/linux/thread/</link>
      <pubDate>Sun, 23 Jul 2023 15:05:46 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/thread/</guid>
      <description>&lt;h1 id=&#34;thread&#34;&gt;Thread&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;thread는 process의 경량화 버전으로 생각할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_create()&lt;/code&gt; 함수로 &lt;code&gt;fork&lt;/code&gt; 명령을 대체하고, &lt;code&gt;pthread_join()&lt;/code&gt; 으로 &lt;code&gt;wait&lt;/code&gt; 명령을 대체하면 process 대신 thread를 동작시킨다.&lt;/li&gt;
&lt;li&gt;thread는 함수를 실행시키는 것이 기본이며, 함수를 실행시킬 때 넣을 인자와, 함수의 리턴값을 받을 인자를 pthread_create의 파라미터로 받는다.&lt;/li&gt;
&lt;li&gt;리눅스 프로세스 표시 목록에 &lt;code&gt;LWP(light-weight-process)&lt;/code&gt; 항목으로 표시되며, proces ID가 같더라도 LWP ID가 다르면 같은 process 안의 thread인 것.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_exit()&lt;/code&gt; 로 thread만 종료시킬 수 있다.&lt;/li&gt;
&lt;li&gt;main process가 종료되면 딸려있는 thread들도 함께 종료된다. 다만, main thread만 pthread_exit으로 종료시키면 process가 종료되지 않고 main thread만 종료되고 다른 thread들은 계속 구동되는 형태가 되므로 주의한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int pthread_join(pthread_t thread, void **retval)&lt;/code&gt; : 자식 thread가 종료될 때 까지 대기하고, 종료처리를 해 주는 함수, &lt;code&gt;pthread_exit()&lt;/code&gt;에서 반환된 값을 retval로 받아올수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_detach(int tid)&lt;/code&gt; : thread id가 tid에 해당하는 thread를 부모 thread에서 분리하는 함수. 이후 종료되고 join 처리를 대기하지 않고 바로 free됨.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int pthread_self()&lt;/code&gt; : 자신의 thread id 를 확인할때 사용하는 함수&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void* func(void* data)
{
    (struct ARG*) data;
    ...
    pthread_detach(pthread_self()); // pthread_join 대신 사용 가능
}

...
// thread 생성
struct ARG *arg;
int tid = pthread_create(&amp;amp;thread, 0, func, arg);
...
pthread_join(tid, 0); // pthread_detach 대신 사용 가능
...
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;process-와-thread-차이&#34;&gt;process 와 thread 차이&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;process는 메모리를 수정하는 순간 메모리가 분리되지만, thread는 메모리를 공유하여 수정하고 나서도 같은 영역을 참조할수 있다. (전체 가상메모리를 공유한다.)&lt;/li&gt;
&lt;li&gt;process는 wait 값의 인자를 확인 에러를 확인할 수 있는 반면, thread의 에러는 pthread_join의 return 값을 확인한다. (값이 0 초과이면 에러가 됨)
&lt;ul&gt;
&lt;li&gt;일반적인 에러 처리는, &lt;code&gt;errno.h&lt;/code&gt; 헤더파일에 &lt;code&gt;errno&lt;/code&gt; 라는 변수가 전역변수로 선언되어 있고, 프로세스가 에러에 의해 종료될 경우 이 변수에 값을 채워넣는다.&lt;/li&gt;
&lt;li&gt;thread는 전역변수를 공유하기 때문에 errno를 사용하지 않는 것&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;전역변수의 상호 참조에 의해 발생하는 race condition 문제를 해결하기 위해 사용할 수 있는 방법
&lt;ul&gt;
&lt;li&gt;race condition : 둘 이상의 thread가 전역변수를 참조할 때 메모리 접근하려 서로 경쟁하는 상황&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread.h&lt;/code&gt; 헤더를 사용하며, pthread 라이브러리를 사용하기 떄문에 빌드시 옵션에 &lt;code&gt;-lpthread&lt;/code&gt;를 추가해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
...
pthread_mutex_lock(&amp;amp;mutex);
// 전역변수 참조 영역
pthread_mutex_unlock(&amp;amp;mutex);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;mutex를 사용해 임계 영역(critical section)에 대해 mutual exclusion 속성을 보장하여 동시 접속에 의한 오동작을 막을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mutex-내부-구조&#34;&gt;Mutex 내부 구조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C언어로는 compare와 set을 atomic하게 수행할 수 없어 mutual exclusion을 구현할 수 없다.&lt;/li&gt;
&lt;li&gt;cas(compare and set) 라는 코드를 어셈블리어에서 지원하는데, compare와 set을 atomic하게 처리할 수 있다.&lt;/li&gt;
&lt;li&gt;아래 함수는 어셈블리어를 사용하여 C에서 cas를 구현한 내용이다. cpu 칩마다 지원하는 형태가 다를 수 있음에 주의한다. (아래는 인텔이 제공하는 형태)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef int int32_t;
int mutex = 0; // 초기값 0
/**
 * @brief   old_value와 *ptr을 비교하여 같다면 *ptr에 new_value를 대입한다.
 *          mutex lock의 역할을 한다. 
 * @return  int old_value와 *ptr의 비교 결과가 같다면 false를, 다르다면 true를 반환
 */
int __bionic_cmpxchg(int32_t old_value, int32_t new_value, volatile int32_t* ptr)
{
    int 32_t prev;
    __asm__ __volatile__ (&amp;#34;lock; cmpxchgl %1, %2&amp;#34;
            : &amp;#34;=a&amp;#34; (prev)
            : &amp;#34;q&amp;#34; (new_value), &amp;#34;m&amp;#34; (*ptr), &amp;#34;0&amp;#34; (old_value)
            : &amp;#34;memory&amp;#34;);
    return prev != old_value;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;spin-lock&#34;&gt;Spin Lock&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;while문을 반복하며 mutex를 계속 체크하는 기법&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void spin_lock(int* mutex)
{
    while (__bionic_cmpxchg(0, 1, mutex)); // mutex가 0이 될 때 까지 무한 대기 
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;CPU 활용도가 떨어지므로 임계영역이 짧은 경우만 사용 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;sleep-lock&#34;&gt;Sleep Lock&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;mutex를 기다리는 동안 thread를 sleep 시키면 thread에 할당된 리소스를 해제하여 다른 곳에 할당해 줄 수 있게 된다.&lt;/li&gt;
&lt;li&gt;gcc에서는 slelep lock을 지원하는 라이브러리가 없지만, 시스템 커맨드 라이브러리에는 futex(fast user mutex)라는 함수로 sleep lock을 지원한다. C언어로 사용하려면 시스템 콜로 futex를 호출하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;unisted.h&amp;gt;
int mutex = 1;
void *foo(void *data)
{
    sytstemcall 202, &amp;amp;mutex, 0, 1, 0); // __futex_wait();
    ... /* critical section */
    systemcall(202, &amp;amp;mutex, 1, 1); // __futex_wake();
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;__futex_wait 은 mutex_lock, __futex_wake는 mutex_unlock에 대응된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;self-lock&#34;&gt;Self Lock&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;recursive 함수에서 mutex를 사용한다면 하나의 함수에서 동일한 mutex를 두번 호출하게 되는 &amp;ldquo;selfl lock&amp;quot;이 발생할 수 있다.&lt;/li&gt;
&lt;li&gt;self lock이 발생하면 마찬가지로 deadlock이 발생한다.&lt;/li&gt;
&lt;li&gt;재귀 호출을 위한 &lt;code&gt;recursive mutex lock&lt;/code&gt; 이 존재한다. mutex 생성시 attribute로 재귀함수를 위한 설정이 존재하며, mutex_lock을 한 thread에서 중복 호출 가능하며, mutex_lock을 호출한 수만큼 mutex_unlock을 호출해 주면 mutex가 해제된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_mutexattr_t attr;
pthread_mutex_t mutex;
...
pthread_mutexattr_init(&amp;amp;attr);
pthread_mutexattr_settype(&amp;amp;attr, PTHREAD_MUTEX_RECURSIVE);
pthread_mutuex_init(&amp;amp;mutex, &amp;amp;attr);
...
pthread_mutex_lock(&amp;amp;mutex); // 1
pthread_mutex_lock(&amp;amp;mutex); // 2
pthread_mutex_lock(&amp;amp;mutex); // 3
...
pthread_mutex_unlock(&amp;amp;mutex); // 1
pthread_mutex_unlock(&amp;amp;mutex); // 2
pthread_mutex_unlock(&amp;amp;mutex); // 3
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;condition-조건변수&#34;&gt;Condition (조건변수)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;thread에서 전역 변수에 참조할 때, 순서를 제어하기 위해 사용하는 방법&lt;/li&gt;
&lt;li&gt;아래 코드는 thread1에서 전역변수를 처리해야 thread2에서 전역변수에 접근이 가능하게 하는 코드이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
...
thread1()
{
    pthread_mutex_lock(&amp;amp;mutex);
    // 전역변수 처리
    pthread_cond_signal(&amp;amp;cond);
    pthread_mutex_unlock(&amp;amp;mutex);
}
...
thread2()
{
    pthread_mutex_lock(&amp;amp;mutex);
    pthread_cond_wait(&amp;amp;cond);
    // 전역변수 처리
    pthread_mutex_unlock(&amp;amp;mutex);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;condition-내부-구조&#34;&gt;Condition 내부 구조&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func1()
{
    pthread_mutex_lock(); // &amp;lt;- (1)
    do_something();
    pthread_cond_signal();
    pthread_mutex_unlock();
}
func2()
{
    pthread_mutex_lock();
    pthread_cond_wait(); // &amp;lt;- (2)
    do_something();
    pthread_mutex_unlock();
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;func1이 (1)에서 mutex unlock을 대기하고, func2가 (2)에서 condition signal을 대기하면 deadlock이 걸릴 것 같지만, condition wait와 mutex lock은 서로 교착상태를 만들지 않는다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pthread_cond_wait()&lt;/code&gt; 아래와 같이 mutex_unlock, futex_wait, mutex_lock으로 구성되어 있으므로 mutex&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;pthread_cond_wait()
{
    ...
    pthread_mutex_unlock();
    while (condition == 0) // condition 조건이 충족될 때 까지 무한 대기
    {
        futex_wait(); // sleep lock
    }
    condition = 0; // condition 초기화
    pthread_mutex_lock();
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;즉, condition wait는 condition signal이 발생한 시점이 아니라, mutex 가 unlock되는 시점에 탈출된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;deadlock&#34;&gt;Deadlock&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;두 개 이상의 Mutex가 서로 해제되기를 기다리며 대기하여 더 이상 process가 진행되지 못하게 되는 상황을 deadlock이라 한다.&lt;/li&gt;
&lt;li&gt;lock을 순서대로 잡고, cycle이 생기지 않게 관리하면 deadlock을 피할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;재진입-가능-함수-reentrant&#34;&gt;재진입 가능 함수 (Reentrant)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;thread에서 사용할 수 있는 함수를 &amp;lsquo;재진입 가능 함수&amp;rsquo; 라 한다. 즉, Thread-safe 한 함수를 의미한다.&lt;/li&gt;
&lt;li&gt;내부적으롱 전역변수, 혹은 static 변수를 사용하는 함수는 &amp;lsquo;재진입 불가능&amp;rsquo; 하다.&lt;/li&gt;
&lt;li&gt;strtok는 대표적인 재진입 불가능한 함수이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func1()
{
    strtok()
}
func2()
{
    strtok()
}
main()
{
    pthread_create(func1);
    pthread_create(func2);
}
// -&amp;gt; strtok는 재진입 불가능한 함수이기 때문에 결과가 의도한 결과가 나오지 않을 수 있다.
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;C 라이브러리에서는 strtok_r 이라는 재진입 가능한 함수를 제공한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tls--tsd&#34;&gt;TLS / TSD&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;TLS는 thread 의 전역 변수를 저장하기 위한 공간으로, 로더(Loader)에 의해서 할당된다.&lt;/li&gt;
&lt;li&gt;리눅스에서는 TSD라 부른다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int pthread_setspecific(pthread_key_t key, const void *value)&lt;/code&gt; : &amp;lsquo;key&amp;rsquo; 에 해당하는 영역에 &amp;lsquo;value&amp;rsquo;를 연결한다. value로는 동적할당한 메모리가 온다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void* pthread_getspecific(pthread_key_t key)&lt;/code&gt; : 기존에 set으로 할당한 key에 해당하는 메모리를 가져온다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void pthread_key_create(pthread_key_t key, void* (*descturctor)(void*))&lt;/code&gt; 할당한 메모리를 해제하는 역할을 수행할 함수 &lt;code&gt;void destructor(void* ptr){free(p);}&lt;/code&gt;를 정의하고, destructor의 포인터를 key와 매핑시킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void main(void)
{
    pthread_key_t key;
    pthread_key_create(key, void (*destructor)(void*));
}

void func1(void)
{
    int *tsd = pthread_get_specific(key) // key에 해당하는 영역 가져옴
    if (!tsd) // null 받았을 시
    {
        tsd = calloc(1, sizeof int); // int 영역이 필요해서 동적할당. 다른 자료형도 가능
        pthread_set_specific(key, tsd); // TSD 영역에 저장
    }
}

void destructor(void* ptr)
{
    free(p);
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;TLS는 내부적으로 &lt;code&gt;void* tls[]&lt;/code&gt; 배열을 bitmap 형태로 지니고, pthread_set_specific을 할 경우 &lt;code&gt;tls[idx]&lt;/code&gt;에 메모리 주소를 대입한다.&lt;/li&gt;
&lt;li&gt;pthread_set_specific을 호출할 때 마다 idx는 자동으로 갱신된다.&lt;/li&gt;
&lt;li&gt;thread가 종료될 때 모든 key에 대해 소멸자로 정의된 destructor가 호출된다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Process</title>
      <link>https://aswinblue.github.io/Blog/post/linux/process/</link>
      <pubDate>Tue, 18 Jul 2023 20:15:29 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/process/</guid>
      <description>&lt;h1 id=&#34;process&#34;&gt;Process&lt;/h1&gt;
&lt;h2 id=&#34;program-vs-process&#34;&gt;Program vs Process&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Process : 실행중인 프로그램&lt;/li&gt;
&lt;li&gt;Program : 실행 가능한 파일&lt;/li&gt;
&lt;li&gt;Process는 메모리에 올라가 있는 상태의 프로그램을 의미한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;c언어-program-to-process&#34;&gt;C언어 Program to Process&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C언어로 구성된 프로그램은 전처리 - 컴파일 - 링킹 - 로딩의 과정을 거친다.
&lt;ul&gt;
&lt;li&gt;전처리 : &lt;code&gt;#&lt;/code&gt; 으로 시작하는 라인들을 알맞은 형태로 치환한다.&lt;/li&gt;
&lt;li&gt;컴파일 : C언어(high-level language)를 어셈블리어(기계어) 로 변환한다.&lt;/li&gt;
&lt;li&gt;링킹 : 외부의 ELF(Executable and Linkable Format) 파일들을 호출할 수 있도록 연결한다.&lt;/li&gt;
&lt;li&gt;로딩 : 최종 생성된 파일을 실행시켜 메모리에 올려 프로세스로 만든다.
&lt;ul&gt;
&lt;li&gt;리눅스에서는 &lt;code&gt;execv()&lt;/code&gt; 함수에 의해 프로세스화 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프로세스&#34;&gt;프로세스&lt;/h2&gt;
&lt;h3 id=&#34;fork&#34;&gt;fork&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fork()&lt;/code&gt; 함수는 프로세스를 복사하는 함수이다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unistd.h&lt;/code&gt; 헤더에 선언되어 있다.&lt;/li&gt;
&lt;li&gt;복사당한 프로세스를 부모 프로세스, 복사해서 생성된 프로세스를 자식 프로세스라 한다.&lt;/li&gt;
&lt;li&gt;복사된 자식 프로세스도 &lt;code&gt;fork&lt;/code&gt; 실행 이후부터 코드가 진행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fork&lt;/code&gt; 함수의 반환값은 &lt;code&gt;pid_t&lt;/code&gt; 타입이다.
&lt;ul&gt;
&lt;li&gt;반환값이 -1이라면 실패를 의미한다.&lt;/li&gt;
&lt;li&gt;결과가 0이라면 현재 프로세스는 자식 프로세스임을 의미한다.&lt;/li&gt;
&lt;li&gt;0이 아니닌 값이라면 현재 프로세스는 부모 프로세스이다.
&lt;ul&gt;
&lt;li&gt;반환값은 자식프로세스의 process id를 의미하며, 리눅스 명령어 &lt;code&gt;ps -ef&lt;/code&gt; 로 pid를 확인 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Race Condition : 일단 fork가 되어 프로세스가 부모 자식으로 나뉘면, 프로세스의 실행은 병렬적으로 이루어지며, 같은 코드라도 어느 것이 먼저 동작할지 알 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;wait&#34;&gt;wait&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;fork() 로 자식 프로세스를 생성한 후 자식 프로세스가 exit()를 호출하여 종료될 때, 부모 process는 자식 process의 종료 결과를 &lt;code&gt;wait()&lt;/code&gt; 으로 받을수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait(statloc *status)&lt;/code&gt; : 자식 process에서 호출된 exit() 함수 안에 들어간 인자값을 status(인자는 4byte int지만, 사용하는 부분은 2byte) 에 담아낸다.&lt;/li&gt;
&lt;li&gt;status 값은 상위 1byte와 하위 1byte를 구분해서 사용한다.
&lt;ul&gt;
&lt;li&gt;정상적으로 종료가 된경우는 exit() 함수에 의한 종료를 의미하며, status의 상위 1byte에 exit의 인자값을 담아낸다.&lt;/li&gt;
&lt;li&gt;비정상 종료는 signal에 의한 종료를 의미하며, signal 번호 값을 status의 하위 1byte에 담아낸다.&lt;/li&gt;
&lt;li&gt;0~7번 bit : 자식 process 정상종료시 종료 status&lt;/li&gt;
&lt;li&gt;8번 bit : core dump 여부&lt;/li&gt;
&lt;li&gt;9~15번 bit : 시그널 번호&lt;/li&gt;
&lt;li&gt;status값을 인자로 받아 종료 사유를 회신하는 매크로 함수를 사용하면 쉽게 판단할 수 있다.
&lt;ul&gt;
&lt;li&gt;WIFEXITED, WEXITEDSTATUS, WIFSIGNALED &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;메모리&#34;&gt;메모리&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;부모 프로세스를 복사해 자식 프로세스를 생성해도 code 영역은 공유된다.
&lt;ul&gt;
&lt;li&gt;code 영역은 read only memory 이기 때문에&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;자식 프로세스는 부모 프로세스의 ram 영역 값도그대로 복사 해 온다.
&lt;ul&gt;
&lt;li&gt;하지만, 자식 프로세스가 새성될 당시 메모리가 바로 복사되는 것이 아니라, 메모리에 값을 작성하는 시점에 복사가 된다.&lt;/li&gt;
&lt;li&gt;즉, 부모나 자식 프로세스에서 값을 덮어쓰거나 새로 생성하지 않은 변수에 대해서는 같은 메모리를 바라보고 있다고 볼 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;메모리는 reference count를 들고 있어 몇개의 프로세스에서 해당 영역을 참조하는지 체크한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;프로세스-생명-주기-life-cycle&#34;&gt;프로세스 생명 주기 (Life Cycle)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;모든 프로세스는 부모 프로세스가 있고, 가장 최초로 실행된 프로세스를 init 프로세스라 하며, init 프로세스의 pid는 1이다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>System_programming</title>
      <link>https://aswinblue.github.io/Blog/post/linux/system_programming/</link>
      <pubDate>Sat, 15 Jul 2023 08:35:21 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/system_programming/</guid>
      <description>&lt;h1 id=&#34;system-programming&#34;&gt;System Programming&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;프로그램이 동작하는 구조는 크게 application, kernel, HW 로 분리할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;_____________
|  Library  |
¯¯¯¯¯¯¯¯¯¯¯¯¯   Application level
------------------------------
_____________
|System call|
¯¯¯¯¯¯¯¯¯¯¯¯¯   Kernel level
------------------------------
_____________
|  Hardware  |
¯¯¯¯¯¯¯¯¯¯¯¯¯   H/W level
------------------------------
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;application level에서는 library를 사용하며, 이 코드들은 library buffer를 사용한다. (open(), read(), write(), close() &amp;hellip;)
&lt;ul&gt;
&lt;li&gt;시스템에서 제공하는 최적의 buffer 단위로 disk에서 값을 읽어오고, library buffer에 담아두면 작은단위로 읽어올 때 효율적이다.&lt;/li&gt;
&lt;li&gt;예를들어, 한 줄씩 파일을 읽어야 한다면, 1byte씩 파일에서 &amp;lsquo;\n&amp;rsquo;을 감지할 때 까지 읽을 수 있지만, BUF_SIZ만큼 파일에서 읽어서 library buffer에 담아두고 library buffer를 1byte씩 읽으며 &amp;lsquo;\n&amp;rsquo;를 찾는 것이 실행 속도는 더 빠르다. (IO접근은 적을수록 효율적)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Kernel level에서는 System call을 사용하며 system buffer를 사용한다.&lt;/li&gt;
&lt;li&gt;application level 함수를 사용하면, 보통 library buffer를 1차적으로 사용하고, 내부적으로 system call을 수행해 system buffer를 2차적으로 사용하게 된다.
&lt;ul&gt;
&lt;li&gt;printf는 c library 함수이며, &amp;lsquo;\n&amp;rsquo;을 만나야 화면상에 출력을 한다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;\n&amp;rsquo;이 입력되기 전 까지 문자열들은 library buffer에 기록된다.&lt;/li&gt;
&lt;li&gt;fprintf는 &amp;lsquo;\n&amp;rsquo;과 상관없이 문자열을 출력한다. 즉 library buffer를 사용하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;파일-입출력&#34;&gt;파일 입출력&lt;/h2&gt;
&lt;h3 id=&#34;fgetc&#34;&gt;fgetc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;C에서 파일에 접근하기 위해서는 &lt;code&gt;fopen&lt;/code&gt; 함수를 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fopen&lt;/code&gt;은 파일 포인터를 반환하며, 코드 내에서 파일 포인터로 해당 파일에 접근이가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fgetc(FPTR)&lt;/code&gt; 함수는 fopen으로 연 파일 포인터를 참조해서 char 하나를 읽고 반환한다.
&lt;ul&gt;
&lt;li&gt;fgetc 함수의 반환 값은 int 형태이다.&lt;/li&gt;
&lt;li&gt;text file을 읽을 땐, 0xFF값이 내용에 올 수 없지만, binary file을 읽을 땐 중간에 0xFF 값이 올 수 있다.&lt;/li&gt;
&lt;li&gt;char 형태로 0xFF를 읽으면 -1값에 해당하기 때문에, EOF와 구분이 불가능하여 char 대신 int를 반환하도록 되어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-구조체&#34;&gt;파일 구조체&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fopen&lt;/code&gt;은 파일 구조체의 주소(포인터)를 반환한다.&lt;/li&gt;
&lt;li&gt;파일 구조체는 아래와 같은 내용을 담고 있다.
&lt;ul&gt;
&lt;li&gt;_flags:&lt;/li&gt;
&lt;li&gt;_IO_read_ptr : 다음 명령시 파일을 읽거나 쓸 위치&lt;/li&gt;
&lt;li&gt;_IO_read_end: kernel에서 데이터를 받아서 저장할 버퍼의 끝 위치.&lt;/li&gt;
&lt;li&gt;_IO_read_base: kernel에서 데이터를 받아서 저장할 버퍼의 시작 위치. 파일에 대한 읽기 명령(fgetc/fgets등) 이 발생했을 때, kernel은 4096byte(BUF_SIZE) 만큼 데이터를 미리 읽어서 이곳에 채워둔다.&lt;/li&gt;
&lt;li&gt;_fileno: 파일의 offset, kernel에서 해당 파일에 정해준 index(kernel 함수에서 사용할 수 있다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fopen 시에 파일 구조체가 생성 및 초기화 되지만, &lt;em&gt;IO_read&lt;/em&gt;* 인자들은 파일 접근이 이루어짐과 동시에 값이 적용된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;eof&#34;&gt;EOF&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;파일을 끝까지 읽었다고 판단하는 것은, EOF 문자(-1) 으로 판단한다.
&lt;ul&gt;
&lt;li&gt;하지만 실제파일을 읽어보면 마지막에 -1값이 실제로 들어있지는 않다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EOF 값은 file I/O 함수의 리턴값일 뿐 실제 파일에 기입된 값이 아니다.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;file I/O 함수는 i-node에 기록된 파일의 크기를 기반으로 파일 끝을 판단한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;ASKII 코드 중 주요 문자의 값 참조&lt;/li&gt;
&lt;li&gt;a: 97&lt;/li&gt;
&lt;li&gt;A: 68&lt;/li&gt;
&lt;li&gt;0: 48&lt;/li&gt;
&lt;li&gt;\n: 10&lt;/li&gt;
&lt;li&gt;\r: 13&lt;/li&gt;
&lt;li&gt;(공백): 32&lt;/li&gt;
&lt;li&gt;\t: 9&lt;/li&gt;
&lt;li&gt;\0: 0&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fguts(BUFF, SIZE, FPTR)&lt;/code&gt; 함수는 fopen으로 연 파일 포인터를 참조해서 line 하나를 읽어온다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fputs(BUFF, FPTR)&lt;/code&gt; 함수는 fopen으로 연 파일 포인터를 참조해서 line 하나를 출력한다.
&lt;ul&gt;
&lt;li&gt;리눅스에서 표준 입력/출력/에러는 기본적으로 파일 포인터를 열어둔다. 각각 아래 문자열 혹은 번호로 참조 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;stdin&lt;/code&gt; : 표준 입력
&lt;code&gt;stdout&lt;/code&gt; : 표준 출력 &lt;br&gt;
&lt;code&gt;stderr&lt;/code&gt;: 표준 에러   &lt;br&gt;
-&amp;gt; 파일 포인터 대신 &lt;code&gt;stdout&lt;/code&gt; 을 입력하면 표준 출력으로 문자열이 출력된다. (ex: &lt;code&gt;fputc(BUF, stdout)&lt;/code&gt;)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Make</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/make/</link>
      <pubDate>Thu, 13 Jul 2023 18:35:05 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/make/</guid>
      <description>&lt;h1 id=&#34;make&#34;&gt;make&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;분할 컴파일을 통해 컴파일 작업 효율을 올리고, 이 과정을 자동화 하기 위해 일괄처리를 도와주는 도구이다.&lt;/li&gt;
&lt;li&gt;batch 파일로 컴파일 하면, 변경점을 감지하지 못해 batch파일을 수정하지 않고서는 분할 컴파일을 수행할 수 없다.&lt;/li&gt;
&lt;li&gt;make파일은 파일들 간의 의존성을 정의하여, 특정 파일이 수정되면 어떤 파일을 컴파일 해야하는지 알아서 판단해 준다.&lt;/li&gt;
&lt;li&gt;리눅스 시스템의 수정 시간을 확인하여, 빌드 결과물이 생성된 시간과 소스가 수정된 시간을 비교해서 컴파일 혹은 링킹이 다시 필요한지 판단하는 원리이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본구조&#34;&gt;기본구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;파일 이름은 &lt;code&gt;Makefile&lt;/code&gt; 으로 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;TARGET:DEPENDENCIES
   COMMANDS
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;COMMANDS 앞에는 공백이 아니라 &lt;strong&gt;tab문자&lt;/strong&gt;이다.&lt;/li&gt;
&lt;li&gt;COMMAND를 실행하여 TARGET파일 생성한다는 의미이다.&lt;/li&gt;
&lt;li&gt;TARGET을 생성할 때 DEPENDENCIES 파일들이 필요하다. DEPENDENCIES파일이 수정되면 TARGET파일도 다시 컴파일 해야한다는 의미이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;# 주석&lt;/code&gt; : 주석은 #으로 달 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;    @COMMANDS&lt;/code&gt;: make파일은 실행시 &amp;lsquo;실행한 명령 원문&amp;rsquo; 과 &amp;lsquo;실행 결과&amp;rsquo; 를 모두 쉘이 출력한다. &lt;code&gt;@&lt;/code&gt;를 붙이면 명령 원문은 출력하지 않는다.&lt;/li&gt;
&lt;li&gt;기본 형태를 약간 변형하여 명령어를 생성할 수도 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DEPENDENCIES&lt;/code&gt; 를 없이 &lt;code&gt;TARGET&lt;/code&gt; 과 &lt;code&gt;COMMANDS&lt;/code&gt; 만 남기면, &lt;code&gt;make TARGET&lt;/code&gt; 명령을 입력시 해당 &lt;code&gt;COMMANDS&lt;/code&gt; 만 수행되도록 할 수 있다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;clean:
    rm -f ${OBJ}${TARGET}
    # make clean 명령시 위 동작 수행

install:
    ...
    # 동일한 형태로 다른 명령도 작성 가능
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;make-파일-정의-commands&#34;&gt;make 파일 정의 COMMANDS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;대부분의 명령들은 쉘 명령과 유사하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;echo &amp;lt;VALUE&amp;gt;&lt;/code&gt; : VALUE 값을 출력한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VARIABLE = VALUE&lt;/code&gt; : VARIABLE 이라는 이름의 변수를 선언하고, VALUE 값을 대입함
&lt;ul&gt;
&lt;li&gt;변수 선언시 자기 자신을 참조하는 형태(recursive)는 &lt;code&gt;=&lt;/code&gt; 연산자로 사용 불가능하다. (ex: &lt;code&gt;VARIABLE = ${VARIABLE} + DATA&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;대신 &lt;code&gt;:=&lt;/code&gt; 연산과 &lt;code&gt;+=&lt;/code&gt; 연산을 사용 가능하다.&lt;/li&gt;
&lt;li&gt;ex) &lt;code&gt;VARIABLE := ${VARIABLE} + DATA&lt;/code&gt;, &lt;code&gt;VARIABLE += DATA&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(VARIABLE)&lt;/code&gt; : VARIABLE 변수에 해당하는 값을 호출 (&lt;code&gt;${VARIABLE}&lt;/code&gt; 과 동일)
&lt;ul&gt;
&lt;li&gt;TIP: 컴파일 도구를 변수로 지정해 놓으면 좋다. &lt;code&gt;CC=gcc&lt;/code&gt; -&amp;gt; &lt;code&gt;$(CC) -c file.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TIP: 최종 파일 이름을 변수로 지정해 놓으면 좋다. &lt;code&gt;PROJECT_NAME=myProject&lt;/code&gt; -&amp;gt; &lt;code&gt;gcc -o $(PROJECT_NAME) file1.o file2.o&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TIP: .o파일을 만드는 &lt;code&gt;-c&lt;/code&gt; 옵션을 &lt;code&gt;CFLAGS&lt;/code&gt; 로 변수로 사용하면 좋다. &lt;br&gt;
-&amp;gt; &lt;code&gt;CFLAGS = -I./include -c&lt;/code&gt; 와 같이 include path 및 기타 설정이 가능하다.&lt;/li&gt;
&lt;li&gt;TIP: 링킹을 위한 &lt;code&gt;LFLAGS&lt;/code&gt; 또한 같은 맥락에서 변수로 활용하면 좋다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;${VARIABLE:ASIS=TOBE}&lt;/code&gt; : VALUE 변수에서 ASIS라는 구문을 TOBE라는 구문으로 치환한다. (ex: &lt;code&gt;PROJECT_NAME:my=your&lt;/code&gt;-&amp;gt; ${PROJECT_NAME} == yourProject)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;내장-매크로&#34;&gt;내장 매크로&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;make 파일의 target-dependency-command 라인들에 일일이 파일 이름을 써 넣고 수정하기 번거롭기에, 아래와 같이 매크로를 활용해 좀더 편리하게 작업을 수행할 수 있도록 한다.
&lt;ul&gt;
&lt;li&gt;내장 매크로를 활용하면 command에 파일 이름을 직접쓰지 않아도 되게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt; : DEPENDENCIES 중 가장 선두&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt; : DEPENDENCIES 전체를 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; : TARGET을 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt; : 확장자가 없는 TARGET을 의미&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt; : DEPENDENCIES 중 TARGET보다 수정 시간이 늦은 파일들&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.c.o:&lt;/code&gt; : Makefile 안에서 언급된 모든 xxx.o 파일을 만들기 위해 동일한 이름을 가진 xxx.c 파일들을 컴파일하여 xxx.o 파일을 생성한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%.o : %.c&lt;/code&gt; : &lt;code&gt;.c.o&lt;/code&gt; 와 동일한 효과를 낸다. 좀더 신규 스타일이다.&lt;/li&gt;
&lt;li&gt;최종 예시를 보면 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CC = gcc
CFLAGS = -c
TARGET = a.out
OBJ = main.o func1.o

${TARGET} : ${OBJ}
    ${CC} ${OBJ} -o ${TARGET}  # gcc main.o func1.o -o a.out 와 동일

.c.o :  # 위에서 언급된 모든 .o 파일(OBJ)을 만들기 위해 .c 파일로 .o 파일 생성
    ${CC} ${CFLAGS} $&amp;lt;  # $&amp;lt;는 가장 선두의 dependency를 의미함. 즉 gcc -c xxx.c 와 동일
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;쉘-명령어&#34;&gt;쉘 명령어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;make&lt;/code&gt; : 현재 경로에 있는 &lt;code&gt;Makefile&lt;/code&gt; 을 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make install&lt;/code&gt; : 해당 경로의 소스를 컴파일하여 /usr/local/lib, /usr/local/bin 폴더로 .so파일과 .bin파일 복사&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make -f &amp;lt;FILE_NAME&amp;gt;&lt;/code&gt; : Makefile 대신 FILE_NAME 을 make파일로 가정하고 실행한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;make -p&lt;/code&gt; : 설정된 매크로 옵션들을 확인 가능&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Shell Programming</title>
      <link>https://aswinblue.github.io/Blog/post/linux/shell_programming/</link>
      <pubDate>Thu, 13 Jul 2023 18:29:44 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/shell_programming/</guid>
      <description>&lt;h1 id=&#34;shell-programming&#34;&gt;Shell Programming&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 쉘 프로그래밍에 대해 기술한다.&lt;/li&gt;
&lt;li&gt;쉘 프로그래밍은 bash, sh 등의 명령어를 활용한 로직을 칭하며, 리눅스 환경에서 text 파일 안에 명령어를 작성해 놓고, 실행하는 방식으로 사용한다.&lt;/li&gt;
&lt;li&gt;명령어가 든 파일의 확장자는 보통 .sh 로 세팅한다. (윈도우 OS의 .batch 와 유사)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sh-파일-작성&#34;&gt;.sh 파일 작성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;새로 생성된 text 파일은 확장자가 .sh 라도 실행 권한이 없기 떄문에 &lt;code&gt;chmod&lt;/code&gt; 명령어로 권한을 수정해야 한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ex) &lt;code&gt;chmod a+x &amp;lt;파일이름&amp;gt;&lt;/code&gt; 명령으로 모든 사용자에 대해 실행 권한을 부여할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;.sh 파일 안에는 shell 명령어들을 사용할 수 있다. 그 외 추가적으로 작성할 수 있는 구문들은 다음과 같다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Aws</title>
      <link>https://aswinblue.github.io/Blog/post/cloud/aws/</link>
      <pubDate>Wed, 12 Jul 2023 21:12:55 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/cloud/aws/</guid>
      <description>&lt;h1 id=&#34;aws&#34;&gt;Aws&lt;/h1&gt;
&lt;h2 id=&#34;aws-로그인&#34;&gt;Aws 로그인&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;root 로그인과 IAM 로그인이 있다.
필요한 권한만 할당된 IAM 계정을 사용하는 것이 안전하며, root는 외부로 공유되지 않게 하고 보안을 철저히 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;window-서버-생성&#34;&gt;Window 서버 생성&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;window 서버 vs Linux 서버&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;중소기업쪽에서는 보안 및 관리할 것들이 줄어드는 Window 서버를 많이 선호하는 편이다.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;t 시리즈는 범용서버이다. t2.large는 꽤 큰 서버이다.&lt;/li&gt;
&lt;li&gt;프리티어를 사용하면 일부 서비스를 무료로 사용할 수는 있지만, 성능이 좋지는 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;좌측상단 &amp;lsquo;서비스&amp;rsquo;를 선택, EC2를 찾아서 들어간다. (또는 검색창에서 EC2를 검색)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gcc</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/gcc/</link>
      <pubDate>Mon, 10 Jul 2023 22:13:06 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/gcc/</guid>
      <description>&lt;h1 id=&#34;gcc&#34;&gt;GCC&lt;/h1&gt;
&lt;p&gt;C / C++ 언어를 컴파일 해 주는 도구이다. 리눅스에서는 apt 명령으로 설치 가능하며, 윈도우에서는 Mingw을 이용하여 설치 가능하다.
gcc는 컴파일러를 포함한 패키지일 뿐, 내부적인 컴파일러는 따로 있다. (cc1 등)&lt;/p&gt;
&lt;h2 id=&#34;gcc-컴파일-동작-순서&#34;&gt;GCC 컴파일 동작 순서&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;gcc main.c&lt;/code&gt; 파일을 동작시키면 main.c파일을 컴파일하여 실행파일인 a.out 파일을 생성하게 된다.&lt;br&gt;
하지만 내부적으로는 아래와 같은 과정을 거치게 된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;전처리 : c언어로 구현된 .c 파일을 전처리가 완료된 .i 파일로 변환한다.&lt;br&gt;
&lt;code&gt;gcc -E main.c -o a.i&lt;/code&gt; : main.c 파일을 a.i 파일로 전처리&lt;/li&gt;
&lt;li&gt;컴파일 : 전처리된 .i 파일을 어셈블리어로 변환&lt;br&gt;
&lt;code&gt;gcc -S a.i -o a.s&lt;/code&gt; : a.i 파일을 a.s 어셈블리어로 어셈블&lt;/li&gt;
&lt;li&gt;어셈블: 각 벤더들이 만든 어셈블리어를 목적파일로 변환(어셈블리 언어를 기계어로 변환)
&lt;code&gt;gcc -c a.s -o a.o&lt;/code&gt; : 어셈블리 파일을 목적 파일 EOL(Executable Linux File)로 변환. 하지만 바로 실행할 수는 없다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file a.o&lt;/code&gt; 명령어를 입력 해 보면 &amp;ldquo;LSB relocatable&amp;rdquo; 이라고 표시된다. 즉, 재배치 가능하다는 의미로, 실행 할 수 있는 상태는 아니라는 뜻이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;링킹: 목적파일에서 참조하는 다른 목적파일들을 linking하여 최종 실행파일을 생성한다.&lt;br&gt;
&lt;code&gt;gcc a.o -o out&lt;/code&gt; : a.o 목적파일로 실행 가능한 파일을 생성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file out&lt;/code&gt; 명령어를 입력 해 보면 &amp;ldquo;LBS executable&amp;rdquo; 라고 출력된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcc -v --save-temps -o out&lt;/code&gt; : 위 전체 과정을 실행하며 중간 생성물을 남기고, 실행 결과도 출력&lt;/li&gt;
&lt;li&gt;리눅스에서 &lt;code&gt;ldd&lt;/code&gt; 명령으로 링킹시 라이브러리 의존성을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;ASLR을 지원하는 커널의 경우, &lt;code&gt;-no-pie&lt;/code&gt; 옵션을 넣으면 PIE( position independent executable) 영역을 생성하지 않아 ASLR 기능을 끌 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;라이브러리&#34;&gt;라이브러리&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;헤더파일에서 include를 하여 사용할 수 있는 목적파일을 라이브러리라고 칭한다.
&lt;ul&gt;
&lt;li&gt;라이브러리는 링킹을 통해 프로그램에 포함되며, 링킹 방식에 따라 &amp;lsquo;정적 라이브러리&amp;rsquo;와 &amp;lsquo;동적 라이브러리&amp;rsquo;로 분류된다.&lt;/li&gt;
&lt;li&gt;정적 라이브러리는 정적 링킹에 의해 생성되며, 라이브러리가 코드의 object 파일이 자체에 포함되는 형태이다.
&lt;ul&gt;
&lt;li&gt;정적 라이브러리는 파일의 크기가 커지고, 라이브러리 버전 변경시 파일이 매번 변경되어야 하는 단점이 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcc -static&lt;/code&gt; 와 같이 static 옵션을 넣어 설정 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;동적 라이브러리는 동적 링킹에 의해 생성되며, 라이브러리 코드의 object 파일이 별도로 존재하고, 링커가 라이브러리 코드의 주소를  사용자의 코드와 연결시켜주는 형태이다.
&lt;ul&gt;
&lt;li&gt;빌드시 별도 옵션을 넣지 않으면 dynamic linking 으로 동작한다.&lt;/li&gt;
&lt;li&gt;동적 할당을 수행하면 각 프로세스는 외부 라이브러리 코드의 함수를 PLT(Procedure Linkage Table) 와 GOT(Global Offsets Table)를 통해 접근하게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C에서 라이브러리 파일은 &lt;code&gt;lib&lt;/code&gt; 으로 시작하는 규칙을 지니며 &lt;code&gt;.a&lt;/code&gt; 확장자를 가진다&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gcc -c CFILE.c -o OBJ.o&lt;/code&gt; 명령으로 &lt;code&gt;OBJ.o&lt;/code&gt; 목적파일을 생성했다면, &lt;code&gt;ar rcv libmylib.a OBJ.o&lt;/code&gt; 명령으로 &lt;code&gt;libmylib.a&lt;/code&gt;라는 사용자 정의 라이브러리/정적 라이브러리를 생성 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ar t libmylib.a&lt;/code&gt; 로 라이브러리가 가리키는 파일을 검색하면 &lt;code&gt;OBJ.j&lt;/code&gt; 파일을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;라이브러리를 함께 컴파일 할 때 &lt;code&gt;gcc main.c libmylib.a&lt;/code&gt; 와 같이 컴파일 할 수도 있지만, 라이브러리를 제대로 활용하는 방법은 &lt;code&gt;gcc main.c -lmylib&lt;/code&gt; 와 같이 &lt;code&gt;-l&lt;/code&gt; 옵션을 이용한다.
&lt;blockquote&gt;
&lt;p&gt;정적 라이브러리 이름에서 앞쪽의 lib 부분과 뒤쪽의 .a 부분을 제외한 부분이 라이브러리 이름이다.
위 예시에서는 &lt;code&gt;mylib&lt;/code&gt;이 라이브러리 이름이다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux_introduction</title>
      <link>https://aswinblue.github.io/Blog/post/linux/linux_introduction/</link>
      <pubDate>Mon, 10 Jul 2023 21:31:47 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/linux_introduction/</guid>
      <description>&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;
&lt;h2 id=&#34;생성-배경&#34;&gt;생성 배경&lt;/h2&gt;
&lt;h3 id=&#34;unix&#34;&gt;Unix&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;unix는 범용 다중 사용자 방식의 시분할 운영체제이다. 즉, multi-user를 목적으로 개발된 운영체제이다.&lt;/li&gt;
&lt;li&gt;Dennis Ritche, Ken Thompson, Douglas Mcllroy 등이 주축이 되어 개발&lt;/li&gt;
&lt;li&gt;이후 다양한 회사들에 의해 개발이 지속되어, 표준화의 필요성이 생겼고, IEEE에서 제안한 POSIX(Portable Operating System Interface) 라는 표준 인터페이스를 따르게 되었다.&lt;/li&gt;
&lt;li&gt;리눅스는 unix를 기반으로 개발된 os이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;gnu&#34;&gt;GNU&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Richard Stallman이 창시한 FSF(Free Software &lt;strong&gt;Fo&lt;/strong&gt;undation) 의 프로젝트 GNU&lt;/li&gt;
&lt;li&gt;리눅스도 GNU의 GPL(General Public License) 에 의해 배포된다.
&lt;ol&gt;
&lt;li&gt;무료로 사용 가능하며&lt;/li&gt;
&lt;li&gt;GPL 소스를 적용된 코드를 수정하여 재판매가 가능하지만, 해당 코드를 공개해야 하며,&lt;/li&gt;
&lt;li&gt;개발자는 코드로 인해 발생하는 어떤 문제에 대해서도 법적 책임을 지지 않는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;GNU 프로젝트에서 linux를 main os로 채택&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;linus-torvalds&#34;&gt;Linus Torvalds&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 커널을 최초로 개발하였으며, 현재도 리눅스 커널 최고 설계자로 위치&lt;/li&gt;
&lt;li&gt;Git 개발에도 참여하였음&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;리눅스는 수많은 개발자들이 개발에 동참하기에 개발 속도가 빠르고 분량이 방대하다.&lt;/li&gt;
&lt;li&gt;1991년 0.01버전이 공개되고, 1994년 1.0버전이, 1999년 2.4가 발표되었다.&lt;/li&gt;
&lt;li&gt;커널은 같지만, Redhat Ubuntu CentOs Fedora 등 다양한 배포 버전이 개발되었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;linux-hierarchy&#34;&gt;Linux hierarchy&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;리눅스는 다음과 같은 구조로 구성되어 하드웨어를 제어한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Hardware -&amp;gt;&lt;br&gt;
Linux Kernel -&amp;gt;&lt;br&gt;
System Call Interface -&amp;gt;&lt;br&gt;
System Utilities -&amp;gt;&lt;br&gt;
Linux Shell&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux_env</title>
      <link>https://aswinblue.github.io/Blog/post/linux/linux_env/</link>
      <pubDate>Mon, 10 Jul 2023 21:04:56 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/linux_env/</guid>
      <description>&lt;h1 id=&#34;dev-in-linux&#34;&gt;Dev in Linux&lt;/h1&gt;
&lt;p&gt;리눅스 개발환경 구축을 위한 가이드&lt;/p&gt;
&lt;h2 id=&#34;사용자-맞춤-설정&#34;&gt;사용자 맞춤 설정&lt;/h2&gt;
&lt;h3 id=&#34;bashrc&#34;&gt;.bashrc&lt;/h3&gt;
&lt;p&gt;홈 디렉터리에 위치한 user별 설정 파일이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;source ~/.bashrc&lt;/code&gt; 명령어로 언제든 새로고침 할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 콘솔 프롬프트를 보기 쉽게 색칠하기 위한 설정할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;force_color_prompt=true
if [ -n &amp;#34;$force_color_prompt&amp;#34; ]; then
    if [ -x /usr/bin/tput ] &amp;amp;&amp;amp; tput setaf 1 &amp;gt;&amp;amp;/dev/null; then
	# We have color support; assume it&amp;#39;s compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ &amp;#34;$color_prompt&amp;#34; = yes ]; then
    PS1=&amp;#39;${debian_chroot:+($debian_root)}\[\033[01;32m\]\u\[\033[01;36m\]@\[\033[01;35m\]\h\[\033[00m\]:\[\033[01;033m\]\w\$\[\033[00m\]&amp;#39;
else
    PS1=&amp;#39;${debian_chroot:+($debian_chroot)}\u@\h:\w\$ &amp;#39;
fi
unset color_prompt force_color_prompt
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;vi&#34;&gt;vi&lt;/h3&gt;
&lt;p&gt;리눅스에서 활용할 수 있는 기본적인 에디터이다. 진입장벽은 높은 편이지만, 한번 익숙해지면 매우 편리하다.&lt;br&gt;
~/.vimrc 폴더에 기본 설정을 적용할 수 있다.&lt;br&gt;
기본적인 설정은 아래와 같이 세팅할 수 있다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Virtual_box</title>
      <link>https://aswinblue.github.io/Blog/post/linux/virtual_box/</link>
      <pubDate>Sun, 02 Jul 2023 20:03:24 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/virtual_box/</guid>
      <description>&lt;h1 id=&#34;virtualbox&#34;&gt;VirtualBox&lt;/h1&gt;
&lt;h2 id=&#34;문제와-해결&#34;&gt;문제와 해결&lt;/h2&gt;
&lt;h3 id=&#34;root-계정&#34;&gt;root 계정&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;virtual box를 생성하면 기본 user의 이름은 vboxuser로 세팅되어 있다. 하지만 vboxuser는 sudo 권한이 없어 다른 설정을 수행 할 수가 없다.&lt;/li&gt;
&lt;li&gt;virtual box에서 root 계정 비밀번호를 변경하는 방법은 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;virtualbox에서 원하는 ubuntu machine를 실행시킨다.&lt;/li&gt;
&lt;li&gt;machine이 실행되는 도중 shift키를 클릭하고 있는다.&lt;/li&gt;
&lt;li&gt;부팅 모드 선택 화면이 뜨면 &lt;code&gt;Advanced options for Ubuntu&lt;/code&gt; 를 선택하고, &lt;code&gt;(recovery mode)&lt;/code&gt;표시가 되어있는 항목으로 부팅을 시도한다.&lt;/li&gt;
&lt;li&gt;로딩이 완료되면 &lt;code&gt;root&lt;/code&gt; 라는 항목을 선택하여 root 계정의 비밀번호를 재설정 할 수 있다.&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    
    <item>
      <title>Flutter</title>
      <link>https://aswinblue.github.io/Blog/post/mobileapp/flutter/</link>
      <pubDate>Thu, 19 Jan 2023 22:01:38 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/mobileapp/flutter/</guid>
      <description>&lt;h1 id=&#34;개발환경-및-기본-지식&#34;&gt;개발환경 및 기본 지식&lt;/h1&gt;
&lt;h2 id=&#34;구성-파일들&#34;&gt;구성 파일들&lt;/h2&gt;
&lt;p&gt;analysis_options.yaml : flutter rule을 설정하는 파일
assets : 이미지 등 리소스들을 저장하는 경로
lib/main.dart : 메인 App 소스가 구동되는 dart 파일
pubspec.yaml : 리소스 경로 및 API들을 설정할 수 있는 파일 (assets 폴더 설정 가능)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 경로 설정
flutter:
  assets:
    - assets/
	
# dependency 설정
dependencies:
  flutter:
    sdk: flutter
  cupertino_icons: ^1.0.2
  
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;android/app/src/main/AndroidManifext.xml : 안드로이드 앱 개발시 권한 부여를 위한 파일&lt;/p&gt;
&lt;h2 id=&#34;빌드-및-실행&#34;&gt;빌드 및 실행&lt;/h2&gt;
&lt;p&gt;main.dart 파일을 지정하고 실행시켜야 한다.
이때, dart 빌드가 아닌 flutter 빌드를 해준다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Computer Science</title>
      <link>https://aswinblue.github.io/Blog/post/computerscience/computer_science/</link>
      <pubDate>Thu, 19 Jan 2023 21:59:14 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/computerscience/computer_science/</guid>
      <description>&lt;h1 id=&#34;computer-science&#34;&gt;Computer Science&lt;/h1&gt;
&lt;h2 id=&#34;cpu&#34;&gt;CPU&lt;/h2&gt;
&lt;h3 id=&#34;segment&#34;&gt;Segment&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;프로세스가 사용하는 메모리를 Segment라 칭하며, 리눅스에서는 5가지 종류로 이를 분류한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;코드 세그먼트&lt;/code&gt; : 실행 가능한 코드가 위치한 영역으로, text segment라고도 부른다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;데이터 세그먼트&lt;/code&gt; : 코드 실행에 필요한 데이터가 있는 영역으로, 전역변수 및 전역 상수들이 위치한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;읽기/쓰기가 모두 가능한 데이터들은 data segment에 저장된다.&lt;/li&gt;
&lt;li&gt;읽기만 가능한 상수 데이터들은 rodata(read-only) segment 에 저장된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;&lt;code&gt;BSS 세그먼트&lt;/code&gt; : Block Started by Symbol 의 약자로, 컴파일시점에 값이 정해지지 않은 전역변수가 저장되는 영역이다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;이 영역은 프로그램 시작시 모두 0으로 초기화 된다. C에서 전역변수가 0 으로 초기화되는 이유가 이 때문이다.&lt;/li&gt;
&lt;li&gt;읽기와 쓰기가 모두 가능한 영역이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;code&gt;힙 세그먼트&lt;/code&gt; : 동적으로 할당되는 데이터들을 저장하는 영역이다. 스택과 마주보는 방향으로 증가한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;스택 세그먼트&lt;/code&gt; : 프로세스의 스택이 위치하는 영역으로, 지역변수 및 함수 인자들이 저장된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;스택 세그먼트는 메모리 마지막 주소(가장 큰 주소)부터 시작해서 힙과 마주보는 방향으로 증가한다.&lt;/li&gt;
&lt;li&gt;운영체제가 프로세스 동작 상황에 따라 스택 영역을 관리한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;세그먼트는 위에서 언급된 순서대로 메모리에 배치되며, 스택 세그먼트만 특이하게 메모리 가장 마지막을 기준으로 할당된다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git</title>
      <link>https://aswinblue.github.io/Blog/post/git/git/</link>
      <pubDate>Sat, 09 Jul 2022 10:58:55 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/git/git/</guid>
      <description>&lt;h1 id=&#34;git&#34;&gt;Git&lt;/h1&gt;
&lt;h2 id=&#34;cache&#34;&gt;Cache&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Cache 확인: &lt;code&gt;git ls-files --stage FILE_PATH&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Cache 삭제: &lt;code&gt;git rm -r --cached FILE_PATH&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&#39;PATH&#39; already exists in the index&lt;/code&gt; 오류가 발생했을 때, cache를 확인하고 삭제하면 해결 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;config&#34;&gt;config&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config&lt;/code&gt; 명령으로  git 관련 setting을 확인 및 설정할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --list&lt;/code&gt; : 설정된 내용 확인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --add&lt;/code&gt; : 설정 추가
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--system&lt;/code&gt; : 컴퓨터 환경에 적용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--global&lt;/code&gt; : 사용자 환경에 적용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--local&lt;/code&gt; : repository별로 설정 적용, default값
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git config --global user.name &amp;lt;USER_NAME&amp;gt;&lt;/code&gt; : 사용자 이름 설정, 구역 인자를 붙이면 &amp;ndash;add 는 생략가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --global user.email &amp;lt;EMAIL&amp;gt;&lt;/code&gt; : 사용자 email 설정, 구역 인자를 붙이면 &amp;ndash;add 는 생략가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git config --unset&lt;/code&gt; : 설정 제거&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;submodule&#34;&gt;Submodule&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;생성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git repository 안에 다른 git repository를 관리할 때 사용한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>thymeleaf</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/thymeleaf/</link>
      <pubDate>Wed, 29 Jun 2022 20:00:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/thymeleaf/</guid>
      <description>&lt;h1 id=&#34;thymeleaf&#34;&gt;Thymeleaf&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;서버에서 view를 구성할 때 사용하는 라이브러리&lt;/li&gt;
&lt;li&gt;태그 형식의 문법을 사용하며 vue와 유사하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.thymeleaf.org/doc/tutorials/2.1/usingthymeleaf.html&#34;&gt;thymeleaf 공식 튜토리얼&lt;/a&gt; 에서 기본적인 문법을 확인할 수 있다.&lt;/li&gt;
&lt;li&gt;태그 안에  &lt;code&gt;th:속성=&amp;quot;값&amp;quot;&lt;/code&gt; 형태의 속성을 추가하는 형태로 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;text&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;span th:text=&amp;quot;${text}&amp;quot;&amp;gt;default text&amp;lt;/span&amp;gt;&lt;/code&gt;: 서버에서 &amp;rsquo;text&amp;rsquo;라는 이름으로 정의한 태그가 있으면 text를 표시한다. text변수가 없으면 &lt;code&gt;&amp;lt;span&amp;gt;default text&amp;lt;/span&amp;gt;&lt;/code&gt;를 표시한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;utext&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;span th:utext=&amp;quot;${utext}&amp;quot;&amp;gt;default text&amp;lt;/span&amp;gt;&lt;/code&gt;: &amp;rsquo;text&amp;rsquo; 이름으로 정의한 텍스트를 &amp;lsquo;span&amp;rsquo; 태그에 넣어 표시한다. &amp;rsquo;text&amp;rsquo;변수가 없으면 &amp;lsquo;default text&amp;rsquo;를 표시한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;fragment&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div th:fragment=&amp;quot;name&amp;quot;&amp;gt;&lt;/code&gt;: &amp;rsquo;name&amp;rsquo; 이라는 이름으로 fragment를 생성한다. fragment는 &lt;code&gt;th:replace&lt;/code&gt;, &lt;code&gt;th:copy&lt;/code&gt; 를 사용해서 재활용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;copy&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div th:copy=&amp;quot;this::name&amp;quot;&amp;gt;&lt;/code&gt;: 현재 파일의 &amp;rsquo;name&amp;rsquo; fragment를 &amp;lsquo;div&amp;rsquo;태그로 표현한다. &amp;rsquo;this&amp;rsquo; 대신 파일 이름을 사용하면 다른 파일의 fragment를 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;replace&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div th:replace=&amp;quot;this::name&amp;quot;&amp;gt;&lt;/code&gt;: 현재 파일의 &amp;rsquo;name&amp;rsquo; fragment로 대체한다.(태그도 바뀐다.) &amp;rsquo;this&amp;rsquo; 대신 파일 이름을 사용하면 다른 파일의 fragment를 사용가능하다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Tailwind</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/tailwind/</link>
      <pubDate>Thu, 02 Jun 2022 21:55:38 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/tailwind/</guid>
      <description>&lt;h1 id=&#34;tailwind&#34;&gt;Tailwind&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Css 프레임워크로 빠르고 효율적으로 css를 설정할 수 있는 툴이다.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tailwindcss.com/docs&#34;&gt;Tailwind Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;tailwind 모듈 설치&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm install -D tailwindcss@latest&lt;/code&gt; 명령을 사용하여 설치가 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npx tailwindcss init&lt;/code&gt; 명령을 사용하면 현재 경로에 tailwind.config.js 파일이 생성되며, 현재 프로젝트에서 tailwind를 적용할 수 있게 된다.
&lt;ul&gt;
&lt;li&gt;tailwind.config.js 파일은 다음과 같이 구성된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;module.exports = {
  // 포함할 항목
  content: [&amp;#39;./src/**/*.{html,js,jsx,ts,tsx, mustache}&amp;#39;],
  // 제외할 항목 (최신 버전에서 사용되지 않는 문법)
  // purge: [&amp;#34;./src/**/*.html&amp;#34;, &amp;#34;./src/**/*.js&amp;#34;],
  // jit mode는 purge와 함께 세트로 사용되었고, 세트로 사라졌다.(?)
  // mode: process.env.NODE_ENV ? &amp;#39;jit&amp;#39; : undefined,
  darkMode: &amp;#39;class&amp;#39;, // [false, &amp;#39;mdeia&amp;#39;, &amp;#39;class&amp;#39;]
  theme: {
    fontFamily: {
      display: [&amp;#39;Open Sans&amp;#39;, &amp;#39;sans-serif&amp;#39;],
      body: [&amp;#39;Open Sans&amp;#39;, &amp;#39;sans-serif&amp;#39;],
    },
    extend: {
      fontSize: {
        14: &amp;#39;14px&amp;#39;,
      },
      backgroundColor: {
        &amp;#39;main-bg&amp;#39;: &amp;#39;#FAFBFB&amp;#39;,
        &amp;#39;main-dark-bg&amp;#39;: &amp;#39;#20232A&amp;#39;,
        &amp;#39;secondary-dark-bg&amp;#39;: &amp;#39;#33373E&amp;#39;,
        &amp;#39;light-gray&amp;#39;: &amp;#39;#F7F7F7&amp;#39;,
        &amp;#39;half-transparent&amp;#39;: &amp;#39;rgba(0, 0, 0, 0.5)&amp;#39;,
      },
      borderWidth: {
        1: &amp;#39;1px&amp;#39;,
      },
      borderColor: {
        color: &amp;#39;rgba(0, 0, 0, 0.1)&amp;#39;,
      },
      width: {
        400: &amp;#39;400px&amp;#39;,
        760: &amp;#39;760px&amp;#39;,
        780: &amp;#39;780px&amp;#39;,
        800: &amp;#39;800px&amp;#39;,
        1000: &amp;#39;1000px&amp;#39;,
        1200: &amp;#39;1200px&amp;#39;,
        1400: &amp;#39;1400px&amp;#39;,
      },
      height: {
        80: &amp;#39;80px&amp;#39;,
      },
      minHeight: {
        590: &amp;#39;590px&amp;#39;,
      },
      backgroundImage: {
        &amp;#39;hero-pattern&amp;#39;:
          &amp;#34;url(&amp;#39;https://demos.wrappixel.com/premium-admin-templates/react/flexy-react/main/static/media/welcome-bg-2x-svg.25338f53.svg&amp;#39;)&amp;#34;,
      },
    },
  },
  plugins: [],
};
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;tailwind는 react와 같은 framework에서는 자동으로 적용이 가능하지만, 그 외의 경우에는 postcss 등과 같은 모듈의 도움이 필요하다.&lt;/li&gt;
&lt;li&gt;tailwind 모듈 설치와 tailwind.config.js 구성이 끝났다면, tailwind로 작성된 css를 코드에 추가해줘야 한다. index.css에 아래 구문을 추가한다.
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;@tailwind base;
@tailwind components;
@tailwind utilities;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postcss&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring_boot</title>
      <link>https://aswinblue.github.io/Blog/post/webserver/spring_boot/</link>
      <pubDate>Mon, 30 May 2022 19:20:23 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webserver/spring_boot/</guid>
      <description>&lt;h1 id=&#34;spring-boot&#34;&gt;Spring Boot&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Spring boot는 서버 생성을 위한 도구로, spring 프레임워크에 편의성을 향상시킨 프레임워크이다.&lt;/li&gt;
&lt;li&gt;Java, Kitlin, Groovy 등의 언어로 구현이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;개발환경&#34;&gt;개발환경&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;java 기반으로 동작하기에 jdk 설치가 필요하다.
&lt;ul&gt;
&lt;li&gt;(22년 기준) 11버전 이상을 다운받는것을 추천한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IDE
&lt;ul&gt;
&lt;li&gt;vs code를 사용한다면 확장패키지로 &amp;lsquo;Java Extension Pack&amp;rsquo; 과 &amp;lsquo;Spring Boot Extension Pack&amp;rsquo; 을 설치한다.&lt;/li&gt;
&lt;li&gt;java 개발을 위한 eclips나 intelliJ를 사용해도 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;spring 프로젝트 생성
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start.spring.io&lt;/code&gt; 페이지에 들어가면 프로젝트를 생성할 수 있는 UI가 구성되어 있다. 원하는대로 설정 후 다운로드를 받아서 사용하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;gradle 설치
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;https://gradle.org/releases/&lt;/code&gt; 주소에서 gradle 파일을 다운받는다.&lt;/li&gt;
&lt;li&gt;이후 path 설정을 마친 후, 프로젝트 root directory에서 &lt;code&gt;gradle wrapper&lt;/code&gt; 명령을 수행해 gradlew파일을 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;기본-설정&#34;&gt;기본 설정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;포트 설정
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;application.properties&lt;/code&gt; (혹은 yml)파일을 열고, &lt;code&gt;server.port = 8080&lt;/code&gt; 와 같이 기입하면 동작 포트를 8080으로 설정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;devtools 설정&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;정적 파일들을 갱신했을 때, 서버 재실행 없이 explorer만 reload 해 주면 변경점이 반영될 수 있도록 한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Algorithm</title>
      <link>https://aswinblue.github.io/Blog/post/algorithm/algorithm/</link>
      <pubDate>Sun, 24 Apr 2022 18:16:23 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/algorithm/algorithm/</guid>
      <description>&lt;h1 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h1&gt;
&lt;h2 id=&#34;그래프-탐색&#34;&gt;그래프 탐색&lt;/h2&gt;
&lt;h3 id=&#34;spshortest-path&#34;&gt;SP(Shortest Path)&lt;/h3&gt;
&lt;p&gt;단일 출발점에서 단일 목적지까지 최단 경로를 찾는 알고리즘&lt;/p&gt;
&lt;h4 id=&#34;dfs&#34;&gt;DFS&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;용도 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;경로가 있는지 확인할 때 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;자로구조 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;stack&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;방법 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;시작 node를 stack에 넣는다.&lt;/li&gt;
&lt;li&gt;stack이 모두 빌때까지 아래 동작을 반복한다.&lt;/li&gt;
&lt;li&gt;stack의 top을 현재 node로 설정한다.&lt;/li&gt;
&lt;li&gt;현재 node를 &amp;lsquo;visited&amp;rsquo; 처리하고 stack에서 제거한다.&lt;/li&gt;
&lt;li&gt;다음으로 이동할 node가 있는지 확인한다.&lt;/li&gt;
&lt;li&gt;다음으로 이동할 node &amp;lsquo;A&amp;rsquo;가 있다면, 현재 node에서 그다음에 탐색할 방향을 stack에 push하고, node &amp;lsquo;A&amp;rsquo;도 stack에 push한다.&lt;/li&gt;
&lt;li&gt;더이상 갈 곳이 없으면 현재 node의 visited 처리를 복원한다.&lt;/li&gt;
&lt;li&gt;최종 목적지에 도달한 경우를 모아 결과값을 비교한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;예시 :&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;bfs&#34;&gt;BFS&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;용도 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;최단경로 탐색에 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;자로구조 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;queue&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;방법 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;시작 node를 queue에 넣는다.&lt;/li&gt;
&lt;li&gt;queue가 비거나 목적지에 도달할 때 까지 아래 동작을 반복한다.&lt;/li&gt;
&lt;li&gt;queue의 front를 pop 하여 현재 node로 설정한다.&lt;/li&gt;
&lt;li&gt;현재 node에서 이동 가능한 node가 있는지 확인하고, 이동 가능하다면 모두 queue에 push한다.&lt;/li&gt;
&lt;li&gt;queue에 push하면서 해당 경로는 &amp;lsquo;visited&amp;rsquo; 처리를 한다.
&lt;ul&gt;
&lt;li&gt;(주의) queue에 넣으면서 visited 처리를 하고, queue에 넣기전에 방문 여부를 판단해야 메모리 부족을 예방할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sssp-single-source-shortest-path&#34;&gt;SSSP (Single Source Shortest Path)&lt;/h3&gt;
&lt;p&gt;단일 출발점에서 모든 node까지 최단 경로를 찾는 알고리즘&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>VsCode</title>
      <link>https://aswinblue.github.io/Blog/post/developtips/vscode/</link>
      <pubDate>Sat, 16 Apr 2022 09:07:48 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/developtips/vscode/</guid>
      <description>&lt;h1 id=&#34;vs-code&#34;&gt;VS code&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;visual studio code 사용법&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;개발환경&#34;&gt;개발환경&lt;/h2&gt;
&lt;h3 id=&#34;c--c&#34;&gt;C / C++&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;컴파일러&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;gcc 혹은 mingw 설치가 필요하다. 인터넷에서 설치하도록 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;설정파일&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;컴파일 및 실행을 위해서는 launch.json, setting.json, tasks.json 파일이 필요하다.&lt;/li&gt;
&lt;li&gt;vs code에서 알아서 작성해 주지만, 기본 설정으로 부족한 부분은 수정해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# settings.json
{
  &amp;#34;C_Cpp_Runner.cStandard&amp;#34;: &amp;#34;&amp;#34;,
  &amp;#34;C_Cpp_Runner.cppStandard&amp;#34;: &amp;#34;&amp;#34;,
  &amp;#34;C_Cpp_Runner.msvcBatchPath&amp;#34;: &amp;#34;&amp;#34;,
  &amp;#34;C_Cpp_Runner.warnings&amp;#34;: [
    &amp;#34;-Wall&amp;#34;,
    &amp;#34;-Wextra&amp;#34;,
    &amp;#34;-Wpedantic&amp;#34;
  ],
  &amp;#34;C_Cpp_Runner.enableWarnings&amp;#34;: true,
  &amp;#34;C_Cpp_Runner.warningsAsError&amp;#34;: false,
  &amp;#34;C_Cpp_Runner.compilerArgs&amp;#34;: [],
  &amp;#34;C_Cpp_Runner.linkerArgs&amp;#34;: [],
  &amp;#34;C_Cpp_Runner.includePaths&amp;#34;: [],
  &amp;#34;C_Cpp_Runner.includeSearch&amp;#34;: [
    &amp;#34;*&amp;#34;,
    &amp;#34;**/*&amp;#34;
  ],
  &amp;#34;C_Cpp_Runner.excludeSearch&amp;#34;: [
    &amp;#34;**/build&amp;#34;,
    &amp;#34;**/build/**&amp;#34;,
    &amp;#34;**/.*&amp;#34;,
    &amp;#34;**/.*/**&amp;#34;,
    &amp;#34;**/.vscode&amp;#34;,
    &amp;#34;**/.vscode/**&amp;#34;
  ],
  &amp;#34;C_Cpp_Runner.cCompilerPath&amp;#34;: &amp;#34;gcc&amp;#34;,
  &amp;#34;C_Cpp_Runner.cppCompilerPath&amp;#34;: &amp;#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/g++.exe&amp;#34;,
  &amp;#34;C_Cpp_Runner.debuggerPath&amp;#34;: &amp;#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gdb.exe&amp;#34;,
  &amp;#34;files.associations&amp;#34;: {
    &amp;#34;hash_map&amp;#34;: &amp;#34;cpp&amp;#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# launch.json
{
  &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;,
  &amp;#34;configurations&amp;#34;: [
    {
      &amp;#34;name&amp;#34;: &amp;#34;C/C++ Runner: Debug Session&amp;#34;,
      &amp;#34;type&amp;#34;: &amp;#34;cppdbg&amp;#34;,
      &amp;#34;request&amp;#34;: &amp;#34;launch&amp;#34;,
      &amp;#34;args&amp;#34;: [],
      &amp;#34;stopAtEntry&amp;#34;: false,
      &amp;#34;cwd&amp;#34;: &amp;#34;f:/Documents/GitHub/acmicpc/15997&amp;#34;,
      &amp;#34;environment&amp;#34;: [],
      &amp;#34;program&amp;#34;: &amp;#34;동작시킬 프로그램 경로&amp;#34;,
      &amp;#34;internalConsoleOptions&amp;#34;: &amp;#34;openOnSessionStart&amp;#34;,
      &amp;#34;MIMode&amp;#34;: &amp;#34;gdb&amp;#34;,
      &amp;#34;miDebuggerPath&amp;#34;: &amp;#34;C:/Program Files (x86)/mingw-w64/i686-8.1.0-posix-dwarf-rt_v6-rev0/mingw32/bin/gdb.exe&amp;#34;,
      &amp;#34;externalConsole&amp;#34;: false,
      &amp;#34;setupCommands&amp;#34;: [
        {
          &amp;#34;description&amp;#34;: &amp;#34;Enable pretty-printing for gdb&amp;#34;,
          &amp;#34;text&amp;#34;: &amp;#34;-enable-pretty-printing&amp;#34;,
          &amp;#34;ignoreFailures&amp;#34;: true
        }
      ]
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# tasks.json
{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &amp;#34;version&amp;#34;: &amp;#34;2.0.0&amp;#34;,
    &amp;#34;tasks&amp;#34;: [
        {
            &amp;#34;type&amp;#34;: &amp;#34;shell&amp;#34;,
            &amp;#34;label&amp;#34;: &amp;#34;execute&amp;#34;,
            &amp;#34;command&amp;#34;: &amp;#34;${fileDirname}/${fileBasenameNoExtension}.exe&amp;#34;,
            &amp;#34;group&amp;#34;: {
                &amp;#34;kind&amp;#34;: &amp;#34;test&amp;#34;,
                &amp;#34;isDefault&amp;#34;: true
            },
            &amp;#34;problemMatcher&amp;#34;: []
        },
        {
            &amp;#34;type&amp;#34;: &amp;#34;cppbuild&amp;#34;,
            &amp;#34;label&amp;#34;: &amp;#34;C/C++: g++.exe 활성 파일 빌드&amp;#34;,
            &amp;#34;command&amp;#34;: &amp;#34;C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin\\g++.exe&amp;#34;,
            &amp;#34;args&amp;#34;: [
                &amp;#34;-fdiagnostics-color=always&amp;#34;,
                &amp;#34;-g&amp;#34;,
                &amp;#34;${file}&amp;#34;,
                &amp;#34;-o&amp;#34;,
                &amp;#34;${fileDirname}\\${fileBasenameNoExtension}.exe&amp;#34;
            ],
            &amp;#34;options&amp;#34;: {
                &amp;#34;cwd&amp;#34;: &amp;#34;${fileDirname}&amp;#34;
            },
            &amp;#34;problemMatcher&amp;#34;: [
                &amp;#34;$gcc&amp;#34;
            ],
            &amp;#34;group&amp;#34;: &amp;#34;build&amp;#34;,
            &amp;#34;detail&amp;#34;: &amp;#34;컴파일러: \&amp;#34;C:\\Program Files (x86)\\mingw-w64\\i686-8.1.0-posix-dwarf-rt_v6-rev0\\mingw32\\bin\\g++.exe\&amp;#34;&amp;#34;
        }
    ]
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;단축키&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl + Shift + P&lt;/code&gt; 단축키로 명령을 일일이 수행해도 되지만, 단축키를 설정해 바로 실행하는게 빠르다.&lt;/li&gt;
&lt;li&gt;파일 -&amp;gt; 기본설정 -&amp;gt; 바로가기키 (&lt;code&gt;Ctrl + K &amp;amp; Ctrl + S&lt;/code&gt;) 를 누르고, 우측 상단 &amp;lsquo;바로가기 키 열기&amp;rsquo; 를 클릭하여 단축키를 직접 입력한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 키 바인딩을 이 파일에 넣어서 기본값 재정의
[
    {
        &amp;#34;key&amp;#34;: &amp;#34;ctrl+alt+c&amp;#34;,
        &amp;#34;command&amp;#34;: &amp;#34;workbench.action.tasks.build&amp;#34;,
    },
    {
        &amp;#34;key&amp;#34;: &amp;#34;ctrl+alt+e&amp;#34;,
        &amp;#34;command&amp;#34;: &amp;#34;workbench.action.tasks.test&amp;#34;,
    }
]
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43;_stl</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/c&#43;&#43;_stl/</link>
      <pubDate>Tue, 12 Apr 2022 19:17:21 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/c&#43;&#43;_stl/</guid>
      <description>&lt;h1 id=&#34;c-stl&#34;&gt;C++ STL&lt;/h1&gt;
&lt;h2 id=&#34;자료구조&#34;&gt;자료구조&lt;/h2&gt;
&lt;h3 id=&#34;map&#34;&gt;map&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;key-value 쌍으로 이루어진 tree형태의 자료구조&lt;/li&gt;
&lt;li&gt;중복을 허용하지 않음&lt;/li&gt;
&lt;li&gt;C++에서는 red black tree로 구현되어 삽입,삭제가 O(log n) 안에 이루어진다.&lt;/li&gt;
&lt;li&gt;내부적으로 key를 기준으로 오름차순으로 자료를 정렬한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;헤더 :  &lt;code&gt;#include &amp;lt;map&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선언 : &lt;code&gt;map&amp;lt;int, int&amp;gt; map1;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;내림차순으로 선언 : &lt;code&gt;map &amp;lt;int, int, greater&amp;gt; map2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;삽입 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;insert : &lt;code&gt;map1.insert({&amp;quot;key&amp;quot;,VALUE})&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;[] : &lt;code&gt;map1[&amp;quot;key&amp;quot;] = VALUE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;삭제 :&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;특정 index : &lt;code&gt;map1.erase(map1.begin()+2)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;특정 key : &lt;code&gt;map1.erase(KEY)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;구간 : &lt;code&gt;map1.erase(map1.begin(), map1.end())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;전체 : &lt;code&gt;map1.clear()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;검색 :&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map&amp;lt;int, int&amp;gt;::Iterator res;

if ((res = map1.find(KEY)) != m.end()) {
  res -&amp;gt; first; // key
  res -&amp;gt; second; // value
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;반복문 :&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;for (auto itr = map1.begin(); itr != map1.end(); itr++) {
  itr-&amp;gt;first // key
  itr-&amp;gt;second // value
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;hash-map&#34;&gt;hash map&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;hash table을 이용한 자료구조&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;정렬이 필요없는 비순차적 구조&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;헤더 : &lt;code&gt;#include&amp;lt;hash_map&amp;gt;&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Window</title>
      <link>https://aswinblue.github.io/Blog/post/developtips/window/</link>
      <pubDate>Sat, 19 Mar 2022 08:29:51 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/developtips/window/</guid>
      <description>&lt;p&gt;#MS Window&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MS window 사용시 필요한 편이 기능들을 나열&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wsl2&#34;&gt;WSL2&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;윈도우에서 리눅스를 실행하는 방법이다.&lt;/li&gt;
&lt;li&gt;windows 10 이상부터 지원 가능하며, microsoft store에서 ubuntu를 설치하는 방식이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;PowerShell을 관리자 권한으로 실행하여 아래 명령어 입력&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;$ dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart&lt;br&gt;
$ dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart&lt;br&gt;
$ wsl &amp;ndash;set-default-version 2&lt;/p&gt;&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;WSL 콘솔에서 &lt;code&gt;explorer.exe .&lt;/code&gt; 를 입력하면 현재 경로를 윈도우의 파일 탐색기로 열 수 있다. 해당 경로에 파일을 옮기면 윈도우-리눅스 간 파일 이동이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;환경변수&#34;&gt;환경변수&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;환경변수 설정시 컴퓨터를 재부팅하지 않고 적용하는 방법&lt;/li&gt;
&lt;li&gt;콘솔에 &lt;code&gt;taskkill /f /im explorer.exe&lt;/code&gt;, &lt;code&gt;explorer.exe&lt;/code&gt; 명령을 순서대로 입력한다.&lt;/li&gt;
&lt;li&gt;작업표시줄이 없어졌다 생겨나면 적용이 된 것이다. 켜져있던 탐색기는 복원되지 않으니 주의&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;batch&#34;&gt;batch&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;call&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;기본 command가 아닌 package command를 수행할 경우, batch파일에 명령어를 그대로 넣어서 수행하면 첫번째 줄만 수행될 수 있다.&lt;/li&gt;
&lt;li&gt;이때 &lt;code&gt;call&lt;/code&gt; 명령어를 사용해주면 여러 라인을 실행 가능하다.
ex)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;call npm run build
cd server
call gradle wrapper
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;리눅스에서-파일-가져오기&#34;&gt;리눅스에서 파일 가져오기&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scp&lt;/code&gt; 명령을 사용해서 리눅스에서 파일을 가져올 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;scp &amp;lt;계정&amp;gt;@&amp;lt;리눅스_IP주소&amp;gt;:리눅스에서_가져올_파일_경로 윈도우에_저장할_경로&lt;/code&gt; 형태로 사용 가능하다.&lt;/li&gt;
&lt;li&gt;ex) &lt;code&gt;scp kim@10.162.32.11:target_file C:\&lt;/code&gt; : C 경로에 target_file을 받아온다. target_file에 절대경로를 사용하는게 좋다. 상대경로를 사용할 시 절대 경로는 /home/kim/target_file 가 된다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Firebase_react</title>
      <link>https://aswinblue.github.io/Blog/post/databases/firebase_react/</link>
      <pubDate>Sat, 12 Feb 2022 19:32:34 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/databases/firebase_react/</guid>
      <description>&lt;h1 id=&#34;firebase-with-react&#34;&gt;Firebase with React&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;react에서 firebase를 활용하는 방법&lt;/li&gt;
&lt;li&gt;firebase SDK를 설치하거나 웹상에서 설치없이 사용하는 방법은 firebase 기본을 참조&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;인증-auth&#34;&gt;인증 (Auth)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;firebase 로 계정 생성 및 로그인&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;firebase API를 import하여 사용&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;AppFirebase.js&amp;gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import firebase from &amp;#34;firebase/compat/app&amp;#34;;
import &amp;#34;firebase/compat/auth&amp;#34;;

const firebaseConfig = {
apiKey: process.env.REACT_APP_API_KEY,
authDomain: process.env.REACT_APP_AUTHDOMAIN,
projectId: process.env.REACT_APP_PROJECTID,
storageBucket: process.env.REACT_APP_STORAGEBUCKET,
messagingSenderId: process.env.REACT_APP_MESSAGINGSENDERID,
appId: process.env.REACT_APP_APPID
};

export default firebase.initializeApp(firebaseConfig);
export const authService = firebase.auth();
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;AppFirebase.js 를 활용하여 business logic에 필요한 로그인 / 회원가입 기능을 구현
&amp;lt;Auth.js&amp;gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import { authService } from &amp;#34;../components/AppFirebase&amp;#34;;

const data = await authService.createUserWithEmailAndPassword(email, password)  // email, passwd로 계정 생성
const data = await authService.signInWithEmailAndPassword(email, password)  // email, passwd로 로그인
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;createUserWithEmailAndPassword / signInWithEmailAndPassword 실행 이후 authService.currentUser를 참조하면 user 정보를 받아올 수 있다.&lt;/li&gt;
&lt;li&gt;하지만, authService.currentUser 정보를 갱신하는데는 시간이 걸린다. firebase API에서는 observer를 등록하여 currentUser의 변경 시점을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;currentUser 변경시점에 특정함수 동작&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;user 정보가 갱신된 시점에 특정 동작을 원한다면, 아래와 같이 onAuthStateChanged 함수를 사용하면 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;authService.onAuthStateChanged((user) =&amp;gt; { /* something to do */ }});
&lt;/code&gt;&lt;/pre&gt;&lt;ol&gt;
&lt;li&gt;로그아웃&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;authService.signOut()&lt;/code&gt; 함수를 호출하여 로그아웃이 가능하다.&lt;/li&gt;
&lt;li&gt;참고로 크롬 웹 디버깅 화면에서 &amp;lsquo;Application&amp;rsquo;탭에 들어가서 IndexedDB -&amp;gt; firebaseLocalDb 안의 내용을 🚫버튼으로 삭제해 주면 로그인 정보가 사라진다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;에러&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;authService&lt;/code&gt;의 함수(&lt;code&gt;createUserWithEmailAndPassword&lt;/code&gt;, &lt;code&gt;signInWithEmailAndPassword&lt;/code&gt;, &amp;hellip;) 사용시 에러가 발생할 수 있으므로, try, catch문으로 묶어서 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;try {
  let data
  data = await authService.createUserWithEmailAndPassword(email, password)
} catch(error) {
  console.log(error.code) // 에러의 원인이 코드 형태로 출력된다.
  console.log(error.message) // 에러의 원인이 메시지 형태로 출력된다.
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;ref) 오류발생 원인&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cryptocurrency</title>
      <link>https://aswinblue.github.io/Blog/post/crypto/cryptocurrency/</link>
      <pubDate>Wed, 02 Feb 2022 13:22:27 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/crypto/cryptocurrency/</guid>
      <description>&lt;h1 id=&#34;cryptocurrency&#34;&gt;Cryptocurrency&lt;/h1&gt;
&lt;h2 id=&#34;cryptographic-hash-function&#34;&gt;Cryptographic Hash function&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;hash function은 아래와 같은 속성을 갖는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;모든 크기의 String을 input 으로 받는다.&lt;/li&gt;
&lt;li&gt;정해진 크기의 output을 생성한다. (bitcoin에서는 256bit)&lt;/li&gt;
&lt;li&gt;적당한 시간 안에 계산이 가능하다. (계산 시간이 너무 길지 않다)&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;cryptographic hash function은 아래와 같은 security 속성을 추가로 갖는다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;collision-free&lt;/li&gt;
&lt;li&gt;hiding&lt;/li&gt;
&lt;li&gt;puzzle-friendly&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;속성1-collision-free&#34;&gt;속성1. collision-free&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;x != y 라면, H(x) = H(y) 인 경우를 찾을 수 없어야 한다.&lt;/li&gt;
&lt;li&gt;이 말은 collision 이 존재하지 않는다는 뜻은 아니다. num(possible_input) &amp;gt; num(possible_outputs) 이다.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;찾을 수 없다&amp;rsquo; 라는 말은, collision이 존재하지만, hahs function의 결과를 예측할 수 없다는 뜻이다.
&lt;ul&gt;
&lt;li&gt;실제로, 2^130 개의 무작위 수를 선택하여 hash function을 돌렸을 때, 99.8%의 확률로 충돌이 발생한다.&lt;/li&gt;
&lt;li&gt;하지만 이 수치는 천문학적으로 크기 때문에 걱정할 필요가 없다. (collision을 발견할 확률은 인류가 만든 최고의 컴퓨터로 우주 생성시부터 계산을 해도, 2초뒤 지구에 운석이 떨어질 확률만큼 낮다.)&lt;/li&gt;
&lt;li&gt;collision을 쉽게 구하는 방법이 있는가?
-&amp;gt; 특정 hash function에 대해서는(SHA256에 대해서도 최단기간 collision을 찾아내는 방법이 알려져 있다.) 가능하지만, 대부분은 그렇지 않다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hash-as-message-digest&#34;&gt;hash as message digest&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;collision을 구하는 것이 매우 어렵기 때문에, H(x) = H(y)라면, x = y라고 확신해도 된다.&lt;/li&gt;
&lt;li&gt;즉, hash를 이용해 데이터 전송/비교에 드는 비용을 절감 가능하다. (전체 message 대신 hash만 비교)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;속성2-hiding&#34;&gt;속성2. hiding&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;H(x)를 갖고 x를 유추할 수 없다.&lt;/li&gt;
&lt;li&gt;hiding 속성을 가지려면 아래와 같은 방법을 사용한다.&lt;/li&gt;
&lt;li&gt;high min-entropy 를 가진 무작위 상수 &amp;lsquo;r&amp;rsquo;을 x와 조합(concatenate)하여 hash function의 input에 넣으면 hiding 속성을 갖게 된다. (&lt;code&gt;H(r|x)&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;high min-entropy 란 넓고 고르게 퍼져있음을 뜻한다. 즉, 넓은 선택범위 안에서 특정 값이 특출나게 여려번 중복해서 뽑히지 않는다는 뜻이다. (no particular value is chosen with more than negligible probability)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;commitment&#34;&gt;commitment&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;편지를 동봉하듯 데이터가 가지고 있는 내용을 공개하지 않고 데이터를 공개하는 것&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Firebase</title>
      <link>https://aswinblue.github.io/Blog/post/databases/firebase/</link>
      <pubDate>Wed, 19 Jan 2022 21:02:46 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/databases/firebase/</guid>
      <description>&lt;h1 id=&#34;firebase&#34;&gt;firebase&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;firebase는 실시간 db로 유명하며, google에 인수되고 폭이 넓어졌다.&lt;/li&gt;
&lt;li&gt;Amazon의 Amplify가 firebase와 유사하다.&lt;/li&gt;
&lt;li&gt;일정 사용량 까지는 무료로 사용 가능하며, 이후에는 요금이 부가된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설치-및-사용&#34;&gt;설치 및 사용&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;온라인으로 콘솔에 접속하여 프로젝트를 생성 및 설정하고, firebase sdk를 로컬에 다운받아 코드에 적용한다.&lt;/li&gt;
&lt;li&gt;firebase는 다양한 운영체제에 설치 가능하며, 각각의 설치 방법을 따르면 된다.
(웹에서는 설치하지 않고 url로 참조해 사용할 수도 있다.)&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;버전이 올라감에 따라 참조방법, 인터페이스 등 사용법이 바뀌는 경우가 많으니 항상 docs를 잘 살펴보자&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Golang</title>
      <link>https://aswinblue.github.io/Blog/post/golang/golang/</link>
      <pubDate>Fri, 14 Jan 2022 21:52:14 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/golang/golang/</guid>
      <description>&lt;h1 id=&#34;go&#34;&gt;Go&lt;/h1&gt;
&lt;h2 id=&#34;설치-및-프로젝트-생성&#34;&gt;설치 및 프로젝트 생성&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;구글 검색을 통해 설치파일을 다운받는다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;root 디렉터리 설정이 필요하다.(&amp;lsquo;C:\Go, &amp;lsquo;/usr/local/go/bin/&amp;rsquo;)&lt;/li&gt;
&lt;li&gt;이후 생성할 프로젝트는 이 root 디렉터리 하위 경로에 생성된다. 외부 경로에는 프로젝트를 생성할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;root 디렉터리 안 src 디렉터리에 프로젝트를 생성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Go는 npm, pip 와 같이 패키지 매니저가 없다. git 등에서 코드를 받아오면 src 디렉터리 안에 도메인별로 정리해서 관리하는게 정석이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문법&#34;&gt;문법&lt;/h2&gt;
&lt;h3 id=&#34;printf&#34;&gt;printf&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;format specifier&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%v&lt;/code&gt;: used as a placeholder for the default format representation of a value&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%+v&lt;/code&gt;: a detailed representation of the value, including all the fields and their corresponding values for structs and maps.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Tensorflow</title>
      <link>https://aswinblue.github.io/Blog/post/machinelearning/tensorflow/</link>
      <pubDate>Sat, 27 Nov 2021 08:15:42 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/machinelearning/tensorflow/</guid>
      <description>&lt;p&gt;#Tensorflow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TensorFlow는 구글에서 수치연산을 위해 만든 라이브러리이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본-개념&#34;&gt;기본 개념&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;node와 edge로 구성된 graph를 이용해 수치 연산을 수행한다.
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;node들은 특정한 데이터가 들어오면 연산을 수행하거나, 형태를 변경하거나, 결과를 출력하는 역할을 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge는 학습데이터가 저장되는 다차원 배열이다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge는 node에서 계산된 데이터를 다음 node로 이동시킨다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;edge는 방향성이 있으며(directed), tensor라 불린다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;&#34;&gt;archive.ics.uci.edu/ml&lt;/a&gt; 에서 학습용 데이터를 받아 사용할 수 있다.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;python과 pip를 설치한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip install tensorflow&lt;/code&gt; 명령을 수행한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;window에서 &amp;lsquo;client_load_reporting_filter.h&amp;rsquo; 파일을 찾지 못해 설치를 못했다면, path 경로가 너무 길어서 발생하는 오류이다.&lt;/li&gt;
&lt;li&gt;실행에서 &lt;code&gt;regedit&lt;/code&gt;을 실행하고, &amp;lsquo;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\FileSystem&amp;rsquo; 레지스트리를 찾아 값을 1로 세팅해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;연관-모듈&#34;&gt;연관 모듈&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;함께 쓰면 효율이 좋은 모듈들&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;matplotlib&lt;/li&gt;
&lt;li&gt;numpy&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;data = np.loadtxt(FILE_NAME, delimiter=&#39;,&#39;)&lt;/code&gt; : ,를 기준으로 데이터를 나누는 csv 파일을 읽어들임. 숫자 데이터를 읽을 때 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;keras (tensorflow 설치시 자동성치된다)
&lt;code&gt;y_encoded = to_categorical(y_data)&lt;/code&gt; : y_data 를 one-hot-encoding 하는 함수  (tensorflow.keras.utils.to_categorical)&lt;/li&gt;
&lt;li&gt;pandas&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df = pd.read_csv(FILE_NAME)&lt;/code&gt; : csv 파일을 읽어서 dataframe을 구성한다. 숫자 및 문자열 데이터를 읽을 때 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;sklearn&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;데이터 전처리&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;e = sklearn.preprocessing.LabelEncoder()
e.fit(data)  # data 에 들어있는 값 중 unique한 값을 뽑아(중복 제거) 특정 string에 번호를 매기는(indexing) 함수
data = e.transform(data)  # indexing 된 정보를 바탕으로 실제 data값을 index로 치환
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;기본-문법&#34;&gt;기본 문법&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;상수 선언&lt;br&gt;
&lt;code&gt;val = tf.constant(value, dtype=None, shape=None, name=&#39;Conts&#39;, verify_shape=False)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;value = 값&lt;/li&gt;
&lt;li&gt;dtype : 데이터 타입, ex) &amp;rsquo;tf.float32&amp;rsquo;, &amp;rsquo;tf.float64&amp;rsquo;, &amp;rsquo;tf.int8&amp;rsquo;
&lt;ul&gt;
&lt;li&gt;float(32, 64), int(8, 16, 64),uint(8, 16), string, bool, complex(64, 128 : 복소수)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;shape : 차원, value 형태에 따라 자동으로 설정 됨, ex) &amp;lsquo;[3,3]&amp;rsquo;&lt;/li&gt;
&lt;li&gt;name : 상수의 이름&lt;/li&gt;
&lt;li&gt;verify_shape : tensor의 shape를 바꿀수 있는지 여부&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;배열 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr = tf.range(5)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;output : &lt;code&gt;tf.Tensor : shape(5,), dtype=int32, numpy=([0, 1, 2, 3, 4], dtype=int32)&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kivy</title>
      <link>https://aswinblue.github.io/Blog/post/windowapp/kivy/</link>
      <pubDate>Thu, 09 Sep 2021 18:43:28 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/windowapp/kivy/</guid>
      <description>&lt;p&gt;#kivy&lt;/p&gt;
&lt;h2 id=&#34;basic-concepts&#34;&gt;Basic concepts&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Widget&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;어플리케이션을 구성하는 객체&lt;/li&gt;
&lt;li&gt;widget은 다른 widget을 tree형태로 포함 가능하며 버튼, 라벨 등상호작용 가능한 객체 또는 Widget의 집합&lt;/li&gt;
&lt;li&gt;위치는 좌표로 표현되는데 좌표는 좌측하단이 (0,0)이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Layout&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;화면 구성을 설정한 요소&lt;/li&gt;
&lt;li&gt;widget 혹은 layout을 포함 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;structure&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;main.py에 python으로 내용을 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class TheLabApp(App):
pass
TheLabApp().run()
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;main.py에서 선언한 class &amp;lsquo;TheLabApp&amp;rsquo; 에서 App을 뺀 TheLab을 따서 main.py와 같은 경로에 &amp;lsquo;TheLab.kv&amp;rsquo;파일을 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;/
|-main.py
|-TheLab.kv
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;.py파일에서 원하는 layout class를 상속받아 객체를 구성할 수도 있고, .kv파일에서 바로 작성할 수도 있다.&lt;/li&gt;
&lt;li&gt;단, .kv파일에서 객체를 생성하려면 .py파일에 정의된 class를 사용해야 한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;EXAMPLE@BoxLayout&amp;gt;&lt;/code&gt; 와 같이 .py파일의 class 선언을 생략하고 default 객체를 사용하는 방법도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;///////// .py /////////
class Box(BoxLayout):
  pass
///////// .kv /////////
&amp;lt;Box&amp;gt;: # .py에서 정의된 Box객체를 사용 가능
  GridLayout:  # 이후부터는 kivy에서 제공하는 객체들 사용 가능
    label:
      text:&amp;#34;lb&amp;#34;

&amp;lt;Box2@BoxLayout&amp;gt;: # .py파일에서 아무것도 하지 않는 객체를 선언하기 싫을 때 사용
///////////////////////
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;ex) class 안에서 속성 설정 :&lt;code&gt;self.orientation = &amp;quot;vertical&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ex) kv파일에서 속성 설정 : &lt;code&gt;orientation: &amp;quot;vertical&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;NAME&amp;gt;&lt;/code&gt;형태로 선언한 객체는 다른 객체에서 사용할수 있게 된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;Box&amp;gt;:
  ...
&amp;lt;Box2&amp;gt;:
  Button:
    ...
  Box:  # 사용자 정의 객체
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;.kv파일은 아래와 같이 구성된다.&lt;/li&gt;
&lt;li&gt;화면을 구성하는 내용들의 속성을 정의하고 배치할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;MainWidget:         # 화면에 표기할 객체(widget, layout, &amp;hellip;)
&lt;MainWidget&gt;:       # widget 정의
Button:           # widget 내부 항목 선언, kivy에서 지원하는 객체의 종류
text:&amp;ldquo;A&amp;rdquo;
Button:
text:&amp;ldquo;B&amp;rdquo;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 기초</title>
      <link>https://aswinblue.github.io/Blog/post/python/python_basic/</link>
      <pubDate>Wed, 01 Sep 2021 18:49:18 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/python/python_basic/</guid>
      <description>&lt;h1 id=&#34;python&#34;&gt;Python&lt;/h1&gt;
&lt;h2 id=&#34;기본-내장-함수&#34;&gt;기본 내장 함수&lt;/h2&gt;
&lt;h3 id=&#34;입력&#34;&gt;입력&lt;/h3&gt;
&lt;p&gt;한줄 받기 : &lt;code&gt;a = input()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;받은 값은 string 형태이다.&lt;br&gt;
받은 단어 끊어서 해석 : &lt;code&gt;a, b = input().split()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;split() 함수 안의 인자에 따라 구분자 설정 가능. 빈칸이면 공백을 기준으로 끊어줌&lt;br&gt;
받은 단어 끊고 숫자로 변환 : &lt;code&gt;a, b = map(int, input().split())&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;int 외 다른 형태도 사용 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;출력&#34;&gt;출력&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;print()&lt;/code&gt; 와 &lt;code&gt;sys.stdout.write()&lt;/code&gt; 로 화면에 출력할 수 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;sys.stdout.write&lt;/code&gt; 안에는 string 형태만 적용할 수 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print&lt;/code&gt; 안에는 수식 등으로 string 및 byte를 표현 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sys.stdout.buffer.write()&lt;/code&gt; 를 사용하면 문자열을 수식을 통해 조합하고 ascii 코드 형태로 출력 가능하다.
&lt;ul&gt;
&lt;li&gt;print() 를 사용하면 prefix가 붙어서 원하는 형태를 표현하기 어렵다. 이럴 때 sys.stdout.buffer.write()를 사용한다.&lt;/li&gt;
&lt;li&gt;ex)
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  sys.stdout.write(b&amp;#39;A&amp;#39;*0x10 + b&amp;#39;B&amp;#39;*0x20 + b&amp;#39;\xaa\
  xbb\xcc\xdd\x00\x00\x00\x00&amp;#39;)
  # 결과: AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB����
  sys.stdout.write(b&amp;#39;A&amp;#39;*0x10 + b&amp;#39;B&amp;#39;*0x20 + b&amp;#39;\xaa\
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;xbb\xcc\xdd\x00\x00\x00\x00&amp;rsquo;)
# 결과: b&amp;rsquo;AAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\xaa\xbb\xcc\xdd\x00\x00\x00\x00&amp;rsquo;
```&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Angular</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/angular/</link>
      <pubDate>Mon, 23 Aug 2021 19:46:09 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/angular/</guid>
      <description>&lt;h1 id=&#34;angular&#34;&gt;Angular&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Angular JS와 Angular는 다르다. Angular JS는 초창기 Angular를 의미하고, 그냥 Angular는 Angular2 이상의 버전을 의미한다.&lt;/li&gt;
&lt;li&gt;javascript기반의 textscript를 사용한다. 확장자가 ts로 끝난다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;개발환경-세팅&#34;&gt;개발환경 세팅&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;nodejs 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ sudo apt install npm&lt;/code&gt; :nodejs와 npm 동시에 설치&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;angular client 설치&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ npm install -g @angular/cli&lt;/code&gt; 명령어를 이용하여 설치&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;workspace 생성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;client 설치가 완료되었으면 workspace를 생성하고 application을 생성한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;$ ng new &amp;lt;application_name&amp;gt;&lt;/code&gt; 명령어를 이용하여 설치한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nodejs 버전이 낮다고 한다.  github에서 받아서 빌드하여 써 보자.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring basic</title>
      <link>https://aswinblue.github.io/Blog/post/webserver/spring/</link>
      <pubDate>Mon, 23 Aug 2021 19:21:55 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webserver/spring/</guid>
      <description>&lt;h1 id=&#34;spring-basic&#34;&gt;Spring basic&lt;/h1&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;spring CLI를 설치한다. 직접 다운받아서 원하는 곳에 압축을 푼 후 PATH설정을 해 주는게 빠르다.&lt;br&gt;
&lt;a href=&#34;https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started.html#getting-started-installing-the-cli&#34;&gt;참조&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;프로젝트-생성&#34;&gt;프로젝트 생성&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CLI로 프로젝트를 생성해 보자.
&lt;code&gt;spring init --build=gradle -d=web -a=myApp -g=com.aswin.blue [location]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--build=gradle&lt;/code&gt; 기본으로 maven을 사용하지만 gradle로 설정 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d=web&lt;/code&gt; dependency를 web으로 설정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a=myApp&lt;/code&gt; artifactId, 즉 project명을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g=com.aswin.blue&lt;/code&gt; 그룹 명을 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[location]&lt;/code&gt; 생성할 폴더를 지정한다. 없으면 새로 생성한다. 지정하지 않으면 zip 형태로 압축해서 생성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설정&#34;&gt;설정&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;maven으로 프로젝트를 생성하면 pom.xml을 설정해야 한다.&lt;/li&gt;
&lt;li&gt;각종 라이브러리를 플러그인 형태로 사용하려면 dependency와 repository 설정을해 줘야 한다.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;&lt;a href=&#34;https://mvnrepository.com/%22&#34;&gt;https://mvnrepository.com/&#34;&lt;/a&gt; 주소처럼 maven repository를 정리해 놓은 사이트에서 원하는 repository를 찾아서 dependency를 작성한다.&lt;/li&gt;
&lt;li&gt;repository 추가시 compile dependency를 확인하고 추가로 pom.xml을 작성한다.&lt;/li&gt;
&lt;li&gt;maven 사이트보다는 github의 readme를 더 신용하자, maven 사이트 업데이트가 안돼서 잘 동작하지 않는 것도 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;실행&#34;&gt;실행&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;maven 프로젝트의 실행에도 maven이 사용된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvn -X clean install exec:java -Dexec.args=&amp;quot;&amp;quot;&lt;/code&gt; 로 실행이 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;-X&lt;/code&gt; 는 디버깅 로그 출력을 의미한다.
&lt;code&gt;-Dexec.args=&lt;/code&gt; 는 main 함수의 argv를 설정한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jython</title>
      <link>https://aswinblue.github.io/Blog/post/java/jython/</link>
      <pubDate>Mon, 23 Aug 2021 19:20:47 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/java/jython/</guid>
      <description>&lt;h1 id=&#34;jython&#34;&gt;Jython&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Java 환경에서 python을 실행하게 하는 방법 중 하나&lt;/li&gt;
&lt;li&gt;역으로 Jython 환경에서 java를 실행 가능하기도 하다.&lt;/li&gt;
&lt;li&gt;spring에서 jython을 사용하는 방법에 대해 묘사하겠다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;설치&#34;&gt;설치&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;pom.xml에 의존성을 작성한다.&lt;/li&gt;
&lt;li&gt;pom을 사용하면 jython을 설치하지 않고 일부 동작이 실행되게 할 수 있지만, 외부 모듈 사용에는 제한적인 부분이 있기에 설치가 필요하면 설치를 해야한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.python/jython --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.python&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jython&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.7.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;실행&#34;&gt;실행&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PythonInterpreter 을 선언한다.&lt;/li&gt;
&lt;li&gt;이후 execfile, exec 함수를 이용하여 python 문법을 사용 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;PythonInterpreter jython;
jython.execfile(PYTHON);
jython.exec(&amp;#34;print(1+1)&amp;#34;);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;execfile로 특정 함수를 정의하였다면 그 아래에 있는 exec함수에서 함수를 호출할 수도 있다.&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Web_scrapping</title>
      <link>https://aswinblue.github.io/Blog/post/developtips/web_scrapping/</link>
      <pubDate>Mon, 23 Aug 2021 19:00:44 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/developtips/web_scrapping/</guid>
      <description>&lt;h1 id=&#34;web-scrapping&#34;&gt;Web Scrapping&lt;/h1&gt;
&lt;h2 id=&#34;x-path&#34;&gt;x-path&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/a/b/c/d/e/f/g/...&lt;/code&gt; 와 같이 특정 경로를 가진 개체를 가리키는 방법이다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//*[@id=&amp;quot;abcd&amp;quot;]&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;// 는 모든 경로에서 찾겠다는 의미&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;는 모든 태그에 대해 찾겠다는 의미. *대신 TAG를 넣으면 &amp;lsquo;TAG&amp;rsquo; 라는 이름의 태그를 가진 항목에서만 검색함&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;@id=&amp;ldquo;abcd&amp;rdquo; 는 id라는 속성이 abcd 인 항목을 찾겠다는 의미&lt;/li&gt;
&lt;li&gt;브라우저에서 자동으로 해줒기 때문에 보통은 걱정할 필요가 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;정규식&#34;&gt;정규식&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;. : 하나의 문자&lt;/li&gt;
&lt;li&gt;^ : 문자열의 시작&lt;/li&gt;
&lt;li&gt;$ : 문자열의 끝&lt;/li&gt;
&lt;li&gt;* : 모든 문자&lt;/li&gt;
&lt;li&gt;# : 하나의 숫자&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.w3schools.com/python/python_regex.asp&#34;&gt;정규식 참조 link&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>GDB</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/gdb/</link>
      <pubDate>Mon, 23 Aug 2021 18:49:15 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/gdb/</guid>
      <description>&lt;h1 id=&#34;gdb&#34;&gt;GDB&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;GNU Debugger의 약자&lt;/li&gt;
&lt;li&gt;유닉스의 디버거는 오픈소스가 아니라 GNU에서 새로 개발한 디버거&lt;/li&gt;
&lt;li&gt;디버깅을 위해서는 register(레지스터 값), disassem(rip 부근 주소를 디스어셈 한 값), stack(스택의 값), backtrace(현재 rip에 도달 할 때 까지 거쳐간 함수들) 을 파악해야 하며, 이를 context(맥락) 이라 한다.&lt;/li&gt;
&lt;li&gt;pwndbg 플러그인을 설치하면 hacking에 관련된 내용을 디버깅하기 용이하다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;https://github.com/pwndbg/pwndbg&lt;/code&gt; 주소에서 git을 clone 받고, ./setup.sh를 실행시키면 이후 &lt;code&gt;gdb&lt;/code&gt; 명령을 칠 때 자동으로 pwndbg 플러그인이 적용된 gdb가 실행된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;컴파일&#34;&gt;컴파일&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gcc로 컴파일시 옵션에 &lt;code&gt;-g&lt;/code&gt; 를 붙여야 소스를 보면서 디버깅이 가능&lt;/li&gt;
&lt;li&gt;리눅스에서 컴파일한 파일은 ELF (Executable and Linkable Format) 의 실행 파일이 된다.
&lt;ul&gt;
&lt;li&gt;ELF 파일은 파일 실행에 필요한 정보가 든 헤더와 여러 섹션들로 구성된다.&lt;/li&gt;
&lt;li&gt;섹션에는 기계어 코드 등의 정보들이 들어있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;readelf -h [ELF파일]&lt;/code&gt; 명령으로 ELF 파일의 헤더 정보를 확인 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gdb-옵션&#34;&gt;gdb 옵션&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gdb [파일이름]&lt;/code&gt; : 해당 파일이름 디버깅 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--args [arg1] [arg2] [...]&lt;/code&gt; : 파일 실행에 필요한 argument를 전달&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기타-명령어&#34;&gt;기타 명령어&lt;/h2&gt;
&lt;h3 id=&#34;실행-전-설정사항&#34;&gt;실행 전 설정사항&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;coredumb 파일&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>React basic</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/react_basic/</link>
      <pubDate>Mon, 23 Aug 2021 18:46:22 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/react_basic/</guid>
      <description>&lt;h1 id=&#34;react-basic&#34;&gt;React basic&lt;/h1&gt;
&lt;h2 id=&#34;개발환경-설치-및-실행&#34;&gt;개발환경 설치 및 실행&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;node.js 로 만들어진 create-react-app 툴을 이용하면 손쉽게 react 앱을 생성할 수 있다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;npm을 설치하고 아래 명령어를 수행하여 create-react-app을 설치한다.
&lt;code&gt;npm install -g create-react-app&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;원하는 경로에 들어가 프로젝트를 생성한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;create-react-app &amp;lt;NAME&amp;gt;&lt;/code&gt; : NAME 경로에 프로젝트 생성&lt;/li&gt;
&lt;li&gt;주의 : 프로젝트가 생성되는 폴더명은 대문자를 사용할 수 없다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;실행&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm run start&lt;/code&gt; 를 수행하면 &lt;code&gt;localhost:3000&lt;/code&gt;에서 웹페이지를 퍼블리싱한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;기본-설정&#34;&gt;기본 설정&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;실행 포트&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt; 파일에서 &lt;code&gt;&amp;quot;proxy&amp;quot;: &amp;quot;http://localhost:3000/&amp;quot;&lt;/code&gt; 과 같이 입력하면 실행시 포트를 3000으로 설정할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;기본-구조&#34;&gt;기본 구조&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;/public/index.html 에서 기본 화면 구성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lsquo;root&amp;rsquo; 이름으로 된 division이 있는데, 이 division에 대한 설정은 javascript로 정의되어있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;src 경로에 javascript파일들 구성&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&amp;lsquo;index.js&amp;rsquo; 에 메인 화면에 사용된 객체가 정의되어 있다. 아래 내용은 id가 &amp;lsquo;root&amp;rsquo; 인 division에 &amp;lsquo;App&amp;rsquo;을 적용하겠다는 의미이다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; basic</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/c&#43;&#43;/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/c&#43;&#43;/</guid>
      <description>&lt;h1 id=&#34;c-basics&#34;&gt;C++ basics&lt;/h1&gt;
&lt;h2 id=&#34;매크로&#34;&gt;매크로&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#define MACRO 1&lt;/code&gt; : MACRO 값으로 1을 지정&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#undef MACRO&lt;/code&gt; : MACRO값에 지정된 내용 해제&lt;/li&gt;
&lt;li&gt;여러줄의 매크로 값 지정 :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define PRINT(X) printf(&amp;#34;%d&amp;#34;, X);\
  printf(&amp;#34;%d&amp;#34;, (X) + 1);\
  printf(&amp;#34;%d&amp;#34;, (X) + 2);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;매크로 합성 :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define A 1
#define B 1
#define C A##B // A##B = 12
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;함수형태 매크로 작성 :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 일반함수에는 &amp;#39;;&amp;#39; 를 붙이지만 매크로 함수에는 &amp;#39;;&amp;#39;를 붙일 필요가 없다.
// 일관성을 갖기 위해 do-while문 안에 작성하면 매크로 함수에도 &amp;#39;;&amp;#39;를 붙이도록 할 수 있다.
#define FUNC(a, b) do { \
    a = b * 2;\
} while (0)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;연산자 우선순 :&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 매크로 함수는 계산 전 치환을 먼저 수행한다. 연산자 우선순위에 주의한다.
#define ADD1(a,b) a+b
#define ADD2(a,b) (a+b)
#define MULT(a,b) a*b
#define MULT2(a,b) (a)*(b)
...
printf(&amp;#34;%d&amp;#34;,ADD1(3,4) * 2) // 예상값 (3 + 4) * 2 = 14
// 3 + 4 * 2 로 치환하여 계산되어 실제 결과는 11
// ADD2 처럼 계산 결과를 괄호로 묶어야 안전하다.

printf(&amp;#34;%d&amp;#34;,MULT(2+2,3+3)) // 예상값 (4 * 6) * 2 = 26
// (2 + 2 * 3 + 3) 로 치환하여 계산되어 실제 결과는 11
// MULT2 처럼 각 변수를 괄호로 묶어야 안전하다.

// ADD1, MULT2 경우를 종합하여 아래와 같이 사용하자
#define ADD3(a,b) ((a) + (b))
#define MULT3(a,b) ((a) * (b))
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;조건부 컴파일
&lt;ul&gt;
&lt;li&gt;if-elif-else 사용 가능&lt;/li&gt;
&lt;li&gt;조건에 !, &amp;amp;&amp;amp; || 논리연산 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#define MACRO
#define DEBUG 1

#ifdef MACRO // 정의가 되어있으면 수행
#endif

#if DEBUG // DEBUG가 나타내는 값 또는 식이 참이면 수행
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;파일 포함&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;FILE_NAME&amp;gt; // 표준라이브러리에서 파일 참조
#include &amp;#34;FILE_NAME&amp;#34; // 현재 경로 기준 파일 참조
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;→ [&lt;em&gt;활용&lt;/em&gt;]: 헤더파일 중복 참조 방지법&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CMake</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/cmake/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/cmake/</guid>
      <description>&lt;h1 id=&#34;cmake&#34;&gt;CMake&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Cmake란 : C,C++ 언어 컴파일시 make 툴을 이용할 때, 규모가 큰 프로젝트에서 컴파일 의존성 관리를 쉽게 하기 위한 도구&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;명령어&#34;&gt;명령어&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cmake CMakeList.txt&lt;/code&gt; : CMakeList.txt파일 안의 내용을 수행한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cmake .&lt;/code&gt; : 파일 경로를 입력하면 해당 경로에서 CMakeList.txt파일을 찾아서 수행.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; : cmake를 이용해 생성한 파일들을 이용해 make로 컴파일&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cmake 명령 후 make를 이용해 컴파일을 수행하면 부산물들이 많이 생성된다. 이를 방지하기 위해 보통 새로운 폴더를 만들어 넣어서 사용한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. mkdir build
2. vi CMakeList.txt 후 내용 작성
3. cd build
4. cmake ..
5. make
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;CmakeLists.txt 작성은 쉘 프로그래밍과 유사하다. cmake 문법을 사용하여 작성해 주면 된다. 미리 지정된 변수들도 있는데, 해당 변수들에 주의하며 작성한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문법&#34;&gt;문법&lt;/h2&gt;
&lt;h3 id=&#34;빌드-설정&#34;&gt;빌드 설정&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ADD_EXECUTABLE&lt;/code&gt; : 실행파일 생성
ex) &lt;code&gt;ADD_EXECUTABLE(main.exe main.cpp function.cpp)&lt;/code&gt; : main.cpp와 function.cpp를 사용해 main.exe를 생성한다. 헤더 파일은 자동으로 적용된다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Docker</title>
      <link>https://aswinblue.github.io/Blog/post/ci_cd/docker/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/ci_cd/docker/</guid>
      <description>&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;리눅스 커널의 cgroups와 namespace에 의해 제공되는 기술&lt;/li&gt;
&lt;li&gt;가상화 기능의 일종으로, 별도의 OS를 갖지 않아 VM(Virtual Machine) 보다 가볍다.&lt;/li&gt;
&lt;li&gt;게스트는 호스트 OS와 자원을 공유한다.&lt;/li&gt;
&lt;li&gt;immutable infrastructure : 서비스 운영 환경을 통째로 이미지화 하여 배포하는 형태&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;startup&#34;&gt;Startup&lt;/h2&gt;
&lt;h3 id=&#34;설치&#34;&gt;설치&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository&#34;&gt;링크 참조&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;docker api 리눅스 설치 : &lt;code&gt;sudo apt-get install docker&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행&#34;&gt;실행&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;DockerFile&lt;/code&gt; 이름의 파일을 생성하고 내용을 채워넣는다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.docker.com/engine/reference/builder/&#34;&gt;공식 가이드&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;python 서버 실행 예시&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# python:3.10의 이미지로 부터
FROM python:3.9
# 제작자 및 author 기입
LABEL maintainer=&amp;#34;huisam@naver.com&amp;#34;

# 해당 디렉토리에 있는 모든 하위항목들을 &amp;#39;/app/server`로 복사한다
COPY . /app/server

# image의 directory로 이동하고
WORKDIR /app/server

# 필요한 의존성 file들 설치
RUN pip3 install -r requirements.txt

# 환경 설정 세팅
RUN python setup.py install

# container가 구동되면 실행
ENTRYPOINT [&amp;#34;python&amp;#34;, &amp;#34;Server.py&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;리눅스 실행 예시&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Json in C&#43;&#43;</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/json_c&#43;&#43;/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/json_c&#43;&#43;/</guid>
      <description>&lt;h1 id=&#34;json-library-in-c&#34;&gt;Json library in C++&lt;/h1&gt;
&lt;h2 id=&#34;rapid-json&#34;&gt;Rapid Json&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;커뮤니티&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;오픈소스로 다양한 예제코드를 찾을 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;parsing 속도&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;다른 Json 파싱 라이브러리와 비교시 상위권에 위치&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;라이브러리&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;헤더 온리 사용이 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;참조&#34;&gt;참조&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://joycecoder.tistory.com/9&#34;&gt;https://joycecoder.tistory.com/9&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Tencent/rapidjson/&#34;&gt;https://github.com/Tencent/rapidjson/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Linux commands</title>
      <link>https://aswinblue.github.io/Blog/post/linux/linux_command/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/linux_command/</guid>
      <description>&lt;h1 id=&#34;linux-command&#34;&gt;Linux Command&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;리눅스에서 사용되는 명령어들을 정리한다.&lt;/li&gt;
&lt;li&gt;자주 사용되는 모듈의 명령어도 포함한다.&lt;/li&gt;
&lt;li&gt;리눅스에서 명령어는 &lt;code&gt;/usr/bin/&lt;/code&gt; 폴더에 저장되며, 내부에 저장된 파일들은 각 유저들에게 실행권한이 있다.&lt;/li&gt;
&lt;li&gt;유저 개인의 명령어를 따로 설정 및 관리하려면 &lt;code&gt;~/.bashrc&lt;/code&gt; 파일에서 특정 디리렉터리를 PATH에 추가하여 사용할 수 있다.
&lt;ul&gt;
&lt;li&gt;기본적으로 &lt;code&gt;~/bin/&lt;/code&gt; 경로가 PATH에 추가되어 있다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;export PATH=$PATH:추가할경로[:추가할경로2:추가할경로3:...]&lt;/code&gt; 명령어를 &lt;code&gt;~/.bashrc&lt;/code&gt; 에 추가하면 경로를 추가할 수 있다.
&lt;ul&gt;
&lt;li&gt;ex)
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# in .bashrc file
PATH=$PATH:/home/user/bashrc  # 기존의 PATH에 /home/user/.bashrc 추가
# 현재 PATH는 .bashrc 포함
PATH=$PATH:/home/user/dir1:/home/user/dir2  # 기존의 PATH에 dir1, dir2 추가
# 현재 PATH는 .bashrc, dir1, dir2 포함

export PATH  # PATH를 적용
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;적용 후 &lt;code&gt;source ~/.bashrc&lt;/code&gt; 명령어로 .bashrc를 재적용 해 주면 설정이 완료된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;리눅스 쉘에서 위 쉘코드를 바로 입력해도 적용은 가능하지만, 이 경우 재부팅시 설정이 초기화된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;리눅스-기본&#34;&gt;리눅스 기본&lt;/h2&gt;
&lt;h3 id=&#34;리눅스-설정-관련&#34;&gt;리눅스 설정 관련&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stty -a&lt;/code&gt;: 시그널 단축키들의 값 확인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strace FILE_NAME&lt;/code&gt;: 실행파일이 실행되는 상세 과정을 라인별로 보여준다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getconf&lt;/code&gt;  리눅스의 시스템 변수 값을 확인하는 명령어
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getconf -a&lt;/code&gt;: 모든 시스템 변수를 반환한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getconf LONG_BIT&lt;/code&gt;: 시스템이 x64라면 64를, x86이라면 32를 반환한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldd FILE_NAME&lt;/code&gt; : FILE_NAME 을 실행하는데 필요한 라이브러리 의존성을 확인한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;파일-시스템-조작&#34;&gt;파일 시스템 조작&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir&lt;/code&gt; : 디렉터리를 생성하는 명령여
&lt;ul&gt;
&lt;li&gt;parent 디렉터리가 존재하지 않는다면 &lt;code&gt;mkdir -p&lt;/code&gt; 명령어로 한 번에 생성 가능 (ex: &lt;code&gt;mkdir -R A/B/C/D&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;문자열-조작&#34;&gt;문자열 조작&lt;/h2&gt;
&lt;h3 id=&#34;sed&#34;&gt;sed&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;기본적인 기능은 ed에서 따 왔으며, 이 기능들은 모두 sed에 적용이 된다.&lt;/li&gt;
&lt;li&gt;ed는 대화형 편집기이며, sed는 스트리밍 편집기&lt;/li&gt;
&lt;li&gt;\n 을 개행문자로 사용하는 스트리밍 에디터&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;sed [-e script][-f script-file][file...]&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>spdlog C&#43;&#43;</title>
      <link>https://aswinblue.github.io/Blog/post/c&#43;&#43;/log_c&#43;&#43;/</link>
      <pubDate>Thu, 12 Aug 2021 10:41:00 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/c&#43;&#43;/log_c&#43;&#43;/</guid>
      <description>&lt;h1 id=&#34;spdlog&#34;&gt;spdlog&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;C++ 프로젝트에서 로그를 세팅할 수 있는 라이브러리&lt;/li&gt;
&lt;li&gt;fast, header only, no dependency, .. 등 장점&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;참조&#34;&gt;참조&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://isocpp.org/blog/2014/11/spdlog&#34;&gt;https://isocpp.org/blog/2014/11/spdlog&lt;/a&gt;
&lt;a href=&#34;https://github.com/gabime/spdlog&#34;&gt;https://github.com/gabime/spdlog&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nodejs</title>
      <link>https://aswinblue.github.io/Blog/post/webserver/nodejs/</link>
      <pubDate>Mon, 20 Jul 2020 20:40:05 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webserver/nodejs/</guid>
      <description>&lt;h1 id=&#34;nodejs&#34;&gt;Node.js&lt;/h1&gt;
&lt;h2 id=&#34;기본-명령&#34;&gt;기본 명령&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm init&lt;/code&gt; : 패키지 생성&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt; : 라이브러리 설치
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; : package.json에 저장, 기본옵션&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-O&lt;/code&gt; : optionalDependencies에 저장&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-D&lt;/code&gt;, &lt;code&gt;--no-save&lt;/code&gt; : 기록없이 다운로드&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-g&lt;/code&gt; : 글로벌 설치, 모든 프로젝트에 적용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MODULE_NAME@VERSION&lt;/code&gt; : 버전 설정, latest는 가장 최근 버전을 의미&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node main.js&lt;/code&gt; : 실행(main.js)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npx &amp;lt;package_name&amp;gt;&lt;/code&gt; : 설치하지 않고 일회만 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node main.js&lt;/code&gt; : 패키지 실행 (main.js파일)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm audit&lt;/code&gt; : 의존성 문제가 발생했을 때,
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm audit fix&lt;/code&gt; : 의존성 문제를 자동으로 해결하는 명령어, 일부 해결을 할 수는 있지만 package.json 파일을 수정할 수 있으므로 주의. &amp;ndash;fix 옵션을 넣어서 강제로 수정할 수도 있지만, 오히려 되던 기능이 안 될 수도 있으므로 추천하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm cache clean&lt;/code&gt; : 캐싱된 데이터를 정리할 수 있다. &amp;ndash;force 옵션을 넣어 강제로 처리 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;구조&#34;&gt;구조&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main.js&lt;/code&gt; : nodejs 실행시 실행할 메인 파일&lt;/li&gt;
&lt;li&gt;&lt;code&gt;package.json&lt;/code&gt; : root 경로에 존재하며, npm 프로젝트를 관리하는 파일&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/node_modules&lt;/code&gt; : 프로젝트에서 사용되는 모듈들이 저장되는 파일이다. npm install 명령 사용시 모듈들이 다운받아지는 경로이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;packagejson&#34;&gt;package.json&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;nodejs 설정을 담고있는 파일로, 참조할 내용이 많아 아래에 따로 정리한다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Mysql</title>
      <link>https://aswinblue.github.io/Blog/post/databases/mysql/</link>
      <pubDate>Thu, 02 Jul 2020 20:29:29 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/databases/mysql/</guid>
      <description>&lt;h1 id=&#34;mysql&#34;&gt;mysql&lt;/h1&gt;
&lt;h2 id=&#34;명령어&#34;&gt;명령어&lt;/h2&gt;
&lt;p&gt;문법 참조 : &lt;a href=&#34;http://tcpschool.com/mysql/mysql_basic_syntax&#34;&gt;http://tcpschool.com/mysql/mysql_basic_syntax&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;명령어에서 대소문자는 상관없다.&lt;/li&gt;
&lt;li&gt;mysql에서 주석은 &lt;code&gt;#&lt;/code&gt;을 사용한다.&lt;/li&gt;
&lt;li&gt;한줄 주속은 &lt;code&gt;--&lt;/code&gt; 을 사용한다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--&lt;/code&gt; 뒤에 공백 없이 바로 문자나 문자가 아닌 문자가 올 경우, SQL 엔진에 따라 주석으로 인식되지 않을 수도 있어서, 일반적으로 &lt;code&gt;-- &lt;/code&gt;(띄어쓰기 포함) 또는 &lt;code&gt;-- -&lt;/code&gt; 같이 공백이나 의미 없는 문자를 추가해서 주석임을 명확히 해준다. 이건 DBMS에 따라 차이가 있지만, 일부 엔진(MySQL 등)은 &lt;code&gt;--&lt;/code&gt; 뒤에 공백이 있어야 주석으로 인식한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;실행-및-로그인&#34;&gt;실행 및 로그인&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;mysql&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;mysql 실행, 기본으로 설정된 user로 로그인됨&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;code&gt;mysql -u 아이디 -p&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-u&lt;/code&gt;: 특정 아이디로 로그인&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt;: 로그인시 비밀번호 입력하도록&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;데이터베이스-관리&#34;&gt;데이터베이스 관리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DB 생성
&lt;ul&gt;
&lt;li&gt;UTF8 로 문자열 저장하기
&lt;code&gt;CREATE DATABASE 데이터베이스_이름 default CHARACTER SET UTF8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DB 목록확인
&lt;code&gt;show databases&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DB 선택
&lt;code&gt;use DB_NAME&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;종료
&lt;code&gt;EXIT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;로그인 &amp;amp; 데이터베이스 선택
&lt;code&gt;$ mysql -p DB_NAME -u USER_NAME&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;사용자 이름과 USER_NAME으로 DB_NAME 데이터베이스 실행&lt;/li&gt;
&lt;li&gt;USER_NAME이 비어있으면 현재 로그인한 계정과 동일한 이름으로 로그인 시도&lt;/li&gt;
&lt;li&gt;-u DB_NAME 옵션은 로그인 후 &lt;code&gt;$use DB_NAME&lt;/code&gt; 과 같은 효과&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;테이블-생성-및-관리-ddl&#34;&gt;테이블 생성 및 관리 (DDL)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TABLE_NAME 테이블의 스키마 확인
&lt;code&gt;desc TABLE_NAME&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PythonCGI</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/pythoncgi/</link>
      <pubDate>Thu, 02 Jul 2020 19:15:21 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/pythoncgi/</guid>
      <description>&lt;h1 id=&#34;python-cgi&#34;&gt;python CGI&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CGI는 Common Gateway Interface의 약자다.&lt;/li&gt;
&lt;li&gt;web application을 만들 수 있는 언어는 ruby, java, php 등 다양하지만 모두 CGI 규약을 따라 web server와 통신한다.&lt;/li&gt;
&lt;li&gt;web server는 사용자의 요청을 받으면 약속된 이름의 데이터를 환경변수로 web application에 전달하여 서로 교류한다.&lt;/li&gt;
&lt;li&gt;apache에서 python을 이용해 web application을 만들어 web server와 통신해 보자.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$ a2enmod CGI&lt;/code&gt; 명령으로 apache의 CGI를 켜 주고, &lt;code&gt;sudo service apache2 restart&lt;/code&gt; 로 설정 적용&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/var/log/apache2/error.log&lt;/code&gt; 안에 apache 실행시 발생한 에러 로그가 담겨있다.&lt;/li&gt;
&lt;li&gt;웹 브라우저가 웹 서버에 요청할 때 웹 서버는 응답으로 웹 페이지의 데이터 타입(헤더)와 함께 웹 페이지를 전송한다.
python CGI로는 &lt;code&gt;print(&amp;quot;content-type:text/html; charset=UTF-8\n&amp;quot;)&lt;/code&gt; 와 같이 헤더를 표기낸다.&lt;/li&gt;
&lt;li&gt;헤더를 출력한 다음 부터는 body 부분이 출력된다.&lt;/li&gt;
&lt;li&gt;특정 주소로 Redirection을 할 때에는 &lt;code&gt;print(&amp;quot;location : index.py?id=title&amp;quot;)&lt;/code&gt;을 이용한다. ( &amp;lsquo;:&amp;rsquo; 이후 부터 &amp;lsquo;&amp;quot;&amp;rsquo; 까지는 원하는대로 작성)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;formatting&#34;&gt;formatting&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;string에서 특정 문자열을 다른 문자로 치환하는 기능
ex) &lt;code&gt;&#39;{} {}&#39;.format(&#39;one&#39;,&#39;tow&#39;)&lt;/code&gt;
ex) &lt;code&gt;&#39;{a} {b}&#39;.format(a=&#39;hello&#39;, b=&#39;world&#39;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;python 파일에서 문자열과 format 함수를 이용하여 동적 html을 구현 가능하다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cgi-모듈&#34;&gt;CGI 모듈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;import cgi&lt;/code&gt; 로 모듈을 로드해 사용한다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;form = cgi.FieldStorage()&lt;/code&gt; form은 jQuery와 같은 역할을 한다.
ex) &lt;code&gt;pageId = form[&#39;id&#39;].value&lt;/code&gt; : page의 id를 가져온다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;html-연동&#34;&gt;HTML 연동&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;input 태그의 name 속성 : input 태그를 특정 이름으로 CGI에 전달함
ex)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JavaScript</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/javascript/</link>
      <pubDate>Tue, 23 Jun 2020 20:38:45 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/javascript/</guid>
      <description>&lt;h1 id=&#34;javascript&#34;&gt;JavaScript&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;기본적으로 HTML 위에서 돌아가는 코드&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;body 태그 안에 &lt;script&gt; &lt;/script&gt; 태그를 넣고 안에 작성&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;document를 호출하고, .으로 함수를 호출한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;querySelector(&amp;rsquo;&amp;rsquo;)로 원하는 element 선택 가능, &amp;lsquo;&amp;lsquo;안의 내용은 css 선택자 문법과 같음&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;querySelectorAll(&amp;rsquo;&amp;rsquo;)로 원하는 속성의 element들을 nodeList(배열과 유사)형태로 선택 가능&lt;/p&gt;
&lt;p&gt;ex ) &lt;code&gt;document.querySelector(&#39;body&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex ) &lt;code&gt;document.querySelector(&#39;#new&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ex ) &lt;code&gt;document.write(&amp;quot;hello world&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;태그 안에 javaScript를 사용하는 속성값으로 사용&lt;/p&gt;
&lt;p&gt;ex ) &lt;code&gt;&amp;lt;input type=&amp;quot;button&amp;quot; value=&amp;quot;hello&amp;quot; onclick=&amp;quot;alert(&#39;hello&#39;)&amp;quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;특정 태그 안에서 자기자신을 호출할 때에는 querySelector를 호출하지 않고 this를 사용하면 된다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Css</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/css/</link>
      <pubDate>Tue, 23 Jun 2020 20:38:05 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/css/</guid>
      <description>&lt;h1 id=&#34;css&#34;&gt;CSS&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;특정 개체에 효과를 부과한다. 이를 declaration 이라 칭한다.&lt;/li&gt;
&lt;li&gt;중복의 제거 가능, 유지보수 수월, 가독성 증가&lt;/li&gt;
&lt;li&gt;위에서 부터 아래로 읽어가며 효과 적용, 중복 불가능한 효과에 대해서는 이전 효과가 사라짐&lt;/li&gt;
&lt;li&gt;tag 선택자 &amp;lt; calss 선택자 &amp;lt; id 선택자 로 우선 순위가 높다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;html 문서 안에 &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; 태그 안에 작성 가능&lt;/p&gt;
&lt;p&gt;ex ) &lt;code&gt;&amp;lt;style&amp;gt; a { color:black; } &amp;lt;/style&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;태그의 종류별로 속성 설정 가능&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;여기서 태그 a 는 선택자(selector)라고 한다.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;선택자는 ,로 구별하여 함께 사용 가능&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTML</title>
      <link>https://aswinblue.github.io/Blog/post/webapplication/html/</link>
      <pubDate>Tue, 23 Jun 2020 19:13:17 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/webapplication/html/</guid>
      <description>&lt;h1 id=&#34;html&#34;&gt;HTML&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;W3C에서 HTML 규칙을 규정, 웹 브라우저 제작사들이 이를 참조하여 브라우저를 만든다.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;태그&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;element라고 칭하기도 한다.&lt;/li&gt;
&lt;li&gt;부모 자식 관계가 존재&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;TAG_NAME&amp;gt;&lt;/code&gt; 로 시작하고 &lt;code&gt;&amp;lt;/TAG_NAME&amp;gt;&lt;/code&gt;로 끝냄&lt;/li&gt;
&lt;li&gt;태그별로 검색 엔진에서 노출되는 중요도가 다르다.&lt;/li&gt;
&lt;li&gt;태그의 종류에 따라 줄 전체를 사용하거나(block level element), 내용의 크기 만큼의 공간만 사용하는 태그(lnline element)들이 있다.&lt;/li&gt;
&lt;li&gt;html : body와 head를 통틀어 묶은 최 고위 태그&lt;/li&gt;
&lt;li&gt;관용적으로 &amp;lt;!doctype html&amp;gt; 을 붙여 쓴다.&lt;/li&gt;
&lt;li&gt;body : 본문을 묶는 태그&lt;/li&gt;
&lt;li&gt;head : 본문을 설명하는 태그&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;속성(attribute)
&amp;lt;TAG_NAME ATTRIBUTE&amp;gt; 와 같은 형태로 태그 이름 뒤에 붙음&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;body&#34;&gt;body&lt;/h2&gt;
&lt;h3 id=&#34;속성&#34;&gt;속성&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;strong : 굵은 글씨&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Linux_apt</title>
      <link>https://aswinblue.github.io/Blog/post/linux/linux_apt/</link>
      <pubDate>Mon, 25 May 2020 18:30:15 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/linux/linux_apt/</guid>
      <description>&lt;p&gt;Linux 서버에 개발 환경을 세팅하는데 뭔가 제대로 되지 않아 이미 환경설정을 해 본 다른 사람에게 원격으로 도움을 요청했다.&lt;/p&gt;
&lt;p&gt;하지만 그 사람이 리눅스에 익숙하지 않았는지, 우리 서버를 잘못 만져 apt가 먹통이 되는 현상이 발생했다.&lt;/p&gt;
&lt;p&gt;본 해프닝에 대해 서술하자면 아래와 같다.&lt;/p&gt;
&lt;h2 id=&#34;원인&#34;&gt;원인&lt;/h2&gt;
&lt;p&gt;/bin 디렉터리 안의 python bin파일을 강제로 삭제한 것이 원인으로 추정된다.&lt;/p&gt;
&lt;p&gt;환경 설정을 하는데 제대로 되지 않으니 sudo apt-get upgrade 명령도 남용하기도 했다.&lt;/p&gt;
&lt;h2 id=&#34;현상&#34;&gt;현상&lt;/h2&gt;
&lt;p&gt;apt를 이용해 install, remove를 하려 하면 py3compile, py3clean 등에서 오류가 발생하였다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Hugo 환경세팅</title>
      <link>https://aswinblue.github.io/Blog/post/hugo/hugo_dev/</link>
      <pubDate>Sun, 10 May 2020 12:23:13 +0900</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/hugo/hugo_dev/</guid>
      <description>&lt;h1 id=&#34;hugo를-이용해-블로그-만들기&#34;&gt;Hugo를 이용해 블로그 만들기&lt;/h1&gt;
&lt;p&gt;Git과 markdown을 이용하여 git을 블로그처럼 이용하는 사람들이 있다는 것을 알았다.&lt;/p&gt;
&lt;p&gt;게다가 UI를 보기 좋게 꾸며줄 수 있는 툴들도 찾았는데, 그 중 Hugo를 사용해 보았다.&lt;/p&gt;
&lt;p&gt;Hugo는 Go 언어로 짜여져 있어 apt-get으로도 설치가 가능하고, 소스 코드를 받아 빌드하여 쓸 수도 있다.&lt;/p&gt;
&lt;p&gt;내 컴퓨터에는 Go가 이미 설치되 있던 터라 apt-get으로 hugo를 받아서 사용해 보았다.&lt;/p&gt;
&lt;p&gt;설치는 정상적으로 되었고, 처음에는 잘 동작하는 듯 했는데, theme을 적용하니 ERROR들이 뜨기 시작했다.&lt;/p&gt;
&lt;p&gt;인터넷 검색을 아무리 해 봐도 해결책이 보이지 않고, 해당 git에 issue를 날려보기도 했는데 응답이 없어서 혼자 이것저것 뒤져 보았다.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Markdown Syntax Guide</title>
      <link>https://aswinblue.github.io/Blog/post/hugo/sample/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/post/hugo/sample/</guid>
      <description>Sample article showcasing basic Markdown syntax and formatting for HTML elements.</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://aswinblue.github.io/Blog/about/</link>
      <pubDate>Thu, 28 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://aswinblue.github.io/Blog/about/</guid>
      <description>Hugo, the world’s fastest framework for building websites</description>
    </item>
    
    
    
  </channel>
</rss>
