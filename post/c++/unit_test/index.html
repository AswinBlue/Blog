<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Unit Test | AswinBlue</title><meta name=keywords content="C++,test,unit test,google test framework"><meta name=description content="Unit Test 테스트의 속성 좋은 단위 테스트를 작성하기 위해서는 아래 세 가지 기준을 만족해야 한다. 가독성
3A(Arrange / Act / Assert) 순서대로 test case 코드가 작성되어 있어야 한다. test case 가 어떤 동작을 검증하는지 알 수 있어야 한다. test case 의 이름을 명확하게 작성 필요 최신 test framework (java 에서 사용하는 spock)에서는 자연어로 test case 이름을 작성할 수 있도록 지원하는 경우도 있다. (google test 는 미지원) test case 실행 시 printf 문을 한 번 출력 하도록 규칙을 정하여 사용할 수 있다."><meta name=author content="AswinBlue"><link rel=canonical href=https://aswinblue.github.io/Blog/post/c++/unit_test/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=https://aswinblue.github.io/Blog/assets/css/stylesheet.min.f92d651568443750d127ad6450a5621c2bf278d2c45216a3d199fd40eafc2473.css integrity="sha256-+S1lFWhEN1DRJ61kUKViHCvyeNLEUhaj0Zn9QOr8JHM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://aswinblue.github.io/Blog/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aswinblue.github.io/Blog accesskey=h title="AswinBlue (Alt + H)">AswinBlue</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aswinblue.github.io/Blog/archives title=Archive><span>Archive</span></a></li><li><a href=https://aswinblue.github.io/Blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aswinblue.github.io/Blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aswinblue.github.io/Blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><div class=grid-container><div style=float:left;margin:30px class=auto-hide-div><ul><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webhacking/>WebHacking</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webhacking/exploit/>Exploit</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webhacking/cookie/>Cookie</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webhacking/web/>Web</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webhacking/http/>HTTP</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/systemhacking/>System Hacking</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/systemhacking/reverse_engineering/>Reverse Engineering</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/systemhacking/exploit/>Exploit</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/systemhacking/pwntool/>Pwntool</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/assembly/>Assembly</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/assembly/assembly_basic/>Assembly_basic</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/projects/>🔷Projects</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/projects/youtube_downloader/>Youtube Downloader</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/projects/delver/>Delver</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/projects/flick_through/>FlickThrough</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/windowapp/>WindowApp</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/windowapp/window_programming/>Window_programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/windowapp/kivy/>Kivy</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webserver/>WebServer</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webserver/spring_boot/>Spring_boot</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webserver/spring/>Spring basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webserver/nodejs/>Nodejs</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/>WebApplication</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/thymeleaf/>thymeleaf</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/tailwind/>Tailwind</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/angular/>Angular</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/react_basic/>React basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/pythoncgi/>PythonCGI</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/javascript/>JavaScript</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/css/>Css</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/webapplication/html/>HTML</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/python/>Python</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/python/python_basic/>Python 기초</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/mobileapp/>MobileApp</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/mobileapp/flutter/>Flutter</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/machinelearning/>MachineLearning</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/machinelearning/tensorflow/>Tensorflow</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/java/>Java</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/java/jython/>Jython</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/>Linux</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/ipc/>IPC</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/thread/>Thread</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/process/>Process</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/system_programming/>System_programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/shell_programming/>Shell Programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/linux_introduction/>Linux_introduction</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/linux_env/>Linux_env</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/virtual_box/>Virtual_box</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/linux_command/>Linux commands</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/linux/linux_apt/>Linux_apt</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/hugo/>Hugo</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/hugo/hugo_dev/>Hugo 환경세팅</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/hugo/sample/>Markdown Syntax Guide</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/golang/>GoLang</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/golang/golang/>Golang</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/git/>Git</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/git/git/>Git</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/developtips/>DevelopTips</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/developtips/vscode/>VsCode</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/developtips/window/>Window</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/developtips/web_scrapping/>Web_scrapping</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/databases/>DataBases</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/databases/database/>Database</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/databases/firebase_react/>Firebase_react</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/databases/firebase/>Firebase</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/databases/mysql/>Mysql</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/crypto/>Crypto</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/crypto/cryptocurrency/>Cryptocurrency</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/computerscience/>ComputerScience</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/computerscience/computer_science/>Computer Science</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/cloud/>Cloud</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/cloud/aws/>Aws</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/ci_cd/>CI_CD</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/ci_cd/docker/>Docker</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=https://aswinblue.github.io/Blog/post/algorithm/>Algorithm</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/algorithm/algorithm/>Algorithm</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#1284ff><a href=https://aswinblue.github.io/Blog/post/c++/>C++</a><ul><li style=list-style-position:inside;text-indent:30px;color:#1284ff;content:\25ba\00a0><a href=https://aswinblue.github.io/Blog/post/c++/unit_test/>Unit Test</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/make/>Make</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/gcc/>Gcc</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/c++_stl/>C++_stl</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/gdb/>GDB</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/c++/>C++ basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/cmake/>CMake</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/json_c++/>Json in C++</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=https://aswinblue.github.io/Blog/post/c++/log_c++/>spdlog C++</a></li></ul></li><ul></ul><ul></ul></ul></div><main class=main style=grid-row:1;grid-column:2;width:100%><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aswinblue.github.io/Blog>Home</a></div><h1 class=post-title>Unit Test</h1><div class=post-meta><span title='2024-08-19 04:00:00 +0900 KST'>August 19, 2024</span>&nbsp;·&nbsp;37 min&nbsp;·&nbsp;AswinBlue&nbsp;|&nbsp;<a href=https://github.com/AswinBlue/HugoBlog/tree/master/content/post/C++/unit_test.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#unit-test aria-label="Unit Test">Unit Test</a><ul><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%86%8d%ec%84%b1 aria-label="테스트의 속성">테스트의 속성</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8%ec%9d%98-%ec%a1%b0%ea%b1%b4 aria-label="테스트의 조건">테스트의 조건</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ea%b0%80%eb%8a%a5-%ec%84%a4%ea%b3%84-solid aria-label="테스트 가능 설계 SOLID">테스트 가능 설계 SOLID</a><ul><li><a href=#%ec%9a%a9%ec%96%b4 aria-label=용어>용어</a></li><li><a href=#test-coverage aria-label="Test Coverage">Test Coverage</a></li></ul></li><li><a href=#xunit-framework aria-label="xUnit Framework">xUnit Framework</a><ul><li><a href=#4%eb%8b%a8%ea%b3%84-%ed%85%8c%ec%8a%a4%ed%8a%b8-%ed%8c%a8%ed%84%b4 aria-label="4단계 테스트 패턴">4단계 테스트 패턴</a></li></ul></li><li><a href=#google-test-framework aria-label="Google Test Framework">Google Test Framework</a><ul><li><a href=#%ec%84%a4%ec%b9%98-%eb%b0%8f-%ec%8b%a4%ed%96%89 aria-label="설치 및 실행">설치 및 실행</a></li><li><a href=#%ea%b8%b0%eb%b3%b8-%ec%82%ac%ec%9a%a9%eb%b2%95 aria-label="기본 사용법">기본 사용법</a></li><li><a href=#test-suite-class aria-label="Test Suite Class">Test Suite Class</a></li><li><a href=#test-case-class aria-label="Test Case Class">Test Case Class</a></li><li><a href=#test-fixture aria-label="Test Fixture">Test Fixture</a><ul><li><a href=#global-fixture aria-label="Global Fixture">Global Fixture</a></li><li><a href=#%eb%8a%90%eb%a6%b0-%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%ac%b8%ec%a0%9c aria-label="느린 테스트 문제">느린 테스트 문제</a></li><li><a href=#%eb%b3%80%eb%8d%95%ec%8a%a4%eb%9f%b0-%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%ac%b8%ec%a0%9c aria-label="변덕스런 테스트 문제">변덕스런 테스트 문제</a></li></ul></li><li><a href=#assertion--exceptation aria-label="ASSERTION / EXCEPTATION">ASSERTION / EXCEPTATION</a></li><li><a href=#disabled-test-case aria-label="Disabled Test Case">Disabled Test Case</a></li><li><a href=#test-filter aria-label="Test Filter">Test Filter</a></li><li><a href=#test-%ec%8b%a0%eb%a2%b0%ec%84%b1-%ec%a0%90%ea%b2%80 aria-label="Test 신뢰성 점검">Test 신뢰성 점검</a></li><li><a href=#test-%ec%82%b0%ec%b6%9c%eb%ac%bc aria-label="Test 산출물">Test 산출물</a></li><li><a href=#%eb%b9%84%ea%b8%b0%eb%8a%a5-%ed%85%8c%ec%8a%a4%ed%8a%b8 aria-label="비기능 테스트">비기능 테스트</a></li><li><a href=#private-%ec%98%81%ec%97%ad-%ea%b2%80%ec%a6%9d aria-label="Private 영역 검증">Private 영역 검증</a></li><li><a href=#%ed%85%8c%ec%8a%a4%ed%8a%b8-%ec%a0%84%ec%9a%a9-%ed%95%98%ec%9c%84-class aria-label="테스트 전용 하위 class">테스트 전용 하위 class</a></li><li><a href=#%ed%8c%8c%eb%9d%bc%eb%af%b8%ed%84%b0%ed%99%94-%ed%85%8c%ec%8a%a4%ed%8a%b8-parameterized-test aria-label="파라미터화 테스트 (Parameterized Test)">파라미터화 테스트 (Parameterized Test)</a></li><li><a href=#test-listener aria-label="Test Listener">Test Listener</a></li><li><a href=#test-double-%ed%85%8c%ec%8a%a4%ed%8a%b8-%eb%8c%80%ec%97%ad aria-label="Test Double (테스트 대역)">Test Double (테스트 대역)</a><ul><li><a href=#test-stub aria-label="Test Stub">Test Stub</a></li><li><a href=#fake-object aria-label="Fake Object">Fake Object</a></li><li><a href=#test-spy aria-label="Test Spy">Test Spy</a></li><li><a href=#mock-object aria-label="Mock Object">Mock Object</a></li></ul></li></ul></li><li><a href=#google-mock aria-label="Google Mock">Google Mock</a><ul><li><a href=#%ec%84%a4%ec%b9%98 aria-label=설치>설치</a></li><li><a href=#%ec%82%ac%ec%9a%a9 aria-label=사용>사용</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=unit-test>Unit Test<a hidden class=anchor aria-hidden=true href=#unit-test>#</a></h1><h2 id=테스트의-속성>테스트의 속성<a hidden class=anchor aria-hidden=true href=#테스트의-속성>#</a></h2><ul><li>좋은 단위 테스트를 작성하기 위해서는 아래 세 가지 기준을 만족해야 한다.<ol><li><p>가독성</p><ul><li>3A(Arrange / Act / Assert) 순서대로 test case 코드가 작성되어 있어야 한다.</li><li>test case 가 어떤 동작을 검증하는지 알 수 있어야 한다.<ul><li>test case 의 이름을 명확하게 작성 필요</li><li>최신 test framework (java 에서 사용하는 spock)에서는 자연어로 test case 이름을 작성할 수 있도록 지원하는 경우도 있다. (google test 는 미지원)</li><li>test case 실행 시 printf 문을 한 번 출력 하도록 규칙을 정하여 사용할 수 있다.<pre tabindex=0><code>#define SPEC(msg) printf(&#34;[SPEC] %s\n&#34;, msg)
TEST(SampleTestCase, SampleTest) {
    SPEC(&#34;이 테스트는 무엇을 하는 테스트 입니다&#34;);
}
</code></pre></li></ul></li><li>코드를 보지 않고 오류의 원인을 알 수 있어야 한다.</li><li>자연여와 가깝게 테스트 코드를 표현하는 것이 유리하다.<ul><li>함수 이름을 자연어로 상세히 지정</li><li>에러 메시지를 자연어로 출력</li></ul></li></ul></li><li><p>유지보수성</p><ul><li>테스트 코드는 비용이 증가하지 않아야 한다.</li><li>테스트 코드의 오류 가능성이 있는 제어 구문(조건문, 반복문, 예외처리)은 최소화 되어야 한다.<ul><li>조건문을 최소화 하기 위해서 if 문 대신 ASSERT 구문을 사용할 수 있다.</li></ul></li></ul></li><li><p>신뢰성</p><ul><li>테스트는 테스트 순서 및 수행 횟수에 상관없이 항상 동일한 결과가 나와야 한다.</li><li>BDD(Behavior Driven Development) 관점의 개발을 위해 Mock Object 를 이용한 행위 기반 검증을 수행하여 신뢰성을 높일 수 있다.<ul><li>다만, 테스트 비용 관점에서 상태기반 검증이 행위기반 검증보다 우월하다. 코드 작성 시 상태기반 검증이 가능하게 구현한다면 행위기반 검증 적용하는 것 보다 유지보수성 관점에서 유리하다.</li></ul></li></ul></li></ol></li></ul><h2 id=테스트의-조건>테스트의 조건<a hidden class=anchor aria-hidden=true href=#테스트의-조건>#</a></h2><ul><li>자동화 : 테스트는 실행 이후 완료 까지 추가 조작 없이 돌릴 수 있어야 한다. (필요하다면 최소화)</li><li>자체 검사 : 코드를 확인하지 않고 테스트의 결과 만으로 테스트 목적과 에러 원인을 알 수 있어야 한다.</li><li>반복 : 테스트를 여러 번 돌려도 동일한 결과가 도출되어야 한다.</li><li>독리비 : 각각의 테스트는 개별로 동작이 가능해야 한다.</li></ul><h2 id=테스트-가능-설계-solid>테스트 가능 설계 SOLID<a hidden class=anchor aria-hidden=true href=#테스트-가능-설계-solid>#</a></h2><ul><li><p>Open-Closed Principle : 개방 폐쇄 원칙</p><ul><li>확장에는 열려있고, 수정에는 닫혀있는 설계</li></ul></li><li><p>Liskov Substitution Principle : 리스코프 치환 원칙</p><ul><li>다형성을 활용한 설계</li></ul></li><li><p>Interface Segregations Principle: 인터페이스 분리 원칙</p><ul><li>세분화된 인터페이스 지향, 범용 인터페이스 지양</li></ul></li><li><p>Dependency Inversion Principle : 의존 관계 역전 원칙</p><ul><li>약한 의존관계, 의존성 주입 적극 활용</li><li>추상 개념 활용</li></ul></li><li><p>코드 설계 지침</p><ul><li>복잡한 private method 지양</li><li>정적 멤버 함수 지양</li><li>Single 톤 지양</li><li>의존성 주입에 기반한 composition 모델을 사용</li><li>종속성은 최소화</li><li>생성자는 간단하게 구성하고, 생성자에서 작업은 최소화</li><li>최소 지식의 원칙 수용 (인터페이스에 없는 함수는 호출하지 않도록)</li><li>숨겨진 종속성과 전역 상태는 지양</li></ul></li></ul><h3 id=용어>용어<a hidden class=anchor aria-hidden=true href=#용어>#</a></h3><ul><li><code>Test Suite</code>: 동일한 fixture 를 사용하는 test case 의 집합</li><li><code>SUT</code> : (System Under Test) 테스트 할 대상 시스템. Code Under Test, Class Under Test 등으로 사용하기도 한다.</li></ul><h3 id=test-coverage>Test Coverage<a hidden class=anchor aria-hidden=true href=#test-coverage>#</a></h3><ul><li>공식적인 test coverage의 기준은 없다. 프로젝트마다 다르게 설정될 수 있기 때문이다.</li><li>높은 coverage 를 확보하기 위해서는 오류 case 에 대한 동작도 검증 할 필요가 있다.</li><li>test coverage 가 높다고 테스트가 잘 작성 된 것은 아니다.<ul><li>assertion 없이 동작하는 test case 들이 많아도 coverage는 높아질 수 있다.</li><li>코드가 의도한 대로 잘 동작하는지, 의도한 대로 잘 실패하는지 모두 살펴보는 것이 필요하다.</li></ul></li></ul><h2 id=xunit-framework>xUnit Framework<a hidden class=anchor aria-hidden=true href=#xunit-framework>#</a></h2><ul><li>Unit Test의 3A 순서에 대해 단계가 하나 더 추가된 <code>4단계 테스트 패턴</code>을 추구한다.</li></ul><h3 id=4단계-테스트-패턴>4단계 테스트 패턴<a hidden class=anchor aria-hidden=true href=#4단계-테스트-패턴>#</a></h3><ol><li>test fixture 설정<ul><li>사전조건 설정</li><li>SetUp()</li></ul></li><li>SUT 와 상호작용<ul><li>테스트 할 동작 수행</li></ul></li><li>기대 결과 확인<ul><li>ASSERT</li></ul></li><li>test fixture 해체<ul><li>테스트 이전의 상태로 복구</li><li>TearDown()</li></ul></li></ol><h2 id=google-test-framework>Google Test Framework<a hidden class=anchor aria-hidden=true href=#google-test-framework>#</a></h2><ul><li>C++ 을 대상으로 하는 xUnit Test Framework 중 하나이다.</li><li>C 언어를 대상으로 한다면 Google Test Framework 를 변환하여 사용하기보다 <a href=https://github.com/meekrosoft/fff>FFF 프로젝트</a> 와 같이 다른 라이브러리를 사용하는 것을 권장한다.</li></ul><h3 id=설치-및-실행>설치 및 실행<a hidden class=anchor aria-hidden=true href=#설치-및-실행>#</a></h3><ol><li><p><code>wget https://github.com/google/googletest/releases/download/v1.15.2/googletest-1.15.2.tar.gz</code> 명령으로 소스코드 다운로드</p></li><li><p><code>g++ googletest/googletest/src/gtest-all.cc -c -I ./googletest/googletest/include/ -I ./googletest/googletest -std=c++14 -O2</code> 명령으로 소스코드 컴파일</p><ul><li>include 경로를 설정하여 빌드, 목적파일을 생성한다.</li></ul></li><li><p>ar rcv libgtest.a gtest-all.o</p><ul><li>목적파일 라이브러리화 하여 .lib 파일 생성</li></ul></li><li><p>google test의 main 작성. 아래 형태가 기본적으로 설정되어야 한다.</p><pre tabindex=0><code>int main(int argc, char* argv[]) {
    testing::InitGoogleTest(*argc, argv);
    return RUN_ALL_TESTS();
}
</code></pre><ul><li><code>googletest/src/gtest_main.cc</code> 경로에 있는 main을 사용해도 된다.<ul><li><code>g++ -c ./googletest/googletest/src/gtest_main.cc -I ./googletest/googletest/include/ -std=c++14 -O2</code> 명령으로 gtest_main.o 를 생성한다.</li><li><code>ar rcv libgtest.a gtest-all.o gtest_main.o</code> 명령으로 test.a 라이브러리에 gtest_main 을 포함시킨다.</li><li>이후에는 main 함수를 따로 작성하지 않아도 라이브러리만 추가하여 빌드하면 main 함수를 직접 작성 한 것과 동일하게 동작한다.</li></ul></li></ul><blockquote><p>main 함수는 직접 정의해서 사용 하는것을 권장한다.<br>main 함수는 두 개 이상 선언할 경우에는 컴파일러에 따라 링크 오류가 발생하거나 원하지 않는 main 함수가 실행될 수도 있다.</p></blockquote></li><li><p><code>g++ main.cpp -I ./googletest/googletest/include/ -lgtest -L. -std=c++14 -pthread</code></p><ul><li>소스코드와 함께 라이브러리를 연동하여 실행 파일 빌드</li></ul></li></ol><h3 id=기본-사용법>기본 사용법<a hidden class=anchor aria-hidden=true href=#기본-사용법>#</a></h3><ol><li>gtest/gtest.h 헤더 하나만 include 하면 g-test의 모든 기능 사용 가능</li><li>Test Case 작성<ul><li><p>TEST(Test_Suite_Name, Test_Case_Name) 형태의 매크로를 사용하여 TC 생성 가능</p><pre tabindex=0><code>TEST(SampleTestCase, SampleTest) {
    FAIL() &lt;&lt; &#34; 실패&#34;;  // 실패처리 이후 화면에 &#34;실패&#34; 문자열 출력
}
</code></pre></li><li><p>FAIL() 매크로가 호출되지 않는 Test Case는 성공으로 처리된다.</p><ul><li>SUCCEED() 라는 매크로가 있지만, 이는 가독성을 위한 것일 뿐, 아무것도 하지 않는 매크로이다.</li></ul></li><li><p>3A 에 기반하여 test case 를 구성한다.</p><ol><li>Arrange (Given) : 테스트 대상 코드를 초기화하고 필요한 경우 설정하고 준비<ul><li>객체 선언, 초기화 등</li></ul></li><li>Act (When) : 테스트 대상 코드에서 동작을 수행<ul><li>동작 수행</li></ul></li><li>Assert (Then) : 기대하는 바와 실제 결과를 비교<ul><li>ASSERT 매크로 활용<ul><li><code>ASSERT_EQ(a, b)</code> : a ==b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_NE(a, b)</code> : a != b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_LT(a, b)</code> : a &lt; b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_LE(a, b)</code> : a &lt;= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_GT(a, b)</code> : a > b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_GE(a, b)</code> : a >= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li>ex) `ASSERT_EQ(a, b) &#171; &ldquo;a == b 를 만족하지 못합니다&rdquo;</li></ul></li></ul></li></ol></li></ul></li></ol><h3 id=test-suite-class>Test Suite Class<a hidden class=anchor aria-hidden=true href=#test-suite-class>#</a></h3><ul><li><p><code>testing::Test</code> Class 를 상속받는 Class이다.</p><ul><li>ex) <code>class TestSuiteName : public testing::Test</code></li></ul></li><li><p><code>신선한 Fixture 전략</code></p><ul><li>test case 간 동작의 독립성을 보장하기 위해 test case 가 하나 수행되면 새로운 fixture 객체를 생성하고 소멸하는 방식</li><li>&ldquo;느린 테스트 문제"가 발생하여 개발자의 생산성을 떨어뜨리고, 개발자가 regression test를 수행하지 않게 될 수 있다.</li></ul></li><li><p><code>공유 fixture 전략</code></p><ul><li>fixture 설치/해체에 소요되는 시간을 절감하여 테스트 속도를 증가시키기 위해 모든 test case 가 공유된 fixture를 사용하는 방식<ul><li>&ldquo;변덕스런 테스트 문제"가 발생 할 수 있다.</li></ul></li></ul></li><li><p>대부분의 xUnit framework 는 &lsquo;신선한 fixture 전략&rsquo; 을 사용하지만, test framework 마다 차이가 있을 수 있으므로, test case 의 독립성을 유지시키기 위해서는 framework 에 따라 다른 전략이 필요하다.</p></li><li><p>test suite 에 대응되는 class 이므로, 용도도 test suite 에 맞게 동일한 fixture 를 사용하는 test ase 들을 관리할 수 있는 class 로 활용하면 되겠다.</p></li></ul><h3 id=test-case-class>Test Case Class<a hidden class=anchor aria-hidden=true href=#test-case-class>#</a></h3><ul><li><code>TEST</code> 혹은 <code>TEST_F</code> 매크로를 사용하면 자동으로 생성된다.<ul><li><code>TEST</code> 매크로 : 암묵적으로 test suite class 를 생성하고 test case class 를 생성하는 매크로</li><li><code>TEST_F</code> 매크로 : 명시적으로 생성된 test suite class 를 참조하여 test case class 를 생성하는 매크로<ul><li>&lsquo;F&rsquo; 는 fixture 의 약자</li></ul></li></ul></li><li>Test Suite Class 를 상속받아 생성된다.<ul><li>ex) <code>TEST(TestSuiteName, TestCaseName)</code> -> <code>class TestSuiteName_TestCaseName_test : public TestSuiteName</code></li></ul></li></ul><h3 id=test-fixture>Test Fixture<a hidden class=anchor aria-hidden=true href=#test-fixture>#</a></h3><ul><li><p>xUnit Test Framework 에서 SUT 를 실행하기 위해 준비해야 하는 사전 작업(사전 조건)</p></li><li><p>Arrange 단계가 fixture setup 를 수행하는 단계이다.</p></li><li><p>Test Fixture 를 구성(setup)하는 방식은 두 가지가 있고, 각각 장단이 있다.</p><ol><li><p>Inline Fixture Setup</p><ul><li>모든 fixture setup을 test case 안에서 수행</li><li>장점 : 인과관계 분석이 쉽다.</li><li>단점 : 테스트 코드의 중복이 발생한다.<ul><li>test smell (테스트의 가독성, 유지보수성, 신뢰성을 떨어뜨리는 요소) 에 해당한다.</li></ul></li></ul></li><li><p>Delegate Setup</p><ul><li><p>fixture setup 단계를 test utility 함수를 통해 캡슐화 한다.</p></li><li><p><code>TEST()</code> 매크로를 호출하는 것은, <code>testing::Test</code> class 를 상속하여 class 를 생성하고, 그 생성된 class를 호출하는 형태이다. 이러한 형태를 암묵적인 방법으로 test suite class 를 선언하는 형태라 한다.</p></li><li><p>test suite class 를 명시적으로 선언한다면, delegate setup 기법을 사용할 수 있다.</p><pre tabindex=0><code>// 명시적인 test suite class 선언
class TestSuiteName : public testing::Test {
public:  // 자식 class 에서 접근할 수 있어야 하기 때문에 public 혹은 protected 설정 가능
    class target = new TargetClass()  // 공통된 fixture setting 동작 수행(변수 선언)
    // 여기서 선언된 변수를 TEST_F 에서 참조하여 사용 
};

TEST_F(TestSuiteName, TestCaseName) { 
  target.do_something(); // TestSuiteName class 의 &#39;target&#39; 변수 사용 가능
} // TEST() 매크로 대신 TEST_F() 매크로 사용하여 test case class 선언
// c++ 내부적으로 class TestSuiteName_TestCaseName_test : public TestSuiteName 형태의 class 가 선언 된다. 
</code></pre><ul><li>명시적으로 test suite class 를 선언하고, TEST() 대신 TEST_F() 매크로로 test case class 를 선언한다.</li></ul></li><li><p>장점 : 테스트 코드의 중복을 제거하고, redundant 한 테스트 준비 과정을 test case 안에서 제거 할 수 있다.</p></li><li><p>단점 : 인과관계 분석이 어렵다</p></li></ul></li><li><p>Implicit Setup</p><ul><li>xUnit test framework 이 제공하는 방법</li><li><code>Delegate Setup</code> 과 마찬가지로 명시적인 test suit class 작성이 필요</li><li>test suit class 에서 <code>SetUp()</code> 함수를 정의 해 놓으면, test case 가 실행 될 때 <code>SetUp()</code> 함수가 호출된다. (암묵적 수행)<pre tabindex=0><code>// 명시적인 test suite class 선언
class TestSuiteName : public testing::Test {
protected:
    void SetUp() override
    {
        class target = new TargetClass()  // 공통된 fixture setting 동작 수행(변수 선언)
    }
    void TearDown() override
    {
        delete target
    }
};

TEST_F(TestSuiteName, TestCaseName) { 
  target.do_something(); // TestSuiteName class 의 &#39;target&#39; 변수 사용 가능
}
</code></pre></li><li>장점 : 테스트 코드의 중복을 제거하고, redundant 한 테스트 준비 과정을 test case 안에서 제거 할 수 있다.</li><li>단점 : 인과관계 분석이 어렵다</li></ul></li></ol></li><li><p>Delegated Setup 혹은 Implicit Setup 을 사용할 때 메모리 누수에 대해 주의할 필요가 있다.</p><ul><li>ASSERT 구문은, 실패로 판단되는 경우 이후 동작은 수행하지 않는다.</li><li>만약 ASSERT 구문에 의해 실패가 발생하면 이후 객체의 소멸자가 호출하지 않게 된다.</li></ul></li><li><p>Implicit Setup 을 사용 할 경우에는 테스트가 시작되기 전 <code>SetUP()</code> 함수가 호출되고, 테스트가 완료 되면 <code>TearDown()</code> 함수가 호출된다.</p><ul><li><code>SetUp()</code> 에서 fixture setup을 완료 해 주고, <code>TearDown()</code> 에서 사용한 리소스를 정리하면 되겠다.</li></ul></li></ul><h4 id=global-fixture>Global Fixture<a hidden class=anchor aria-hidden=true href=#global-fixture>#</a></h4><ul><li><p><code>testing::Environment</code> 를 상속받은 class 로 전역 fixture 를 설정 할 수 있다.</p><ul><li>ex) <code>class MyEnvironment : public testing::Environment</code></li></ul></li><li><p>Environment class 에는 Test class 와 마찬가지로 <code>Setup</code>, <code>TearDown</code> 이 제공된다.</p></li><li><p>main 함수 안에 <code>testing::AddGlobalTestEnvironment(new MY_OBJECT);</code> 구문을 추가 해 주면, 모든 test 수행 직전에 Environment의 <code>SetUp()</code> 함수가 동작하고, 모든 test case 들이 수행된 이후 Environment의 <code>TearDown()</code> 함수가 실행된다.</p><ul><li>ex) <code>testing::AddGlobalTestEnvironment(new MyEnvironment)</code> // 인자로 들어갈 객체를 new 를 통해 생성해야 함에 주의. 완료 후 자동으로 해제됨</li></ul></li><li><p>main 함수를 직접 구현하지 않은 경우에는 아래 구문으로도 적용 가능하다.</p><ul><li><code>testing::Environment* myEnvironment = testing::AddGlobalTestingEnvironment(new MyEnvironment);</code></li><li>전역 변수는 main 함수가 실행되기 전에 설정된다는 점을 이용한 방식</li><li>하지만, 가독성을 떨어뜨리고 아래 문제를 발생시킬 수 있기 때문에 공식적으로는 권장하지 않는 방식이다.</li></ul><blockquote><ul><li>둘 이상의 environment를 선언하면 environment 의 설정과 해체 순서가 중요하다. 먼저 설정된 environment 가 가장 나중에 해제되어야 한다.(LIFO)</li><li>하지만 C++ 에서는 둘 이상의 파일에 선언된 전역변수의 초기화 순서가 명확히 정의되어있지 않다.</li><li>여러 파일에서 포인터를 활용하여 environment를 선언하면 environment 의 설정과 해체 순서가 보장되지 않아 위험하다.</li><li>main 함수를 직접 구현하여 environment를 설정하면 environment 의 해체 순서가 명확히 정의 되어 안전하다.</li></ul></blockquote></li></ul><h4 id=느린-테스트-문제>느린 테스트 문제<a hidden class=anchor aria-hidden=true href=#느린-테스트-문제>#</a></h4><ul><li>&ldquo;신선한 fixture 전략&rdquo; 을 사용하는 경우, SetUp 과 TearDown 에 시간이 많이 소요된다면 TestCase 가 많아질 수록 test 에 소요되는 시간이 늘어나 생산성이 떨어진다.<ul><li>테스트가 느리면 code 가 변경되어도 테스트를 수행하지 않게 될 수도 있다.</li></ul></li><li>이러한 문제를 해결하기 위해, xUnit Framework 에서는 수동으로 호출 할 수 있는 fixture 설치/해제 동작을 제공한다.<ul><li>아래와 같이 함수를 대체하면 test case 마다 SetUp / Teardown 을 수행하지 않고, SetUp은 최초 한 번, TearDown은 최후 한번만 수행한다.<ul><li><p><code>void SetUp()</code> -> <code>static void SetUpTestSuite()</code></p></li><li><p><code>void TearDown()</code> -> <code>static void TearDownTestSuite()</code></p></li><li><p>ex)</p><pre tabindex=0><code>// AS IS
SetUp()
TC1()
TearDown()
SetUp()
TC2()
TearDown()
SetUp()
TC3()
TearDown()

// TO BE
SetUpTestSuite()
TC1()
TC2()
TC3()
TearDownTestSuite()
</code></pre></li><li><p>static 함수를 사용하기 때문에 class 멤버 변수도 static 으로 변경하여 선언이 필요하다.</p></li></ul></li></ul></li><li>여러 test case 가 하나의 fixture 객체를 공유하기 때문에, fixture 관리가 제대로 되지 못한다면 &ldquo;변덕스런 테스트 문제"가 발생할 수 있다. 즉, 신뢰성이 떨어질 수 있다.</li><li>C++ 에서는 생성자와 소멸자와 유사하고 대체 가능하지만, 특정 언어에서는 소멸자 개념이 없기 떄문에 xUnit Framework 관점에서는 생성자 소멸자 대신 SetUpTestSuite, TearDownTestSuite 를 사용하는 것이 바람직하다.</li></ul><h4 id=변덕스런-테스트-문제>변덕스런 테스트 문제<a hidden class=anchor aria-hidden=true href=#변덕스런-테스트-문제>#</a></h4><ul><li>test case 의 수행 횟수, 순서 등에 따라 test case 의 결과가 달라지는 현상</li><li>어떤 test case 에 의해 다음 test case 의 test fixture 가 영향을 받아 발생</li></ul><h3 id=assertion--exceptation>ASSERTION / EXCEPTATION<a hidden class=anchor aria-hidden=true href=#assertion--exceptation>#</a></h3><ol><li><p>ASSERTION</p><ul><li><p>ASSERTION 종류는 다음같다.</p><ul><li><code>ASSERT_EQ(a, b)</code> : a ==b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_NE(a, b)</code> : a != b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_LT(a, b)</code> : a &lt; b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_LE(a, b)</code> : a &lt;= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_GT(a, b)</code> : a > b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_GE(a, b)</code> : a >= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_TRUE(a)</code> : a == true 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>ASSERT_FALSE(a)</code> : a == false 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li></ul></li><li><p>ASSERTION 은 FAIL로 판별되면 다음 동작은 수행하지 않는다. 이러한 ASSERTION 의 특징상 하나의 test case 안에서 여러 ASSERTION 을 사용하면 한 번의 검증으로 모든 ASSERTION 을 검증할 수 없다.</p><ul><li>&ldquo;죽은 단원문의 문제&rdquo; 발생</li><li>xUnit Framework 에서는 하나의 test case 에 하나의 ASSERTION 만 사용하도록 권장</li><li>하지만, ASSERTION 을 분리하면 관리해야 하는 test case 가 늘어나고, test code 중복의 문제가 발생한다.</li><li>이를 대체하기 위해 <code>EXPECT</code> 구문이 존재한다.</li></ul></li><li><p>특정 구문이 FAIL 일 때, 이후 코드를 동작시킬 때 segmentation fault 가 발생한다면 ASSERTION 을 사용하는 것이 좋다.</p><ul><li>테스트 프로그램이 안전하게 동작 할 수 있는 보호 역할을 수행한다.</li></ul></li></ul></li><li><p>EXCEPTATION</p><ul><li><p>google framework 에서 제공하는 기능으로, 지원하지 않는 test framework 들도 있다.</p></li><li><p>ASSERTION과 유사하지만, FAIL 판정이 되더라도 이후의 코드도 끝까지 수행한다.</p></li><li><p>ASSERTION 대신 EXCEPTATION 을 사용하면 &ldquo;죽은 단원문의 문제&rdquo; 를 해결할 수 있다.</p></li><li><p>EXCEPTATION 종류는 다음과 같다.</p><ul><li><code>EXCEPTATION_EQ(a, b)</code> : a ==b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_NE(a, b)</code> : a != b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_LT(a, b)</code> : a &lt; b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_LE(a, b)</code> : a &lt;= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_GT(a, b)</code> : a > b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_GE(a, b)</code> : a >= b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_TRUE(a)</code> : a == true 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_FALSE(a)</code> : a == false 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li></ul></li><li><p>segmentation fault 등으로 인해 테스트 프로그램이 비정상 종료 될 수 있는 경우 EXCEPTION 보다는 ASSERTION 을 사용하는 것이 권장된다.</p></li></ul></li></ol><ul><li><p>C 문자열을 비교</p><ul><li><code>EXCEPTATION_STREQ(a, b)</code> : 문자열a == b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_STRNE(a, b)</code> : 문자열a != b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXCEPTATION_STRCASEEQ(a, b)</code> : 대소문자 상관없이 문자열a == b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li></ul></li><li><p>부동소수점 비교</p><ul><li>부동 소수점을 일반 판정문으로 비교를 하면 메모리에 표시되는 형태를 바로 비교하기 때문에 원하는 결과가 나오지 않을 수 있다.<ul><li>ex) <code>EXPECT_EQ(0.7, 0.1 * 7)</code> -> FAIL()</li></ul></li><li>부동 소수점의 오차 범위(라이브러리에 정의된) 안에 들어오는지 판단하는 로직이 추가로 존재한다.</li><li><code>EXPECT_DOUBLE_EQ(a, b)</code>: 부동소수점 a == b 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXPECT_NEAR(a, b, c)</code>: |a-b| &lt;= C 라면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출 (오차 허용 범위)<ul><li>라이브러리에 정의된 오차 범위 말고 직접 오차 범위를 설정하여 판별하는 방법</li></ul></li></ul></li><li><p>Error case 비교</p><ul><li>try-catch 구문에서 catch 로 처리된 구문과 의도하지 않은 error 를 구분하여 검증 할 수 있다.<ul><li><code>EXPECT_THROW(FUNCTION_TO_RUN, ERROR)</code> : FUNCTION_TO_RUN 에서 예외를 throw 한다면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li>ex) <code>EXPECT_THROW(do_something(arg), std::invalid_argument)</code>&#171; &ldquo;의도하지 않은 인자&rdquo;</li><li><code>EXPECT_ANY_THROW(FUNCTION_TO_RUN)</code> : FUNCTION_TO_RUN 에서 예외를 throw 한다면 <code>SUCCEED()</code>, 아니면 <code>FAIL()</code> 호출</li><li><code>EXPECT_NO_THROW(FUNCTION_TO_RUN)</code> : FUNCTION_TO_RUN 에서 예외를 throw 한다면 <code>FAIL()</code>, 아니면 <code>SUCCEED()</code> 호출</li></ul></li></ul></li></ul><h3 id=disabled-test-case>Disabled Test Case<a hidden class=anchor aria-hidden=true href=#disabled-test-case>#</a></h3><ul><li><p>test case 의 결과는 FAIL 과 SUCCESS 외 &ldquo;유지 보수가 필요한 상태&rdquo; 가 하나 더 존재한다.</p><ul><li>유지 보수가 필요한 test case 를 주석처리 하면 test case 존재 자체가 잊혀질 수 있다(&ldquo;잊혀진 테스트 문제&rdquo;)</li><li>유지 보수가 필요한 test case 를 fail 처리하면 false alarm 이 발생한다.</li><li>유지 보수가 필요한 test case 를 true 처리 하면 정상 TC로 판단되어 유지보수가 필요하다는 것이 드러나지 않을 수 있다.</li></ul></li><li><p>유지보수가 필요한 경우, test 를 비활성화 하여 결과에 포함되지 않지만 비활성화 테스트를 따로 표기 되도록 하려면, test case 의 이름 앞에 prefix 로 <code>DISABLED_</code> 를 붙이면 된다.</p><ul><li>ex) <code>TEST(MyTestSuite, DISABLED_MyTestCase)</code></li><li>테스트 실행 결과에 <code>YOU HAVE # DISABLED TEST</code> 문구가 표시된다.</li></ul></li><li><p>test suite 이름에 <code>DISABLED_</code> 를 붙여도 test case 를 비활성화 시킬 수 있다.</p><ul><li>ex) <code>TEST(DISABLED_MyTestSuite, MyTestCase)</code></li></ul></li><li><p>테스트 실행시 <code>--gtest_aosl_run_disabled_tests</code> 옵션을 추가하면 disabled 된 테스트도 실행 할 수 있다.</p><ul><li>ex) <code>./a.out --gtest_aosl_run_disabled_tests</code></li></ul></li></ul><h3 id=test-filter>Test Filter<a hidden class=anchor aria-hidden=true href=#test-filter>#</a></h3><ul><li>원하는 테스트를 선택적으로 실행 할 수 있도록 하는 기능</li><li>테스트 실행시 test case 의 이름으로 필터를 걸 수 있다.<ul><li><code>--gtest_filter=TEST_SUITE_NAME.TEST_CASE_NAME</code> 옵션을 추가한다.</li><li>ex) <code>./a.out --gtest_filter=myTestSuite.MyTestCase</code></li><li>ex) <code>./a.out --gtest_filter=myTestSuite.MyTestCase:myTestSuite2.MyTestCase2</code> // 복수의 조건 설정</li><li>wild card 를 지원한다.<ul><li>ex) <code>./a.out --gtest_filter=my*.*</code></li></ul></li><li>특정 항목을 제외하는 조건을 설정 가능하다.<ul><li>ex) <code>./a.out --gtest_filter=my*.*:*.foo</code></li></ul></li></ul></li></ul><h3 id=test-신뢰성-점검>Test 신뢰성 점검<a hidden class=anchor aria-hidden=true href=#test-신뢰성-점검>#</a></h3><ul><li>테스트는 수행 횟수와 순서에 상관없이 동일한 결과가 나와야 한다. 테스트의 신뢰성을 점검하기 위해 테스트 실행시 설정 가능한 옵션이 존재한다.<ul><li><code>--gtest_shuffle</code> : 테스트 순서를 무작위로 섞어준다.</li><li><code>--gtest_repeat=REPEAT_NO</code> : REPEAT_NO 횟수만큼 테스트 반복 실행<ul><li>몇 번째 테스트에서 실패 했는지 확인하기 어렵다.</li></ul></li><li><code>--gtest_break_on_failure</code> : 테스트 실패시 강제적으로 프로그램을 종료하는 옵션. 특히 반복 테스트 시에 유용하다.</li></ul></li></ul><h3 id=test-산출물>Test 산출물<a hidden class=anchor aria-hidden=true href=#test-산출물>#</a></h3><ul><li>테스트 실행시 옵션을 추가하여 test 결과를 원하는 형태로 export 가능하다.<ul><li><code>--gtest_output=xml</code>: <code>test_detail.xml</code> 파일에 test 결과를 xml 형태로 저장<ul><li><code>--gtest_output=xml:OUTPUT_NAME.xml</code>: 출력 결과물 이름 <code>OUTPUT_NAME.xml</code> 로 설정</li></ul></li><li><code>--gtest_output=json</code> : <code>test_detail.json</code> 파일에 test 결과를 json 형태로 저장<ul><li>google test framework 고유의 기능으로 1.10 버전 이후부터에 지원</li></ul></li><li>xUnit Test Framework 정립 이전(google test framework 1.10버전 이전)에는 용어가 상이할 수 있다.</li></ul></li><li>비 기능적인 부분도 산출물에 출력되도록 설정 가능하다..<ul><li>코드에 <code>RecordProperty(KEY, VALUE)</code> 항목을 추가하여 산출물에 사용자가 정의한 key, value 를 추가할 수 있다.</li></ul></li></ul><h3 id=비기능-테스트>비기능 테스트<a hidden class=anchor aria-hidden=true href=#비기능-테스트>#</a></h3><ul><li>시간, 메모리 등 성능에 대한 검증이 필요할 때, 가독성을 높이며 로직 추가를 최소화 하여야 한다.</li></ul><ol><li><p>시간 측정</p><ul><li>매크로를 활용한 <em>사용자 정의 단언문</em>으로 가독성 문제를 해결 가능하다.<pre tabindex=0><code>#define EXPECT_TIMIEOUT(fn, t)                                                        \
    do {                                                                              \ 
        time_t timeout = t;  // 테스트 결과에 변수명이 찍히므로, 변수명도 유의미하게 선언  \ 
        time_t start = time(nullptr);                                                 \
        fn;                                                                           \ 
        time_t duration = time(nullptr) - start;                                      \
        EXPECT_LE(duration, timeout) &lt;&lt; &#34;Timeout &#34; &lt;&lt; duration &lt;&lt; &#34;/&#34; &lt;&lt; timeout;     \
    } while (0)
</code></pre></li></ul></li><li><p>메모리 측정</p><ol><li><p>operation new, operation delete 을 재정의</p><ul><li><p>메모리 할당 횟수를 전역변수로 관리하여 new 와 delete 의 횟수가 일치하는지 점검</p></li><li><p>GTEST_LEAK_TEST define 을 추가하여 메모리 검증 테스트 코드는 컴파일시 선택적으로 적용 가능하도록 구현</p><ul><li>컴파일 옵션에 <code>-DGTEST_LEAK_TEST</code> 추가하여 코드 적용 가능</li></ul><pre tabindex=0><code>static int cnt

class SUT {
public:
  // 테스트 할 함수
  void do_something() {
    ;
  }
# ifdef GTEST_LEAK_TEST
  // 재정의
  void* operator new(size_t size)
  {
      ++allocCount;
      return malloc(size);
  }
  // 재정의
  void operator delete(void* p, size_t)
  {
      free(p);
      --allocCount;
  }
#endif
};
# ifdef GTEST_LEAK_TEST
int SUT::cnt = 0; // 전역변수
# endif

TEST(TS,TC) {
    int alloc = SUT::cnt;
    EXPECT_TRUE(SUT::do_something());
    int diff = SUT::cnt - alloc;
    EXPECT_EQ(diff, 0) &lt;&lt; diff &lt;&lt; &#34;memory leacked!&#34;;
}
</code></pre></li><li><p>명시적으로 class 를 만들고 SetUp 과 TearDown 활용 할 수도 있다.</p><pre tabindex=0><code>class SUTTest : public testing::Test {
protected:
    void SetUp() override
    {
# ifdef GTEST_LEAK_TEST
        alloc = SUT::cnt;
#endif
    }
    void TearDown() override
    {
# ifdef GTEST_LEAK_TEST
        int diff = SUT::cnt - alloc;
        EXPECT_EQ(diff, 0) &lt;&lt; diff &lt;&lt; &#34;memory leacked!&#34;;
#endif
    }
}

TEST(TS,TC) {
   EXPECT_TRUE(SUT::do_something());
}
</code></pre></li><li><p>단점</p><ul><li>제품 코드에 테스트용 코드가 추가된다.</li><li>test code 가 특정 제품 코드에 국한되고, 재사용이 어렵다.</li><li>SetUp 과 TearDown 이 fixture 외 용도로 사용된다.</li></ul></li></ul></li><li><p>Sanitizer 사용</p><ul><li>Sanitizer : 메모리, 속도, 미정의 동작을 체크 할 수 있는 컴파일러가 제공하는 도구</li><li>다만, 모든 플랫폼에서 제공되지는 않는다. (리눅스 플랫폼에서는 지원 됨)</li><li>컴파일 옵션에 <code>-fsanitize=address</code> 를 추가하면 설정 가능하다.<ul><li>google test framework 결과와 별개로 실행 결과 출력에서 memory leak 이 발생한 크기 및 위치 정보가 출력된다.</li></ul></li><li>C++ 에서는 1번 방법보다 Sanitizer 를 사용하는 것이 더 효과적이다.</li><li>컴파일러 sanitize 옵션<ul><li><code>-fsanitize=address</code> : 메모리 릭 감지</li><li><code>-fsanitize=thread</code> : 데드락 감지</li><li><code>-fsanitize=undefined</code> : 미정의 동작 감지</li></ul></li></ul></li></ol></li></ol><h3 id=private-영역-검증>Private 영역 검증<a hidden class=anchor aria-hidden=true href=#private-영역-검증>#</a></h3><ul><li>private 영역에 존재하는 함수는 test code 클래스에서 호출할 수 없어 검증이 불가능하다. (xUnit Test framework 표준에는 방법이 없음)</li><li>xUnit Test pattern 에서는, 테스트가 필요한 method 는 private 영역에 두지 않아야 한다고 권장한다.<ul><li>&ldquo;검증되지 않은 private method 는 검증된 public method 보다 위험하다&rdquo;</li><li>private method 는 public method 의 가독성을 높이는 목적으로 사용되어야 한다.<ul><li>private method 는 public method 에서 호출되는 형태로 구성<pre tabindex=0><code>private:
A();
B();
public:
C() {
  A();
  B();
}
</code></pre></li></ul></li></ul></li><li>Google Test Framework 는 <code>FRIEND_TEST</code> 기능을 제공하여 test case 에서 private 함수에 접근이 가능하게 할 수 있다.<pre tabindex=0><code>class SUT {
    void process1() { }
    void process2() { }
public:
    void foo() { }
    void goo() {
        process1();
        process2();
    }

    FRIEND_TEST(TS, TC);  // &#39;TS&#39; test suite 의 &#39;TC&#39; test case 이름을 가진 test case 에서 private 영역에 참조 가능
};

TEST(TS, TC) {
  SUT sut;
  sut.goo();
  sut.process1(); // 에러 발생하지 않음
}
</code></pre></li><li>단점 : 제품코드에 google test framework 의존성이 생기게 된다.<ul><li><code>#include &lt;gtest/gtest_prod.h></code> 를 추가하면 FRIEND_TEST 를 사용할 수 있다.</li></ul></li><li>장점 : 은닉 정책을 변경하지 않고 테스트를 수행 할 수 있다.</li></ul><h3 id=테스트-전용-하위-class>테스트 전용 하위 class<a hidden class=anchor aria-hidden=true href=#테스트-전용-하위-class>#</a></h3><ol><li>테스트가 필요한 함수가 protected 영역에 존재한다면, test code 영역에서 SUT class 를 상속받는 하위 class 를 만들어서 테스트 되지 않은 요구사항을 검증할 수 있다.</li></ol><pre tabindex=0><code>class SUT {
    protected:
        void foo() { }
};

class TestSUT : public SUT {  // SUT 를 상속한 test class
public:

using SUT::foo();  // parent 의 foo 함수를 public 영역에서 재선언. 아래 주석과 동일한 역할
/*
    void foo() {
        return foo();  // SUT 의 foo 함수를 호출
    }
*/
}
TEST(TS, TC) {
    TestSUT sut;
    sut.foo(); // 호출 가능
  }
</code></pre><ul><li>장점 : 제품 code를 변경하지 않고 요구사항을 검증 할 수 있다.</li></ul><ol start=2><li>제품 코드에서 검증을 위해 확인 할 수 있는 요소가 없고, 테스트 할 함수가 가상함수로 구현된 경우</li></ol><ul><li><p>ex)</p><pre tabindex=0><code>  class SUT1 {
      virtual ~SUT() {}
      virtual void foo() { }  // 가상함수
  };

  class SUT2 {
      SUT1* sut;
      SUT2 (SUT1* sut) : sut { sut };  // 생성자, 초기화
      void goo() {
          sut-&gt;foo();
      }
  };
</code></pre><ul><li>goo 호출시 foo 가 호출됨을 확인하고싶지만, SUT1 객체에 foo 호출 여부를 알 수 있는 변수가 없다.</li><li>테스트 class 를 추가한다.</li></ul><pre tabindex=0><code>class TestSUT1 : public SUT1 {
public:
    bool flag = false;  // foo 가 호출되었는지 여부를 표시하는 변수 추가
    void foo() override {
        SUT1::foo();
        flag = true;
    }
};

TEST(TS, TC) {
    TestSUT1 sut1;
    SUT2 sut2 {&amp;sut1};

    sut2.goo();  // foo 가 가상함수이기 때문에 goo 에서 TestSUT1.foo 를 호출

    EXPECT_TRUE(sut1.flag);  // foo 가 호출되었는지 여부를 확인 가능
}
</code></pre></li><li><p>제품 코드를 수정하여 test code 작성 리소스를 줄이는 것이 가장 이상적이다.</p><ul><li>단위 테스트 작성 비용이 최소화 되어야 하고, 테스트하기 쉬워야 한다는 관점에서 볼 때</li></ul></li><li><p>제품 코드 수정 없이 문제를 해결하려면, 생성자/소멸자 가상함수를 hooking 하여 테스트를 위한 코드를 작성 할 수 있다.</p></li><li><p>위 방법은 foo 가 가상함수이기 때문에 가능한 방법이다.</p><ul><li>멤버 함수는 객체의 type 을 보고 수행되기 때문에 parent 의 함수가 수행됨</li><li>가상함수는 참조 변수의 함수를 바로 호출하기 때문에 child 의 함수가 수행됨</li></ul></li><li><p>위 경우를 보면 일반 함수보다 가상 함수가 테스트 하기 편하다는 장점을 확인 할 수 있다.</p></li></ul><h3 id=파라미터화-테스트-parameterized-test>파라미터화 테스트 (Parameterized Test)<a hidden class=anchor aria-hidden=true href=#파라미터화-테스트-parameterized-test>#</a></h3><ul><li><p>test code 의 중복을 제거하기 위해 test code 에 for 문을 사용한 loop 를 추가하면 문제가 발생한다.</p><ul><li>테스트 코드에 제어구문이 들어가게 된다.</li><li>에러 발생시 테스트 결과 산출물에 에러를 발생시킨 인자가 정확하게 표시되지 않을 수 있다.</li></ul></li><li><p>xUnit Test Framework 은 입력 데이터를 바꿔가며 반복 검사하는 데이터 중심의 테스트에서 테스트 코드 중복의 문제를 해결할 수 있는 기능을 제공</p></li><li><p>사용 방법</p><ol><li><p><code>TestWithParam</code> 을 상속받는 명시적인 test suite class 선언</p><ul><li>ex) <code>class stringTestSuite : public testing::TestWithParam&lt;std::string> { };</code></li></ul></li><li><p><code>INSTANTIATE_TEST_SUITE_P</code> 매크로를 활용하여 data set 정의</p><ul><li><code>INSTANTIATE_TEST_SUITE_P(prefix, test_suite_class, data_set)</code><ul><li>prefix : 어떤 특성을 갖고있는지 표현하는 용도, string 형태 아니고 코드 형태로 원하는 문자 입력하면 됨</li><li>test_suite_class : data set 을 사용할 test suite class 이름</li><li>data_set : <code>testing::Values()</code> 함수로 표현된 데이터 셋</li><li>ex)<pre tabindex=0><code>INSTANTIATE_TEST_SUITE_P(Prefix, TS, 
    testing::Values(
      &#34;AAA&#34;,
      &#34;BBB&#34;,
      &#34;CCC&#34;
    )
);
</code></pre></li></ul></li></ul></li><li><p>data set 을 이용하는 test case 를 정의한다.</p><ul><li><code>TEST_P</code> 매크로를 사용하여 test case 를 정의한다.</li><li><code>GetParam()</code> 함수를 사용하면 이전에 정의한 data set 을 하나씩 불러온다.</li><li>정의된 data set 갯수만큼 TEST_P 로 정의한 함수를 호출한다.</li><li>ex)<pre tabindex=0><code>TEST_P(TS, TC) {
  const std::string str = GetParam();  // 정의된 data set 을 불러옴
  EXPECT_TRUE(foo(str));  // foo(str) 결과가 참인지 평가
}
</code></pre></li></ul></li></ol><ul><li>for 문을 사용 했을 때와 다르게 test 결과 산출물에 어떤 데이터에서 실패가 발생 했는지 명확히 표시된다.<ul><li>테스트 결과 예시<pre tabindex=0><code>[==========] Running 12 tests from 1 test suite.
[----------] Global test environment set-up.
[----------] 12 tests from prefix/test_suite_class
[ RUN      ] prefix/test_suite_class.test_case/0
[       OK ] prefix/test_suite_class.test_case/0 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/1
[       OK ] prefix/test_suite_class.test_case/1 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/2
[       OK ] prefix/test_suite_class.test_case/2 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/3
[       OK ] prefix/test_suite_class.test_case/3 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/4
[       OK ] prefix/test_suite_class.test_case/4 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/5
[       OK ] prefix/test_suite_class.test_case/5 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/6
[       OK ] prefix/test_suite_class.test_case/6 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/7
[       OK ] prefix/test_suite_class.test_case/7 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/8
[       OK ] prefix/test_suite_class.test_case/8 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/9
[       OK ] prefix/test_suite_class.test_case/9 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/10
test11.cpp:31: Failure
Value of: IsPrime(num)
  Actual: false
Expected: true

[  FAILED  ] prefix/test_suite_class.test_case/10, where GetParam() = 4 (0 ms)
[ RUN      ] prefix/test_suite_class.test_case/11
test11.cpp:31: Failure
Value of: IsPrime(num)
  Actual: false
Expected: true
</code></pre></li></ul></li></ul></li><li><p><code>TEST_P</code> 로 정의된 test case 들은 파라미터만 다르게 설정하여 <code>TEST_F</code> 를 여러 개 만든 것과 동일하다.</p><ul><li>파라미터를 순회하며 수행되는 test case 들 사이에도 <code>SetUp</code>, <code>TearDown</code> 함수가 호출된다.</li></ul></li><li><p>사용자 정의 type을 사용할 수도 있다.</p><pre tabindex=0><code>struct InputType {
    int A;
    int B;
}

// test 결과 산출물에서 사용자 정의 type(struct)이 가독성 있는 형태로 출력하기 위한 연산자 재정의
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const InputTypes&amp; data)
{
    return os &lt;&lt; &#34;(&#34; &lt;&lt; data.A &lt;&lt; &#34;,&#34; &lt;&lt; data.B &lt;&lt; &#34;)&#34;;

    // C++ 20 부터 지원하는 형태
#include &lt;format&gt;
    // return os &lt;&lt; std::format(&#34;({},{})&#34;, data.A, data.B);
}

INITIATE_TEST_SUITE_P(prefix, TS,
    testing::Values(
        (1,1) (2,2) (3,3)
));

TEST_P(TS, TC1) {
    const InputType&amp; data = GetParam();
    EXPECT_TRUE(foo(data.A));
}
TEST_P(TS, TC2) {
    const InputType&amp; data = GetParam();
    EXPECT_TRUE(foo(data.B));
}
</code></pre><ul><li>사용자 정의 타입을 사용 할 때는 연산자 재정의를 해 줘야 테스트 결과 산출물에 원하는 형태로 출력이 가능하다.</li></ul></li><li><p>둘 이상의 파라미터를 조합하여 사용하는 경우 <code>testing::Combine</code> 과 <code>testing::ValuesIn</code> 을 사용할 수 있다.</p><ul><li><code>testing::Combine</code> : 주어진 파라미터 (A,B,C&mldr;)으로 구성할 수 있는 모든 조합에 대해 data set 을 구성한다.</li><li><code>testing::ValuesIn</code> : 배열을 파라미터로 받아 data set 으로 구성한다.</li></ul><pre tabindex=0><code>// SUT 에서 정의된 타입
enum Color {BLACK, WHITE, RED, ORANGE, BLUE}

// 테스트에 사용될 데이터
Color colors[] = {Color::BLACK, Color::WHITE};
std::vector&lt;std::string&gt; str = {&#34;black&#34;, &#34;white&#34;};

// 튜플 형태 정의
using InputType = std::tueple&lt;std::string, Color, int&gt;

// data set 구성
INITIATE_TEST_SUITE_P(prefix, TS,
    testing::Combine(
        testing::ValuesIn(colors),
        testing::ValuesIn(str),
        testing::Values(1, 2, 3)  // Values 를 섞어 구성할 수도 있다.
    )
);

TEST_P(TS, TC)
{
    const InputType&amp; data = GetParam();
    // 설정한 데이터 사용
    Color color = std::get&lt;0&gt;(data);
    std::string str = std::get&lt;1&gt;(data);
    int num = std::get&lt;2&gt;(data);
}
</code></pre></li><li><p>한 Test Suite 에 대해 파라미터(<code>INITIATE_TEST_SUITE_P</code>) 를 여러 개 정의하면, 각 파라미터를 독립되게 이어서 진행한다.</p></li><li><p>기타 파라미터 생성 함수</p><ul><li><code>testing::RANGE()</code> : 지정된 범위에 해당하는 숫자로 배열 구성<ul><li><code>testing::RANGE(1,100)</code> : 1~99까지의 수로 구성된 배열 생성<ul><li>[1, 2, 3, .. , 99]</li></ul></li><li><code>testing::RANGE(1,100,2)</code> : 1~99까지 2씩 증가하는 수로 구성된 배열 생성<ul><li>[1, 3, 5, .. , 99]</li></ul></li></ul></li></ul></li></ul><h3 id=test-listener>Test Listener<a hidden class=anchor aria-hidden=true href=#test-listener>#</a></h3><ul><li><p>테스트 과정에서 발생하는 이벤트 들에 대해 특정 작업을 수행해야 할 때, Listener 를 등록하여 처리할 수 있다.</p></li><li><p>Google Test Framework 의 고유 기능으로, xUnit Test Framework 표준 아님</p></li><li><p>Event Listener 생성 방법</p><ul><li><code>testing::TestEventListener</code> : 모든 event 들에 대해 가상함수로 선언된 인터페이스<ul><li>모든 event 에 대해서만 재정의를 해 주어야 선언 가능</li></ul></li><li><code>testing::EmptyTestEventListener</code> : 모든 event 들에 대해 override 형태로 empty 함수로 구현된 인터페이스<ul><li>필요한 event 에 대해서만 재정의를 해 주면 선언 가능</li></ul><pre tabindex=0><code>class MyListener : public testing::EmptyTestEventListener {
public:
    void OnTestSuiteStart(const TestSuite&amp; /*test_suite*/) override
    {
        std::cout &lt;&lt; &#34;START &lt;&lt; std::endl;
    }

    void OnTestSuiteEnd(const TestSuite&amp; /*test_suite*/) override
    {
        std::cout &lt;&lt; &#34;END &lt;&lt; std::endl;
    }
}
</code></pre></li></ul></li><li><p>정의된 Listener 들은 main 함수에서 등록한다.</p><pre tabindex=0><code>int main(int argc, char** argv)
{
    testing::InitGoogleTest(&amp;argc, argv);

    testing::TestEventListeners&amp; litensers = testing::UnitTest::GetInstance()-&gt;listeners();
    litensers.Append(new MyListener);

    // google test framework 에 default 로 설정된 출력을 제거할 수도 있음
    // delete litensers.Release(litensers.default_result_printer());

    return RUN_ALL_TESTS();
}
</code></pre></li></ul><h3 id=test-double-테스트-대역>Test Double (테스트 대역)<a hidden class=anchor aria-hidden=true href=#test-double-테스트-대역>#</a></h3><ul><li><p>테스트 대상 코드가 다른 &ldquo;협력 객체"에 따라 영향을 받을 수 있을 때, &ldquo;협력 객체&rdquo; 를 대체 하기 위한 테스트용 객체를 생성하고, 이를 &ldquo;테스트 대역&rdquo; (test double) 이라 한다.</p></li><li><p>테스트 대역의 역할 : 테스트 환경을 통제</p></li><li><p>테스트 대역 적용 조건 : 제품 코드가 태스트 대역을 적용 할 수 있는 설계</p><ul><li>테스트 대상 코드가 협력 객체와 &ldquo;약한 결합&rdquo; (느슨한 결합) 관계에 있어야 한다.<ul><li>강한 결합 : 구체적인 타입에 의존하여 객체를 참조하는 형태</li><li>약한 결합 : 추상 타입에 의존하여 객체를 참조하는 형태 (abstract class / interface)</li></ul></li></ul></li><li><p>ex) 원본 코드</p><pre tabindex=0><code>class FileSystem {
public:
    bool IsValidFilename(const std::string&amp; name)
    {
        // 현재의 파일 시스템에서 적합한 이름인지 확인합니다.
        return false;  // fasle 반환하는 경우 검증을 위한 코드
    }
};

class Logger {
public:
    // 확장자를 제외한 파일명이 5글자 이상이어야 한다.
    // ex)
    //  file.log =&gt; file  =&gt; X
    // hello.log =&gt; hello =&gt; O
    bool IsValidLogFilename(const std::string&amp; filename)
    {
        //--------- 테스트 대상 코드 영역
        size_t index = filename.find_last_of(&#34;.&#34;);
        std::string name = filename.substr(0, index);
        if (name.size() &lt; 5) {
            return false;
        }
        //--------- 테스트 대상 코드 영역

        FileSystem fs;
        return fs.IsValidFilename(filename);  // 테스트 대상이 아니지만 테스트 결과에 영향을 끼치는 구문
    }
};
</code></pre></li><li><p>ex) SUT 코드를 약한 결합으로 변경하고 test double 적용</p><ol><li><p>SUT 코드에 협력 객체에 대한 인터페이스를 정의</p><pre tabindex=0><code> class IFileSystem {
 public:
     virtual ~IFileSystem() { }

     virtual bool IsValidFilename(const std::string&amp; name) = 0;  // 순수 가상 함수로 정의
 };
</code></pre></li><li><p>SUT 코드에서 협력 객체가 인터페이스를 사용하도록 변경</p><pre tabindex=0><code>class FileSystem : public IFileSystem {
public:
    bool IsValidFilename(const std::string&amp; name) override
    {
       // 현재의 파일 시스템에서 적합한 이름인지 확인합니다.
       return false;  // fasle 반환하는 경우 검증을 위한 코드
    }
};
</code></pre></li><li><p>test code 에서 Test double 용 class 생성</p><pre tabindex=0><code>class TestDoubleFileSystem : public IFileSystem {
public:
    bool IsValidFilename(const std::string&amp; name) override
    {
        return true;  // 무조건 true 반환하도록
    }
};
</code></pre></li><li><p>Dependency Injection (의존성 주입) 으로 협력객체를 test double 로 대체</p><ul><li>class 내부에서 선언하지 않고, 외부에서 선언된 객체를 받아야 한다.<ul><li>생성자 주입 : 협력 객체가 필수적일 때</li><li>method 주입 : 협력 객체가 필수적이지 않을 때</li></ul></li></ul><pre tabindex=0><code>TEST(LoggerTest, IsValidLogFilename_NameLongerThan5Chars_ReturnsTrue)
{
    TestDoubleFileSystem td;  // 3번에서 정의한 class 사용
    Logger logger { &amp;td };  // 의존성 주입. 외부에서 선언하고 Logger 에 전달
    std::string validFilename = &#34;valid.log&#34;;  // 변수 이름에도 가독성 고려

    EXPECT_TRUE(logger.IsValidLogFilename(validFilename))
        &lt;&lt; &#34;확장자를 제외한 파일명이 5글자 이상 판단 실패&#34;;
}
TEST(LoggerTest, IsValidLogFilename_NameShorterThan5Chars_ReturnsFalse)
{
    TestDoubleFileSystem td;
    Logger logger { &amp;td };
    std::string invalidFilename = &#34;bad.log&#34;;

    EXPECT_FALSE(logger.IsValidLogFilename(invalidFilename))
        &lt;&lt; &#34;확장자를 제외한 파일명이 5글자 미만 판단 실패&#34;;
}

// test case 에서 호출되는 IsValidFilename() 은 TestDoubleFileSystem 함수에서 정의된 함수가 호출되기 때문에 true 가 반환된다. 
</code></pre></li></ol></li></ul><h4 id=test-stub>Test Stub<a hidden class=anchor aria-hidden=true href=#test-stub>#</a></h4><ul><li><p>목적 : 다른 Component로 부터의 받은 값(간접 입력)에 의존하는 로직을 독립적으로 검증이 필요할 때</p></li><li><p>방법 : 입력 값을 생성하는 Component 를 test double 로 교체한다.</p></li><li><p>예시 : 현재 시간의 값에 영향을 받는 Clock 이라는 class 에서 값을 받아 사용하는 Scheduler class 의 Alarm 함수 테스트를 위해, Clock 을 대체 할 test double class 를 생성</p><pre tabindex=0><code>class Time {
public:
    virtual ~Time() { }

    virtual std::string GetCurrentTime() const = 0;
};

// 인터페이스 사용하여 구현되어 있어 test double 적용이 용이한 형태
class Clock : public Time {
public:
    std::string GetCurrentTime() const override
    {
        time_t rawTime;
        tm* timeInfo;
        char buffer[128];

        time(&amp;rawTime);
        timeInfo = localtime(&amp;rawTime);

        strftime(buffer, sizeof(buffer), &#34;%H:%M&#34;, timeInfo);

        return std::string { buffer };
    }
};

class Scheduler {
    Time* time;

public:
    Scheduler(Time* p)
        : time { p }
    {
    }

    int Alarm()
    {
        std::string current = time-&gt;GetCurrentTime();  // 다른 component 에서 받은 값에 의존적
        if (current == &#34;00:00&#34;) {
            return 42;
        } else if (current == &#34;10:00&#34;) {
            return 100;
        }

        return 0;
    }
};
</code></pre><ul><li>test stub pattern 을 적용하여 테스트의 독립성 확보<pre tabindex=0><code>// test double class 를 새로 정의
class StubTime : public Time {
    std::string result;

public:
    StubTime(const std::string&amp; r) : result { r }
    {
    }

    std::string GetCurrentTime() const override
    {
        return result;
    }
};

TEST(SchedulerTest, Alarm_00_00)
{
    // Clock clock;
    StubTime clock { &#34;00:00&#34; };  // Clock 객체 대신 StubTime 객체 사용
    Scheduler scheduler { &amp;clock };

    int result = scheduler.Alarm();

    EXPECT_EQ(result, 42) &lt;&lt; &#34;00:00 일때&#34;;
};

TEST(SchedulerTest, Alarm_10_00)
{
    // Clock clock;
    StubTime clock { &#34;10:00&#34; };
    Scheduler scheduler { &amp;clock };

    int result = scheduler.Alarm();

    EXPECT_EQ(result, 100) &lt;&lt; &#34;10:00 일때&#34;;
};
</code></pre></li></ul></li></ul><h4 id=fake-object>Fake Object<a hidden class=anchor aria-hidden=true href=#fake-object>#</a></h4><ul><li>목적 : 협력 객체의 로직이 아직 미구현인 상태라 테스트가 불가능한 상황 해소<ul><li>or 협력 객체가 사용하기 어려운 경우</li><li>or 협력 객체의 동작이 느린 경우</li></ul></li><li>방법 : 동일한 기능을 제공하는 가벼운 test double 을 통해 검증을 수행한다.<ul><li>Test Stub 과 비교했을 때, test stub은 logic이 없지만, fake object 는 가볍더라도 logic 이 포함된다.</li></ul></li><li>예시 : database 기능을 대체할 수 있는 간이 class 를 선언<pre tabindex=0><code>// SUT에 정의된 사용자 정의 타입
class User {
    std::string name;
    int age;

public:
    User(const std::string&amp; s, int n) : name { s }, age { n }

    std::string GetName() const { return name; }
    int GetAge() const { return age; }
};
// 데이터베이스 인터페이스
class IDatabase {
public:
    virtual ~IDatabase() { }

    virtual void SaveUser(const std::string&amp; name, User* user) = 0;
    virtual User* LoadUser(const std::string&amp; name) = 0;
};

// 데이터베이스(미구현) class 를 사용하는 class. 테스트 대상
class Repository {
    IDatabase* database;

public:
    Repository(IDatabase* p)
        : database { p }
    {
    }

    void Save(User* user)
    {
        //...
        database-&gt;SaveUser(user-&gt;GetName(), user);
        //...
    }

    User* Load(const std::string&amp; name)
    {
        // ...
        return database-&gt;LoadUser(name);
    }
};

// 테스트를 위해 생성한 Fake class 
class FakeDatebase : public IDatabase {
    std::map&lt;std::string, User*&gt; data;

public:
    void SaveUser(const std::string&amp; name, User* user) override
    {
        data[name] = user;
    }

    User* LoadUser(const std::string&amp; name) override
    {
        return data[name];
    }
};


// 사용자 지정 타입의 비교를 위해 연산자 재정의
bool operator==(const User&amp; lhs, const User&amp; rhs)
{
    return lhs.GetName() == rhs.GetName() &amp;&amp; lhs.GetAge() == rhs.GetAge();
}
// 사용자 지정 타입의 출력을 위해 연산자 재정의
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const User&amp; user)
{
    retrurn os &lt;&lt; &#34;(&#34; &lt;&lt; user.GetName() &lt;&lt; &#34;,&#34; &lt;&lt; user.GetAge() &lt;&lt; &#34;)&#34;;
}

// 테스트 수행
TEST(RepositoryTest, Save)
{
    FakeDatebase fake;  // Fake class 사용
    Repository repo { &amp;fake };  // 의존성 주입
    std::string testName = &#34;test_name&#34;;
    int testAge = 42;
    User expected { testName, testAge };

    repo.Save(&amp;expected);
    User* actual = repo.Load(testName);

    ASSERT_NE(actual, nullptr);  // null pointer 로 인한 프로그램 에러 방지
    EXPECT_EQ(*actual, expected);
}
</code></pre></li></ul><h4 id=test-spy>Test Spy<a hidden class=anchor aria-hidden=true href=#test-spy>#</a></h4><ul><li>목적: SUT의 함수를 동작 할 때 발생하는 부수 효과를 관찰할 수 없어서 테스트가 어려운 경우<ul><li>특정 함수의 동작 결과를 저장 해 두었다가 나중에 출력 할 수 있는 test double 구현</li></ul></li><li>방법: 목격한 일을 기록 해 두었다가 이후 확인 할 수 있도록 만들어진 테스트 대역<ul><li>다른 component로 부터의 간접 출력을 저장하는 기능 존재</li><li>저장된 간접 출력들로 합불을 판단판단 할 수 있는 기능 존재</li></ul></li><li>예시: Logger 에서 호출되는 Write 함수는 결과를 확인 할 상태가 남지 않는다. DLoggerTarget 을 상속받는 test double 을 생성하여 Write 함수로 전달받은 내용을 저장하고, 나중에 확인 할 수 있도록 하는 로직을 추가한다.<pre tabindex=0><code>enum Level {
    INFO,
    WARN,
    ERROR
};

// 인터페이스
class DLoggerTarget {
public:
    virtual ~DLoggerTarget() { }

    virtual void Write(Level level, const std::string&amp; message) = 0;
};

// 실제 구현체
class FileTarget : public DLoggerTarget {
    // 전달된 내용을 파일에 기록합니다.
};

// 실제 구현체
class NetworkTarget : public DLoggerTarget {
    // 전달된 내용을 네트워크로 전송합니다.
};

// 테스트 필요한 대상
class DLogger {
    std::vector&lt;DLoggerTarget*&gt; targets;

public:
    void AddTarget(DLoggerTarget* p) { targets.push_back(p); }

    void Write(Level level, const std::string&amp; message)
    {
        for (auto e : targets) {
            e-&gt;Write(level, message); // 결과가 남지 않아 테스트 어려움
        }
    }
};

// test double 을 생성
class SpyTarget : public DLoggerTarget {
    std::vector&lt;std::string&gt; history;  // 전달 된 string 을 vector 에 저장

    std::string Concat(Level level, const std::string&amp; message) const
    {
        return message + std::to_string(level);  // 최종 결과를 이어붙여 반환
    }

public:
    void Write(Level level, const std::string&amp; message) override
    {
        // 목격한 일을 기록
        history.push_back(Concat(level, message));
    }

    // 동작 결과를 판단하는 기능
    bool IsReceived(Level level, const std::string&amp; message) const
    {
        return std::find(std::begin(history), std::end(history), Concat(level, message))
            != std::end(history);
    }
};

// test code
TEST(DLoggerTest, Write)
{
    DLogger logger;
    SpyTarget t1, t2;
    logger.AddTarget(&amp;t1);
    logger.AddTarget(&amp;t2);

    logger.Write(INFO, &#34;test_message1&#34;);
    logger.Write(WARN, &#34;test_message2&#34;);

    EXPECT_TRUE(t1.IsReceived(INFO, &#34;test_message1&#34;));  // 테스트 결과 판단
    EXPECT_TRUE(t2.IsReceived(INFO, &#34;test_message1&#34;));
    EXPECT_TRUE(t1.IsReceived(WARN, &#34;test_message2&#34;));
    EXPECT_TRUE(t2.IsReceived(WARN, &#34;test_message2&#34;));
}
</code></pre></li><li>test code 가 SUT code 보다 더 많아지는 딜레마가 발생한다.</li></ul><h4 id=mock-object>Mock Object<a hidden class=anchor aria-hidden=true href=#mock-object>#</a></h4><ul><li><p>목적 : &ldquo;상태기반 검증"이 아닌 &ldquo;행위기반 검증"을 수행</p><ul><li>상태기반 검증 : SUT에 작용을 가한 후 내부 상태 변화를 확인하고 단언문을 통해 정상 동작 여부를 판단</li><li>행위 기반 검증 : SUT 에 작용을 가한 후 함수 호출 여부, 호출 횟수, 호출 인자, 호출 순서 등의 정보를 통해 정상 동작 여부를 판단</li></ul></li><li><p>방법 : Mock Framework 라는 별도의 framework 를 사용하여 구현</p><ul><li>Google Mock 을 활용할 수 있다.<ul><li><a href=./google-mock>Google Mock 사용 방법</a></li></ul></li></ul></li><li><p>Mock 을 사용한 검증은 초창기에는 별도의 테스트로 여겨졌으나, 현재는 단위테스트 수행시 기본적으로 수행하는 추세가 되었다.</p></li><li><p>사용 방법:</p><ul><li>모의 객체를 생성하고, <code>MOCK_METHOD</code> 매크로를 활용하여 테스트 할 함수를 설정한다.<ul><li><code>MOCK_METHOD{인자갯수}(method 이름, method 타입)</code> : MOCK_METHOD 사용 방법</li></ul><pre tabindex=0><code>class MockDLoggerTarget : public DLoggerTarget {
public:
    // void Write(Level level, const std::string&amp; message)
    // 행위 기반 검증을 수행하고자 하는 메소드
    MOCK_METHOD2(Write, void(Level level, const std::string&amp; message));  // mock 함수 생성
};
</code></pre></li><li><code>EXPECT_CALL</code> 매크로를 사용하여 함수가 수행 되어야 한다는 것을 미리 설정 해 둔다. 이후 <code>EXPECT_CALL</code> 로 설정 한 함수가 호출되지 않으면 에러가 발생한다.<ul><li><code>EXPECT_CALL(class 이름, 함수 호출구문)</code> 형태로 사용한다.</li><li>주의 사항: <code>EXPECT_CALL</code> 구문이 <code>ASSERT_</code>, <code>EXPECT_</code> 와 같은 상태기반 검증의 단언문보다 먼저 수행되는 형태가 좋다.</li></ul><pre tabindex=0><code>TEST(DLoggerTest, Write)
{
    // Arrange
    DLogger logger;
    MockDLoggerTarget t1, t2;
    logger.AddTarget(&amp;t1);
    logger.AddTarget(&amp;t2);

    // Assert
    // 행위 기반 검증 단언문 먼저 설정
    EXPECT_CALL(t1, Write(INFO, &#34;test_message1&#34;));
    EXPECT_CALL(t1, Write(WARN, &#34;test_message2&#34;));
    EXPECT_CALL(t2, Write(INFO, &#34;test_message1&#34;));
    EXPECT_CALL(t2, Write(WARN, &#34;test_message2&#34;));

    // Act
    // 상태 기반 검증 단언문
    logger.Write(INFO, &#34;test_message1&#34;);
    logger.Write(WARN, &#34;test_message2&#34;);
}
</code></pre></li></ul></li><li><p>장점 : 행위 검증을 위한 Lobic 작성이 필요 없음</p></li></ul><h2 id=google-mock>Google Mock<a hidden class=anchor aria-hidden=true href=#google-mock>#</a></h2><ul><li>Google Mock 은 행위기반 검증만을 위한 tool 이 아니라, test double 을 위한 tool 로서, test stub, fake object, test spy 등을 google Mock 으로 구현 할 수도 있다.</li></ul><h3 id=설치>설치<a hidden class=anchor aria-hidden=true href=#설치>#</a></h3><ol><li>googletest 소스코드를 다운받으면 <code>googletest/googlemock/src/gmock-all.cc</code> 파일을 include 하여 사용 가능하다.</li><li>google mock 사용에 필요한 소스코드를 컴파일 한다.<ul><li><code>g++ -c ./googletest/googlemock/src/gmock-all.cc -I ./googletest/googlemock/include -I ./googletest/googlemock/ -I ./googletest/googletest/include/ -std=c++14 -O2</code> : gtest-all.o, gmock-all.o 컴파일</li><li>main 함수에서 <code>InitGoogleMock</code> 을 호출하도록 한다.<ul><li><code>googletest/googlemock/src/gmock_main.cc</code> 파일에 있는 main을 활용할 수 있다.</li><li><code>g++ -c -std=c++14 -O2 ./googletest/googlemock/src/gmock_main.cc -I ./googletest/googletest/include -I ./googletest/googlemock/include</code> : gmock-main.o 컴파일</li></ul></li></ul></li><li>라이브러리 생성<ul><li><code>ar rcv libgtest.a gmock-all.o gtest-all.o gmock_main.o</code> : 컴파일 한 목적 파일로 libgtest.a 라이브러리를 생성한다.</li></ul></li><li>소스코드에 헤더 파일을 include 한다.<ul><li><code>#include &lt;gmock/gmock.h></code></li><li>gmock 만 include 하면 gtest 는 자동으로 include 된다.</li></ul></li><li>이후 소스코드 빌드할 떄 아래 스크립트를 사용한다.<pre tabindex=0><code>#!/bin/sh
# file name : build.sh
g++ $1 -I ./googletest/googletest/include/ -I ./googletest/googlemock/include/ -lgtest -L. -std=c++14 -pthread
# -fsanitize=address  # 필요하다면 추가
</code></pre><ul><li>./build.sh FILE_NAME</li></ul></li></ol><h3 id=사용>사용<a hidden class=anchor aria-hidden=true href=#사용>#</a></h3><ul><li><p>Google Test 1.10 이후 <code>MOCK_METHOD{인자갯수}(method name, method type)</code> 형태는 <code>MOCK_METHOD(return type, method name, parameter, 한정자)</code> 형태로 변경됨</p><ul><li>ex)<pre tabindex=0><code>class MyClass {
public:
    void myFunc(int A, std::string B, char* c) = 0; // 원본 가상함수

    virtual std::string func1() const = 0;  // 인자가 없는 형태
    virtual void func2() const noexcept = 0;  // 한정자가 여러개인 형태
    virtual std::pair&lt;bool, int&gt; func3() const = 0;  // 탬플릿 타입을 사용하는 함수
    virtual bool func4(std::map&lt;std::string, int&gt; a, bool b) const = 0;
};

class MockClass : public MyClass {
public:
    // void myFunc(int A, std::string B, char* c) override  // 만들고 싶은 함수 형태
    MOCK_METHOD(void, myFunc, (int A, std::string B, char* c), (override))  // MOCK_METHOD 선언
    // 한정자도 2개 이상 있을 수 있기 때문에 괄호로 묶어준다.

    MOCK_METHOD(std::string, func1, (), (const, override));
    MOCK_METHOD(void, func2, (), (const, noexcept, override));
    MOCK_METHOD((std::pair&lt;bool, int&gt;), func3, (), (const, override));
    MOCK_METHOD(bool, func4, ((std::map&lt;std::string, int&gt;) a, bool b), (const, override));
};
</code></pre><ul><li>override 는 원본에는 없고, 쓰지 않아도 문법상 오류는 없지만, 추가 해 주어야 하는 한정자이다.</li><li>주의사항1: 매크크로 함수의 특성상 &lsquo;,&rsquo; 로 인자를 구분하는데, 탬플릿 타입에 사용되는 &lsquo;,&rsquo; 때문에 파싱 오류가 나지 않도록, 탬플릿 타입은 괄호로 묶어주도록 주의한다.</li></ul></li></ul></li><li><p>SUT 에서 구현된 class 중, 순수 가상함수가 아닌 함수들은 행위기반 검증이 필요한 경우만 선택적으로 <code>MOCK_METHOD</code> 화 시켜주면 된다.</p></li><li><p>주의사항2: <code>MOCK_METHOD</code> 와 동일한 이름의 함수가 부모에 존재한다면, <code>MOCK_METHOD</code> 에 가려져서 mock class 에서 해당 함수의 호출이 불가능하다.</p><ul><li>ex)</li></ul><pre tabindex=0><code>class SUT{
public:
    // 두 개의 버전이 존재
    virtual void func(int a) {}
    virtual void func() {}

};

class MockSUT : public SUT{
public:
    MOCK_METHOD(void, func, (), (override));
    using SUT::func;
};

TEST(TS, TC)
{
    MockSUT m;

    m.func(1);  // `using SUT::func` 구문 없으면 오류 발생. &#39;TEST&#39; 구문 안에서 직접 호출시에만 문제 발생
    m.func();
}
</code></pre><ul><li>탬플릿 기반 인터페이스/추상클래스 도 MOCK_METHOD 적용 가능<ul><li>ex)</li></ul><pre tabindex=0><code>template &lt;typename T&gt;
class SUT {
public:
    virtual ~SUT() { }

    virtual int func1() const { return 0; }
    virtual void func2(const T&amp; data) = 0;
};

template &lt;typename TYPE&gt;
class MockSUT : public SUT&lt;TYPE&gt; {
public:
    MOCK_METHOD(int, func1, (), (const, override));
    MOCK_METHOD(void, func2, (const TYPE&amp; data), (override));
};
</code></pre></li></ul></li><li><p>의존성 주입을 사용하면, 제품 코드를 사용하는 방식 그대로 테스트를 수행할 수 있다.</p><pre tabindex=0><code>// 인터페이스
class IPacketStream {
public:
    virtual ~IPacketStream() { }

    virtual void AppendPacket(Packet* newPacket) = 0;
    virtual const Packet* GetPacket(size_t packetNumber) const = 0;
};

// 협력객체 class
class PacketStream : public IPacketStream {
public:
    void AppendPacket(Packet* newPacket) override
    {
        std::cout &lt;&lt; &#34;AppendPacket&#34; &lt;&lt; std::endl;
    }

    const Packet* GetPacket(size_t packetNumber) const override
    {
        std::cout &lt;&lt; &#34;GetPacket: &#34; &lt;&lt; packetNumber &lt;&lt; std::endl;
        return nullptr;
    }
};

// 인터페이스로 구현된 테스트 필요한 SUT 코드
class PacketReader {
public:
    void ReadPacket(IPacketStream* stream, size_t packetNumber)
    {
        // ...
        stream-&gt;AppendPacket(nullptr);
        stream-&gt;GetPacket(packetNumber);
    }
};
// 협력객체를 대체할 테스트용 Mock class
class MockPacketStream : public IPacketStream {
public:
    // void AppendPacket(Packet* newPacket) override
    MOCK_METHOD(void, AppendPacket, (Packet * newPacket), (override));

    // const Packet* GetPacket(size_t packetNumber) const override
    MOCK_METHOD(const Packet*, GetPacket, (size_t packetNumber), (const, override));
};
</code></pre></li><li><p>C++에서는 명시적 인터페이스 외 암묵적 인터페이스를 통해 의존성 주입 설계를 수행할 수 있다.</p><ul><li>C++ 의 탬플릿 기능을 활용하면 인터페이스를 따로 정의하지 않고 그 기능을 대체 할 수 있다.</li></ul><pre tabindex=0><code>class PacketReader {
public:
    template &lt;typename IPacketStream&gt;  // 이 구문을 추가해 줌으로서 인터페이스를 구현한 것과 동일한 효과
    void ReadPacket(IPacketStream* stream, size_t packetNumber)
    {
        // ...
        stream-&gt;AppendPacket(nullptr);
        stream-&gt;GetPacket(packetNumber);
    }
};
</code></pre><ul><li>Policy Based Design (단위 전략) : 탬플릿 기반으로 정책을 컴파일 시간에 교체 가능</li><li>장점 : 가상함수 기반이 아니기 때문에 inline 최적화가 가능하다.</li><li>단점 : 실행 시간에 정책 교체가 불가능하다. C++에 한정하여 적용 가능하다.</li></ul></li><li><p>Mock 의 종류</p><ol><li>NaggyMock<ul><li>Google Mock 의 기본 타입은 NaggyMock 이다.</li><li><code>MOCK_METHOD</code> 를 생성하고, <code>EXPECT_CALL</code> 로 감시 처리 하지 않았지만 test case 수행 결과 해당 함수가 호출이 된다면 실행 결과에 warning 메시지를 출력시킨다. 실행 결과에는 영향을 주지는 않는다.</li></ul></li><li>NiceMock<ul><li><code>using testing::NiceMock</code> 구문을 추가하고 <code>NiceMock&lt;MockSUT> mock</code> 으로 선언한다.</li><li>NaggyMock 을 사용 할 때 warning 메시지를 띄우는 경우, <code>NiceMock</code> 을 사용하면 메시지가 출력되지 않는다.</li><li>행위기반 검증이 아닌 다른 목적으로 사용하는 경우 <code>NiceMock</code> 을 사용할 수 있다.</li></ul></li><li>StrictMock<ul><li><code>using testing::StrictMock</code> 구문을 추가하고 <code>StrictMock&lt;MockSUT> mock</code> 으로 선언한다.</li><li>NaggyMock 을 사용 할 때 warning 메시지를 띄우는 case 에 error 를 발생시킨다.</li><li>테스트를 통과하는 기준이 높아져서 테스트 비용이 증가할 수 있으므로 주의해서 사용해야 한다.</li></ul></li></ol></li><li><p>Delegating</p><ul><li><p>주의사항3: <code>MOCK_METHOD</code> 로 만들어진 함수는 return 값이 달라지게 된다. (0을 반환)</p></li><li><p>Google Test Framework 에는 <code>MOCK_METHOD</code> 의 반환값을 제어할 수 있는 기능을 제공하며, 이를 Delegating 이라 한다.</p></li><li><p><code>ON_CALL</code> 매크로를 활용하면 Delegating 설정을 할 수 있다.</p><pre tabindex=0><code>  class SUT {
  public:
      void func(int a, int b) { return 10;}
  };

  class MockSUT : public SUT{
  public:
      MOCK_METHOD(void, func, (int a, int b), (override));
  };

  using testing::Return;
  TEST(TS, TC) {
      MockSUT m;

      ON_CALL(m, func(1, 2)).WillByDefault(Return(10));  // func(1, 2) 결과가 10 반환

      EXPECT_CALL(m, func(1, 2));


      m.func(1,2);  // 호출은 a, b, c 모두 사용
  }
</code></pre><ul><li><p>아래와 같은 방식으로도 사용 할 수 있다.</p><ul><li>원본 함수: <code>Add(int a, int b) { return a + b; }</code></li><li><code>ON_CALL(mock, Add(10, 20)).WillByDefault(Return(30));</code> : Add(10,20) 은 30 을 반환하도록 설정</li><li><code>ON_CALL(mock, Add).WillByDefault(Return(30));</code> : Add 함수는 인자에 상관없이 30을 반환하도록 설정</li><li><code>ON_CALL(mock, Add).WillByDefault(&amp;add);</code> Add 함수는 add라고 정의된 함수의 동작을 따라서 반환값 반환(단, Add와 add 의 함수 형태는 동일)<ul><li><code>int add(int a, int b) { return a + b; }</code></li></ul></li><li><code>ON_CALL(mock, Add).WillByDefault(Adder {});</code> : 구조체의 멤버 함수 사용<ul><li><code>struct Adder {int operator()(int a, int b) const { return a + b; }};</code></li></ul></li><li><code>ON_CALL(mock, Add).WillByDefault([](int a, int b) { return a + b; });</code> : 람다 표현식으로 Add 의 반환값 설정</li></ul></li><li><p><code>ON_CALL</code> 명령은 test case에 작성해도 되지만, mock class 생성자에 선언해도 된다.</p><pre tabindex=0><code>// mock class 선언
class MockDatabase : public IDatabase {
    std::map&lt;std::string, User*&gt; data;

public:
    // 생성자 선언
    MockDatabase()
    {
        // 생성자에서 ON_CALL 설정, ON_CALL 구문 중복 방지
        ON_CALL(*this, SaveUser).WillByDefault([this](const std::string&amp; name, User* user) {
            data[name] = user;
        });
        ON_CALL(*this, LoadUser).WillByDefault([this](const std::string&amp; name) {
            return data[name];
        });
    }

    // void SaveUser(const std::string&amp; name, User* user) override
    MOCK_METHOD(void, SaveUser, (const std::string&amp; name, User* user), (override));

    // User* LoadUser(const std::string&amp; name) override
    MOCK_METHOD(User*, LoadUser, (const std::string&amp; name), (override));
};
</code></pre></li></ul></li><li><p>Delegating 기능을 사용하여 Test Stub, Fake Object, Test Spy 를 모두 구현할 수 있다.</p></li><li><p>EXPECT_CALL 과 ON_CALL 을 동시에 사용할 경우 EXPECT_CALL 만 사용해서 Delegation 을 사용 할 수 있다.</p><ul><li><code>WillOnce</code>, <code>WillRepeatedly</code> 구문을 추가하면 EXPECT_CALL 구문에 ON_CALL 내용을 적용 할 수 있다.<ul><li><code>WillOnce</code> 는 여러 번 호출 가능하며, queue 에 쌓이듯이 순서대로 적용된다.</li><li><code>WillOnce</code> 사용 횟수만큼 함수가 호출되지 않으면 테스트 결과는 실패로 판단된다.</li><li><code>WillOnce()</code> : 인자로 들어간 <code>ON_CALL</code> 구문을 지정된 함수가 호출 될 떄 한 번만 적용</li><li><code>WillRepeatedly()</code> : 인자로 들어간 <code>ON_CALL</code> 구문을 함수 호출마다 적용<ul><li>한 번만 사용 가능</li><li><code>WillOnce</code> 보다 나중에 사용 가능</li></ul></li></ul></li></ul><pre tabindex=0><code>// case 1
EXPECT_CALL(mock, func(10,20)).WillOnce(Return(30));  // 아래 두 구문을 한번에 표현 한 것이다.
/*
    ON_CALL(mock, func(10,20)).WillByDefault(Return(30));
    EXPECT_CALL(mock, func(10,20));
*/
mock.func(10,20); // 30 반환

// case 2
EXPECT_CALL(mock, func(10,20))
    .WillOnce(Return(30));
    .WillOnce(Return(40));
    .WillOnce(Return(50));
// 아래 구문을 한 번에 표현 한 것이다.
/*
    ON_CALL(mock, func(10,20)).WillByDefault(Return(30));
    EXPECT_CALL(mock, func(10,20)).Times(3);  // WillOnce 세번 사용
*/

mock.func(10,20); // 30 반환
mock.func(10,20); // 40 반환
mock.func(10,20); // 50 반환

// case 3
EXPECT_CALL(mock, func(10,20))
    .WillOnce(Return(30));
    .WillOnce(Return(40));
    .WillRepeatedly(Return(50));
// 아래 구문을 한 번에 표현 한 것이다.
/*
    ON_CALL(mock, func(10,20)).WillByDefault(Return(30));
    EXPECT_CALL(mock, func(10,20)).Times(AtLeast(2));  // WillOnce 두번 사용 이후 willRepeatedly 사용
*/

mock.func(10,20); // 30 반환
mock.func(10,20); // 40 반환
mock.func(10,20); // 50 반환
mock.func(10,20); // 50 반환
</code></pre></li></ul></li></ul><ol><li><p>함수 호출 여부 판단</p><ul><li><code>EXPECT_CALL</code> 을 사용하여 호출 여부를 확인할 수 있다.</li><li><code>EXPECT_CALL</code> 은 별도의 오류 메시지를 지정할 수 있는 기능을 제공하지 않는다.</li><li>감시 대상 함수가 호출되기 전 설정이 되어 있어야 한다.</li><li>mock 객체가 파괴되는 시점에 <code>EXPECT_CALL</code> 로 감시를 선언한 함수들의 결과를 판단한다.<ul><li>만약 mock 을 &rsquo;new&rsquo; 를 통해 생성했다면, 명시적으로 &lsquo;delete&rsquo; 를 해 줘야 정상 동작을 한다.</li><li>mock 을 지역변수로 선언한다면 함수 종료시 자동으로 해제되기 때문에 정상 동작 할 것이다.</li></ul></li></ul></li><li><p>함수 호출 인자 판단</p><ul><li><p>ex1) EXPECT_CALL(mock, func(1,2)) : func(1,2) 형태로 함수가 호출되어야 OK</p></li><li><p>ex2) EXPECT_CALL(mock, func) : 어떤 인자로든 func 함수가 호출 되기만 하면 OK</p></li><li><p>특정 인자만 감시하려면 <code>Mock 간략화</code> 기능을 사용한다.</p><ul><li><code>Mock 간략화</code> : 함수의 특정 인자에 대해서만 검증을 수행하고 싶을 때 사용하는 방식<pre tabindex=0><code>class SUT{
public:
    void func(int a, int b, int c) {}
};

class MockSUT : public SUT{
public:
    // parent 함수 override
    void func(int a, int b, int c) override {
        func(int a); // MOCK_METHOD 로 생성한 함수 호출
    }

    MOCK_METHOD(void, func, (int a), (override));  // void func(int a) override {} 형태의 함수를 생성함

    // -&gt; 
};

TEST(TS, TC) {
    MockSUT m;
    EXPECT_CALL(m, func(1));  // 인자 a 에 대해서만 검증
    m.func(1,2,3);  // 호출은 a, b, c 모두 사용
}
</code></pre></li></ul></li><li><p>호출 인자에 조건을 설정하려면 <code>Matcher</code> 를 사용할 수 있다.</p><pre tabindex=0><code>using testing::Ge;
using testing::Eq;
using testing::Matcher;
Matcher&lt;int&gt; arg0 = Ge(10); // 10보다 커야함
Matcher&lt;int&gt; arg1 = Eq(20); // 20보다 작아야함
EXPECT_CALL(mock, func(arg0, arg1));  // arg0은 10보다 작고, arg1은 20보다 커야 성공
</code></pre><ul><li>논리연산<ul><li><code>testing::Eq</code> : ==</li><li><code>testing::Ne</code> : !=</li><li><code>testing::Ge</code> : >=</li><li><code>testing::Gt</code> : ></li><li><code>testing::Le</code> : &lt;=</li><li><code>testing::Lt</code> : &lt;</li><li><code>testing::_</code> : 조건 없음(anything matcher)</li><li>Matcher의 논리적 긱준을 and/or 조건으로 묶어서 사용할 수 있다.<pre tabindex=0><code>using testing::Matcher;
using testing::Gt;
using testing::Lt;
using testing::_;
using testing::AllOf; // and
using testing::AnyOf; // or

MyMockClass mock;  // 필요한 mock class 정의 필요
Matcher&lt;int&gt; arg0 = AllOf(Gt(10), Lt(20)); // 10 초과 &amp;&amp; 20 미만
Matcher&lt;int&gt; arg1 = AnyOf(Gt(20), Lt(10)); // 10 미만 || 20 초과
EXPECT_CALL(mock, func(arg0, arg1, _ )).Times(3);

mock.func(15,25, 128);
mock.func(11,0, 256);
mock.func(19,21, 512);
</code></pre></li></ul></li></ul></li><li><p><code>Mock 간략화</code> 대신 anything matcher 를 사용화 할 수도 있다.</p><pre tabindex=0><code>using testing::_;
EXPECT_CALL(mock, func(_, &#34;arg&#34;, _)); // 첫 번째, 두 번쨰 인자 신경 안쓰고 두 번쨰 인자에 &#34;arg&#34; 문자열이 오는지 판단
</code></pre></li><li><p>Matcher 적용 심화</p><ul><li>다중 인자 Matcher 적용 방법</li></ul><pre tabindex=0><code>using testing::ElementsAreArray;

// 배열 형태로 구성
Matcher&lt;int&gt; args[] = { Eq(1), Eq(2), Eq(3) }
EXPECT_CALL(moc, func(ElementsAreArray(args)));

// 단순 열거 형태로 사용
using testing::ElementsAre;
EXPECT_CALL(moc, func(ElementsAre(Eq(1), Eq(2), Eq(3))));

// 인자 순서 상관없이 모든 조건이 매칭될 수 있는지 체크
using testing::UnorderedElementsAre;
EXPECT_CALL(moc, func(ElementsAre(Eq(1), Eq(2), Eq(3))));
</code></pre><ul><li><code>testing::HasSubstr</code> : 문자열 포함 여부 체크</li><li><code>testing::ContainsRegex</code> : 정규표현식을 만족하는지 체크</li><li><a href=https://google.github.io/googletest/reference/matchers.html>Matcher Document</a></li></ul></li></ul></li><li><p>함수 호출 횟수 판단</p><ul><li><code>EXPECT_CALL(mock, func).Times(n)</code> : &ldquo;mock&rdquo; class 의 함수 &lsquo;func&rsquo; 가 &rsquo;n&rsquo;번 호출되어야 성공<ul><li>Times를 지정하지 않은 경우에는 기본적으로 <code>.Times(1)</code> 이 생략된 형태</li></ul></li><li><code>EXPECT_CALL(mock, func).Times(AtLeast(n))</code> : &ldquo;mock&rdquo; class 의 함수 &lsquo;func&rsquo; 가 최소 n번 이상 호출되어야 성공</li><li><code>EXPECT_CALL(mock, func).Times(AtMost(n))</code> : &ldquo;mock&rdquo; class 의 함수 &lsquo;func&rsquo; 가 최대 n번 이하 호출되어야 성공</li><li><code>EXPECT_CALL(mock, func).Times(Between(n, m))</code> : &ldquo;mock&rdquo; class 의 함수 &lsquo;func&rsquo; 가 n 이상 m 이하 호출되어야 성공<ul><li><code>Cardinality</code> 개념을 적용하여 호출 횟수를 범위로 표현</li><li><code>using testing::AtLeast;</code>, <code>using testing::AtMost;</code>, <code>using testing::Between;</code> 코드 추가 필요</li></ul></li></ul></li><li><p>함수 호출 순서 판단</p><ul><li>Google Mock 에서는 기본적으로 함수 호출 순서는 검증 대상에 포함되지 않는다.</li><li><code>testing::InSequence</code> 객체를 활용하여 함수 호출 순서를 검증할 수 있다.<ul><li>test code 에 InSequence 객체를 선언하면 해당 test case 에서는 모든 함수가 <code>EXPECT_CALL</code> 을 선언한 순서대로 호출되어야 테스트 결과가 성공으로 판단된다.<pre tabindex=0><code>Test(TS, TC) {
    InSequence seq;  // 선언하고, 사용하지 않으면 자동으로 모든 EXPECT_CALL 에 적용됨
    MyMock mock;

    EXPECT_CALL(mock, func1);
    EXPECT_CALL(mock, func2);
    EXPECT_CALL(mock, func3);
    // func1 -&gt; func2 -&gt; func3 순서대로 호출이 되어야 함

    mock.func1();
    mock.func3();  // 함수 호출 순서가 달라서 실패
    mock.func2();
}
</code></pre></li><li>특정 함수들 간의 순서만 확인하고 싶을 때 <code>EXPECT_CALL().InSequence()</code> 구문을 사용한다.<pre tabindex=0><code>Test(TS, TC) {
    InSequence seq1, seq2;  // 두 개의 순서 선언
    MyMock mock;

    // InSequence 구문으로 명시적으로 seq 객체들을 사용하면, 사용한 함수에만 sequence 적용됨
    EXPECT_CALL(mock, func1).InSequence(seq1, seq2);
    EXPECT_CALL(mock, func2).InSequence(seq1);
    EXPECT_CALL(mock, func3).InSequence(seq2);
    EXPECT_CALL(mock, func4)  // 순서에 상관없이 아무때나 호출되어도 되는 함수
    // func1 -&gt; func2 순서 보장 필요
    // func1 -&gt; func3 순서 보장 필요

    mock.func4();  // 순서 제약 없는 함수
    mock.func1();  // 순서 이상 없음
    mock.func3();  // 순서 이상 없음
    mock.func2();  // 순서 이상 없음
    mock.func4();  // 순서 제약 없는 함수
}
</code></pre></li></ul></li></ul></li></ol><ul><li>HamCrest Matcher<ul><li>Google Mock 의 <code>Matcher</code> 는 HamCrest 라이브러리에 기반하며, 상태기반 검증에서 Matcher 를 활용할 수 있다.</li><li><code>ASSERT_THAT</code>, <code>EXPECT_THAT</code> 매크로 함수는 인자로 matcher 구문을 적용하여 검증할 수 있다.<pre tabindex=0><code>EXPECT_THAT(myClass.getName(), testing::StartsWith(&#34;K&#34;)) &lt;&lt; &#34;name doesn&#39;t start with K&#34;; // 함수 결과가 &#34;K&#34; 로 시작하는 string
</code></pre></li><li><a href=https://google.github.io/googletest/reference/matchers.html>Matcher Document</a></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://aswinblue.github.io/Blog/tags/c++/>c++</a></li><li><a href=https://aswinblue.github.io/Blog/tags/test/>test</a></li><li><a href=https://aswinblue.github.io/Blog/tags/unit-test/>unit test</a></li><li><a href=https://aswinblue.github.io/Blog/tags/google-test-framework/>google test framework</a></li></ul><nav class=paginav><a class=prev href=https://aswinblue.github.io/Blog/post/webhacking/http/><span class=title>« Prev</span><br><span>HTTP</span></a>
<a class=next href=https://aswinblue.github.io/Blog/post/windowapp/window_programming/><span class=title>Next »</span><br><span>Window_programming</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on twitter" href="https://twitter.com/intent/tweet/?text=Unit%20Test&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f&amp;hashtags=C%2b%2b%2ctest%2cunittest%2cgoogletestframework"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f&amp;title=Unit%20Test&amp;summary=Unit%20Test&amp;source=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f&title=Unit%20Test"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on whatsapp" href="https://api.whatsapp.com/send?text=Unit%20Test%20-%20https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Unit Test on telegram" href="https://telegram.me/share/url?text=Unit%20Test&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fc%2b%2b%2funit_test%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><div class=auto-hide-div><ins class=kakao_ad_area style=display:none;position:fixed data-ad-unit=DAN-17Lk24lxFVgxtePU data-ad-width=160 data-ad-height=auto></ins></div><script type=text/javascript src=//t1.daumcdn.net/kas/static/ba.min.js async></script></div><footer class=footer><span>&copy; 2025 <a href=https://aswinblue.github.io/Blog>AswinBlue</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>