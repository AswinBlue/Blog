<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.87.0" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>React basic&nbsp;&ndash;&nbsp;AsWindBlew</title><link rel="stylesheet" href="/css/core.min.df05809cfa75ea0a430dc942a79e54236823f6be194b5bc34f0c64744ba5a1b55f91020ad551b34b8af7f2ebee758cc8.css" integrity="sha384-3wWAnPp16gpDDclCp55UI2gj9r4ZS1vDTwxkdEulobVfkQIK1VGzS4r38uvudYzI"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="React basic" /><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2984318617287323"
     crossorigin="anonymous"></script>
<body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><span class="site name">AsWindBlew</span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/categories/">Categories</a><a class="nav item" href="/tags/">Tags</a><a class="nav item" href="/about/">About</a><a class="nav item" href="https://gohugo%2eio/"target="_blank">Hugo</a></nav></div></span></div><div class="site slogan"><span class="title">published by AswinBlue</span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">React basic</h1><p class="article date">Aug 23, 2021<span class="reading-time"> • 18 minutes to read</span></p></section><article class="article markdown-body"><h1 id="react-basic">React basic</h1>
<h2 id="개발환경-설치-및-실행">개발환경 설치 및 실행</h2>
<ol>
<li>node.js 로 만들어진 create-react-app 툴을 이용하면 손쉽게 react 앱을 생성할 수 있다.</li>
</ol>
<ul>
<li>npm을 설치하고 아래 명령어를 수행하여 create-react-app을 설치한다.
<code>npm install -g create-react-app</code></li>
</ul>
<ol start="2">
<li>원하는 경로에 들어가 프로젝트를 생성한다.</li>
</ol>
<ul>
<li><code>create-react-app &lt;NAME&gt;</code> : NAME 경로에 프로젝트 생성</li>
<li>주의 : 프로젝트가 생성되는 폴더명은 대문자를 사용할 수 없다.</li>
</ul>
<ol start="3">
<li>실행</li>
</ol>
<ul>
<li><code>npm run start</code> 를 수행하면 <code>localhost:3000</code>에서 웹페이지를 퍼블리싱한다.</li>
</ul>
<h3 id="기본-설정">기본 설정</h3>
<ol>
<li>실행 포트</li>
</ol>
<ul>
<li><code>package.json</code> 파일에서 <code>&quot;proxy&quot;: &quot;http://localhost:3000/&quot;</code> 과 같이 입력하면 실행시 포트를 3000으로 설정할 수 있다.</li>
</ul>
<h2 id="기본-구조">기본 구조</h2>
<ol>
<li>/public/index.html 에서 기본 화면 구성</li>
</ol>
<ul>
<li>&lsquo;root&rsquo; 이름으로 된 division이 있는데, 이 division에 대한 설정은 javascript로 정의되어있다.</li>
</ul>
<ol start="2">
<li>src 경로에 javascript파일들 구성</li>
</ol>
<ul>
<li>&lsquo;index.js&rsquo; 에 메인 화면에 사용된 객체가 정의되어 있다. 아래 내용은 id가 &lsquo;root&rsquo; 인 division에 &lsquo;App&rsquo;을 적용하겠다는 의미이다.</li>
</ul>
<pre><code>ReactDOM.render(
  &lt;React.StrictMode&gt;
    &lt;App /&gt;
  &lt;/React.StrictMode&gt;,
  document.getElementById('root')
);
</code></pre><ul>
<li>&lsquo;index.js&rsquo;에서 <code>&lt;App/&gt;</code> 라 되어있는 사용자 정의 태그를 생성했는데, <code>App</code>은 &lsquo;App.js&rsquo;에 정의되어 있고, &lsquo;index.js&rsquo;에서 &lsquo;App.js&rsquo;를 참조한다.</li>
<li>&lsquo;App.js&rsquo;에서 선언된 &lsquo;App&rsquo; 이라는 이름의 함수가 반환하는 값이 &lsquo;App&rsquo;태그에 치환된다고 보면 된다.</li>
<li>&lsquo;App&rsquo;이 함수가 아니라 class로 정의되어 있다면 &lsquo;App&rsquo; class의 &lsquo;render()&rsquo; 함수의 리턴값이 &lsquo;App&rsquo;태그로 치환된다.</li>
<li>리턴값은 무조건 특정 태그 안에 들어가 있어야 한다. <div>태그로 감싸주도록 한다.</li>
</ul>
<ol start="3">
<li>src경로에 css파일 구성</li>
</ol>
<ul>
<li>
<table>
<thead>
<tr>
<th>index.css에서 css설정 구성</th>
</tr>
</thead>
</table>
</li>
</ul>
<h2 id="배포">배포</h2>
<ul>
<li><code>npm run start</code>로 &lsquo;create-react-app&rsquo;으로 만든 앱을 실행시킬 수는 있지만, 이는 개발자용 실행 방식이다.</li>
<li>웹 브라우저에서 페이지에 접속하고 다운로드받은 용량을 확인해보면 아무 기능이 없어도 MB단위가 다운받아짐을 확인할 수 있다.</li>
<li>이러한 상태로 배포를 하면 효율 및 보안 관점에서 적합하지 않다.</li>
<li><code>npm run build</code> 명령어를 수행하면 &lsquo;build&rsquo;라는 새로운 디렉터리와 데이터들이 생성된다.</li>
<li>&lsquo;build&rsquo; 안에 있는 파일들은 공백 등을 제거하여 용량 및 보안에 최적화된 상태로 제공된다.</li>
<li>배포시에는 &lsquo;build&rsquo;디렉터리 안의 내용을 사용하면 된다. 웹서버의 최상위 디렉터리를 &lsquo;build&rsquo;로 설정하면 된다.</li>
<li><code>npm install serve</code> 명령어로 serve 툴을 설치한다. serve는 웹서버를 실행시키는 도구이다.</li>
<li><code>serve -s build</code> 명령어로 &lsquo;build&rsquo; 디렉터리를 root 디렉터리로 웹서버를 실행한다.</li>
<li>보통은 이렇게 일일이 작업을 수행하지 않고, <code>npm run deploy</code> 명령으로 package.json 파일에 기록된 설정대로 배포 작업을 자동화시킨다.</li>
</ul>
<h3 id="github에-배포">github에 배포</h3>
<ol>
<li>create-react-app으로 프로젝트 생성 : <code>create-react-app &lt;NAME&gt;</code></li>
<li>gh-pages 설치(이미 설치시 생략가능) : <code>npm install -g gh-pages</code></li>
<li>git hub에서 원하는 이름으로 repository 생성( 이후 {repo-name} 로 지칭)</li>
</ol>
<ul>
<li>생성된 git repository와 react 폴더 연동한다.</li>
<li><code>git init</code></li>
<li><code>git remote add origin {your-repository-url}</code></li>
</ul>
<ol start="4">
<li>package.json파일 수정 ({username}은 github 계정 이름)</li>
</ol>
<ul>
<li>&ldquo;homepage&rdquo; : &ldquo;http://{username}.github.io/{repo-name}&rdquo;</li>
<li>&ldquo;scripts&rdquo;: {&ldquo;predeploy&rdquo;: &ldquo;npm run build&rdquo;, &ldquo;deploy&rdquo;: &ldquo;gh-pages -d build&rdquo;}</li>
</ul>
<ol start="5">
<li>배포를 실행한다. <code>npm run deploy</code></li>
</ol>
<ul>
<li>gh-pages 라는 branch를 자동으로 생성하고, package.json에 설정한 &lsquo;homepage&rsquo; 주소에 react 페이지가 업로드된 것을 볼 수 있다.</li>
</ul>
<h2 id="문법">문법</h2>
<h3 id="주석">주석</h3>
<ul>
<li>React 는 react code(typescript)와 JSX(xml) 코드가 있다.</li>
<li>typescript에서는 &lsquo;//&rsquo; 혹은 &lsquo;/* */&rsquo; 로 주석을 사용한다.</li>
<li>JSX에서는 &lsquo;{/* */}&rsquo; 로 주석을 사용한다.</li>
</ul>
<h3 id="함수">함수</h3>
<ol>
<li>일반 함수</li>
</ol>
<ul>
<li>javascript와 동일하게 선언 가능하다.</li>
</ul>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
        &lt;a href=&quot;/&quot; onClick={ function(e) {
          e.preventDefault();
          this.props.onChangePage();  // 상위 컴퍼넌트로 부터 받은 함수 실행
        }
		&lt;/div&gt;
	);
</code></pre><ol start="2">
<li>arrow 함수</li>
</ol>
<ul>
<li><code>FUNCTION_NAME = (VARIABLES) =&gt; { BODY }</code> 형태로 이루어져 있다.</li>
<li>VARIABLES는 &lsquo;,&lsquo;로 나누어져 두개 이상의 인자를 선언할 수 있고, BODY에서 사용될 수 있다.</li>
<li>위 함수를 호출하려면 <code>FUNCTION_NAME(VARIABLES)</code> 형태로 호출 가능하다.</li>
</ul>
<pre><code>highlightSquares = i =&gt; {
  if (this.props.winningSquares.length &gt; 0) {
    if (this.props.winningSquares.indexOf(i) &gt; -1) {
      return &quot;square winningSquares&quot;;
    } else {
      return &quot;square&quot;;
    }
  } else {
    return &quot;square&quot;;
  }
};
</code></pre><h3 id="변수">변수</h3>
<ul>
<li>hoisting : javascript에서는 변수를 scope(함수 혹은 블록)의 가장 위로 끌어올려서, 먼저 선언된것처럼 인식하는 기능이 있다.</li>
</ul>
<ol>
<li>var</li>
</ol>
<ul>
<li>var는 function-scoped 변수이다. 함수가 끝나기까지 해당 변수는 유지된다. (hoisting)</li>
<li>var를 block-scoped로 낮추기 위해서는 IIFE, &lsquo;use strict&rsquo; 등의 방법을 사용할 수도 있지만 let으로 선언하는게 빠르다.</li>
</ul>
<pre><code>function TEST() {
  for (var i = 0; i &lt; 10; i++) {
    console.log('i: ', i); // 정상출력
  }
  console.log('i: ', i); // 정상출력
}
console.log('i: ', i); // 오류
</code></pre><ul>
<li>동일한 이름의 변수를 재선언할 수 있고, hoisting에 의해 나중에 선언한 변수를 먼저 사용할수도 있다. (오류를 일으키기 좋은 허용이다)</li>
</ul>
<pre><code>var A = 1
var A = 2 // 가능

str='abcd' // 가능
var str
</code></pre><ol start="2">
<li>let</li>
</ol>
<ul>
<li>es2015에서 추가된 문법</li>
<li>재선언 불가능</li>
<li>hoisting 동작 안함</li>
</ul>
<pre><code>let A = 1
let A = 2 // 불가능
A = 3 // 가능

str='abcd' // 불가능
let str
</code></pre><ol start="3">
<li>const</li>
</ol>
<ul>
<li>es2015에서 추가</li>
<li>선언과 동시에 값 할당 필요, 재정의 불가능</li>
<li>hoisting 동작 안함</li>
</ul>
<pre><code>const A = 1
const A = 2 // 불가능
A = 3 // 불가능

str='abcd' // 불가능
const str // 불가능
</code></pre><ol start="4">
<li>선언없이 정의</li>
</ol>
<ul>
<li>아무 타입을 붙이지 않고 선언하면 전역변수로 선언된다.</li>
</ul>
<pre><code>str='12345'
A=5
</code></pre><h4 id="string">string</h4>
<ul>
<li>문자열을 담는 변수로, 아래와 같은 함수들을 지원한다.</li>
<li>contains(str) : 문자열 내에 주어진 문자열(str)이 포함되었는지 확인, 결과를 반환</li>
</ul>
<h3 id="배열">배열</h3>
<ul>
<li>배열은 <code>arr=[1, 2, 3]</code> 과 같은 형태로 선언한다. <code>arr=[,,,]</code>과 같이 크기3(쉼표개수)의 배열 선언도 가능하지만, 배열의 요소는 undefined로 정의된다. <code>arr = new Array(1,2,3)</code>로 선언도 가능하다.</li>
<li>배열의 길이는 <code>arr.length</code> 로 추출 가능하다.</li>
<li>좌항에 배열 형태를 두어 배열의 요소를 각각 정의할 수 있다. <code> [a, b, c] = [1, 2, 3]</code> 이때, 일부 값을 무시할 수 있다. <code>[a, , c] = [1, 2, 3]</code></li>
<li>전개 연산자(&rsquo;&hellip;')을 이용하여 나머지 개체들을 통틀어 지정할 수 있다. <code>[a, b, ...c] = [1, 2, 3, 4, 5] // a = 1, b = 2, c = [3, 4, 5]</code></li>
<li>전개 연산자 이후 다른 변수가 오면 오류가 난다. <code>[a, b, ...c, d] = [1,2,3,4,5] // 오류</code></li>
<li>선언된 변수를 전개연산자로 다른 변수에 넣을수도 있다.</li>
<li><code>ARRAY.indexOf(ITEM)</code> : ARRAY 배열안의 ITEM의 index를 반환한다.</li>
</ul>
<pre><code>var A = [1, 2, 3, 4, 5]
var B = [...A] // B = [1, 2, 3, 4, 5]
</code></pre><h4 id="반복순회">반복(순회)</h4>
<ul>
<li>배열 내용을 순회하는 방법은 다음과 같다.</li>
</ul>
<ol>
<li>map 함수</li>
</ol>
<pre><code>var A = [1,2,3]
A.map((a) =&gt; {
  // 원하는 동작을 입력하면 된다.
})
A.map(Math.sqrt) // lambda함수 외 일반함수를 넣어도 된다.
</code></pre><ol start="2">
<li>for-of</li>
</ol>
<pre><code>var A = [1,2,3]
for (var a of A) {
  // java의 for( : ) 와 같다
}
</code></pre><ul>
<li>객체의 배열도 동일한 방법으로 순회가 가능하다. 다만 비구조화(destructing)가 포함된다.</li>
</ul>
<pre><code>var B = [{a:1, b:2, c:3}, {a:4, b:5, c:6}]
B.map({a,b,c} =&gt; {
  // 원하는 동작 수행
})
for (var {a:aa, b:bb, c:cc} of B) {
  // key가 마음에들지 않으면 재정의도 가능하다.
}
</code></pre><h4 id="비교">비교</h4>
<ul>
<li>filter 함수를 이용하여 조건에 맞는 요소만 선택 가능하다.</li>
</ul>
<pre><code>var a = [1,2,3,4,5,6,7]
var b = a.filter(i =&gt; i &lt; 4); // b = [1,2,3]
</code></pre><h3 id="객체">객체</h3>
<ul>
<li>Json형태로 이루어져 있다. <code>var obj = {'a':10, b:20}</code> key값은 &lsquo;&lsquo;를 붙여도 되고 안붙여도 된다.</li>
<li>value를 변수로 추출할때는 다음과 같이 수행한다. 이를 비구조화라 한다. <code>var {a,b,c} = {a:1, b:2, c:3} // a==1, b==2, c==3</code></li>
<li>비구조화시 기본값을 설정할 수도 있다. <code>var {a=1,b=2} = {a:10} // a==10, b==2. b=2를 설정하지 않으면 b==undefined</code></li>
<li>다른 key를 사용하고싶다면 다음과 같이 수행한다. <code>var {a:one, b:two} = {a:10, b:20, c:30} // one==10, two==20, c==30</code></li>
<li>key값으로 사용불가능한 값이 올 경우 다음과 같이 비구조화 한다. <code>var {'a-b-c':a_b_c, [key]:A_B_C} = {'a-b-c':10, 'A B C':20} // a_b_c = 10, A_B_C = 20</code></li>
<li>재구조화시 전개 연산자를 사용할 수 있지만, 전개연산자를 재정의 할 수는 없다. <code>{a:A, ...rest} = {a:10, b:20, c:30} // rest:B 는 불가능</code></li>
</ul>
<h4 id="unpack">unpack</h4>
<ul>
<li>전개 연산자 <code>...</code> 을 사용하여 객체 내용을 나열할 있다.
ex)</li>
</ul>
<pre><code>const obj = () =&gt; {
  var value = &quot;value&quot;;
  var onChange = () =&gt; {console.log(&quot;onchange&quot;)}
  return {value, onChange};
}

...

// 아래 두 줄은 같은 효과를 가진다.
&lt;input placeholder=&quot;&quot; {...obj}&gt;&lt;input/&gt;
&lt;input placeholder=&quot;&quot; value = {obj.value} onchange={obj.onChange}&gt;&lt;input/&gt;
</code></pre><h3 id="복사">복사</h3>
<ul>
<li>배열</li>
</ul>
<pre><code>var a = [1,2,3]
var b = [...a] // 깊은복사
var [...c] = a // 깊은복사
var d = a // 얕은복사
</code></pre><ul>
<li>객체</li>
</ul>
<pre><code>var A = {one:1, two:2, three:3}
var B = {...A} // 깊은복사 : one==1, two==2, three==3
var C = {...A, three:30} // 깊은복사+값 할당 : one==1, two==2, three==30
</code></pre><h3 id="조건">조건</h3>
<ul>
<li>특정 조건을 만족할 때에만 내용이 출력되도록 한다.<br>
<code>{CONDITION &amp;&amp; &lt;div&gt; ! &lt;/div&gt;} // CONDITION 이 true일 때만 '!'를 표시한다.</code></li>
<li>3항 연산자 : C, java의 3항 연산자와 동일<br>
<code>&lt;span&gt;{A ? &quot;True&quot; : &quot;False&quot;}&lt;/span&gt;</code></li>
<li>&amp;&amp; : 앞의 내용이 참이면 뒤의 내용 수행<br>
<code>&lt;span&gt;{A &amp;&amp; &quot;True&quot;}&lt;/span&gt;</code></li>
</ul>
<h3 id="promise">promise</h3>
<ul>
<li>비동기 처리시 사용하는 객체</li>
<li>promise 객체는 async와 wait를 이용한다.
<ul>
<li><code>async function f1() {}</code> : async 함수 선언, f1 함수는 비동기로 동작하고, 내부에 await 구문을 사용할 수 있다.</li>
<li><code>const var = await f1()</code> : async 함수가 완료될 때 까지 대기하도록 await로 명시</li>
</ul>
</li>
</ul>
<h2 id="component">Component</h2>
<ul>
<li>React는 js파일에서 정의한 컴포넌트를 html로 컴파일 한다.
ex)</li>
<li>&lsquo;Subject&rsquo;라는 이름의 component를 생성해 본다.</li>
<li>생성된 &lsquo;Subject&rsquo;는 custom tag가 된다. HTML에서 tag를 호출하듯 사용 가능하다.</li>
</ul>
<ol>
<li>class형태로 만들기</li>
</ol>
<pre><code>class Subject extends Component {
   render() {
	   return (
		   &lt;header&gt;
         &lt;h1&gt;Hello&lt;/h1&gt;
       &lt;/header&gt;
     );
   }
}
</code></pre><ol start="2">
<li>함수 형태로 만들기</li>
</ol>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
		    &lt;h1&gt;Hello&lt;/h1&gt;
		  &lt;/div&gt;
	  );
}
</code></pre><p>-&gt; 함수형은 자원을 덜 사용하고, 선언하기 쉬운 장점이 있다.</p>
<ul>
<li>&lsquo;index.js&rsquo;가 default라 가정하고, &lsquo;App.js&rsquo;에서 App 객체 안에 <code>&lt;Subject&gt;&lt;/Subject&gt;</code> 와 같이 태그를 생성한다. (다른 파일에 선언했다면 해당 파일을 &lsquo;App.js&rsquo;에서 참조 필요)<br>
※  <em>&lsquo;App.js&rsquo; 파일은 확장자가 js이지만 코드 문법은 javascript가 아니다.</em></li>
</ul>
<h3 id="props">props</h3>
<ul>
<li>props를 활용하여 js파일에서 컴포넌트 태그 생성시 속성을 설정 가능하다.<br>
<code>&lt;Subject title=&quot;TITLE&quot;, content=&quot;CONTENT&quot;&gt;</code> : title 값으로 &ldquo;TITLE&rdquo;, content 값으로 &ldquo;CONTENT&rdquo; 설정</li>
<li>Subject 객체 생성시 <code>{this.prop.title}</code>, <code>{this.prop.content}</code>와 같이 참조하여 사용한다.</li>
</ul>
<pre><code>function Subject() {
    return (
	    &lt;div&gt;
		    &lt;h1&gt;{this.prop.title}&lt;/h1&gt;
        &lt;h2&gt;{this.prop.content}&lt;/h2&gt;
		&lt;/div&gt;
	);
}
</code></pre><ul>
<li>응용하여 아래와 같은 활용도 가능하다.</li>
</ul>
<pre><code>function Subject() {
    {title, content} = {this.prop}
    return (
	    &lt;div&gt;
		    &lt;h1&gt;{title}&lt;/h1&gt;
        &lt;h2&gt;{content}&lt;/h2&gt;
		&lt;/div&gt;
	);
}
</code></pre><h3 id="state">state</h3>
<ul>
<li>props는 부모 컴퍼넌트가 자식에게 설정해 주는 값이라면, state는 컴퍼넌트가 자기 자신을 위해 사용하는 값이다.</li>
<li>state는 함수형에서는 사용 불가능하고 클래스형에서 사용 가능하다. 대신 함수형에서는 &lsquo;훅&rsquo; 이라는 기능을 이용해 state와 유사한 효과를 낼 수 있다.</li>
</ul>
<ol>
<li>state 세팅</li>
</ol>
<ul>
<li>constructor : 컴퍼넌트가 생성되었을 때 최초로 실행되는 함수. 초기화를 담당한다.</li>
</ul>
<pre><code>class App extends Component {
  constructor(props) {
    super(props);       // constructor 함수 기본
    this.state : {    // state 초기화
      subject:{title:&quot;TITLE&quot;, content: &quot;CONTENT&quot;}
    }
  }
  render() {
    return (
      &lt;div ClassName = &quot;APP&quot;&gt;
        &lt;Subject title={this.state.subject.title} content={this.state.subject.content}&gt;&lt;/Subject&gt;     // html형태의 return값 안에서 javascript문법을 사용하려면 '{}'로 묶어준다.
      &lt;/div&gt;
    );
  }
}
</code></pre><p>-&gt; App 컴퍼넌트가 생성되면 초기 설정된 state 값으로 Subject 컴퍼넌트를 생성한다.</p>
<ul>
<li>index.js -&gt; App.js -&gt; Subject.js 순으로 호출이 이루어지는데, index.js에서는 App.js의 상태값을 알지 못한다. 즉, 부모에게 자신의 정보를 노출하지 않고 은닉한다.</li>
</ul>
<ol>
<li>state로 배열 사용</li>
</ol>
<pre><code>  class App extends Component {
    constructor(props) {
      super(props);       // constructor 함수 기본
      this.state = {    // state 초기화
        subject:{title:&quot;TITLE&quot;, content: &quot;CONTENT&quot;},
        contents:[
          {id:1, title:'title1', desc:'desc1'},
          {id:2, title:'title2', desc:'desc2'},
          {id:3, title:'title3', desc:'desc3'},
        ]
      }
    }
    render() {
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt;
        &lt;/div&gt;
      );
    }
  }

  class TOC extends Component {
    render() {
      var lists = [];
      var data = this.props.data;
      var i = 0;
      while (i &lt; data.length) {
        lists.push(&lt;li key={i}&gt;&lt;a href={&quot;/content/&quot; + data[i].id}&gt;{data[i].title}&lt;/a&gt;&lt;/li&gt;)
        /*
         * 반복문을 통해 여러 객체를 만들 때, react에서는 'key'라는 유니크한 속성을 요구한다.
         *
         */
        i = i + 1;
      }
      return (
        &lt;nav&gt;
          &lt;ul&gt;
            {lists} // lists에 &lt;li&gt;태그들을 넣어놓은 것들이 그대로 출력된다.
          &lt;/ul&gt;
        &lt;/nav&gt;
      );
    }
  }
</code></pre><p>※ react에서는 props나 state가 바뀌면, 이를 사용하는 하위 컴퍼넌트들의 <code>render()</code> 함수가 모두 다시 호출된다. 즉, 화면이 재구성된다.</p>
<h3 id="render">render</h3>
<ul>
<li>component 안의 <code>render()</code> 함수는 실제로 랜더링할 때 사용할 로직 및 html 형태를 반환한다.</li>
<li><code>render()</code> 함수 안에서 javascript로 로직 구현이 가능하다.
ex) 조건문</li>
</ul>
<pre><code>  class App extends Component {
    constructor(props) {
      super(props);       // constructor 함수 기본
      this.state = {    // state 초기화
        mode: 'read'
    }
    render() {
      var _mode = state.mode;
      if (_mode == 'read') {    // 조건문

      } else if (_mode == 'write') {

      }
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;TOC data={this.state.contents}&gt;&lt;/TOC&gt;
        &lt;/div&gt;
      );
    }
  }
</code></pre><h4 id="return">return</h4>
<ul>
<li><code>render()</code> 함수의 return 값은 html 형태가 되어야 한다.</li>
<li>하지만 return 안에서도 <code>{}</code> 구문 안에서 간단한 문법은 사용 가능하다.</li>
</ul>
<ol>
<li>조건문</li>
</ol>
<ul>
<li>3항 연산자 : C, java의 3항 연산자와 동일
<code>&lt;span&gt;{A ? &quot;True&quot; : &quot;False&quot;}&lt;/span&gt;</code></li>
<li>&amp;&amp; : 앞의 내용이 참이면 뒤의 내용 수행
<code>&lt;span&gt;{A &amp;&amp; &quot;True&quot;}&lt;/span&gt;</code></li>
</ul>
<h3 id="이벤트">이벤트</h3>
<ul>
<li>
<p>버튼 클릭, 내용 변경 등 사건이 발생했을 때, 이벤트 함수가 호출된다.</p>
<ol>
<li>onClick</li>
</ol>
<ul>
<li>html에서 onclick은 &lsquo;C&rsquo;가 소문자이지만, react에서는 대문자이다.</li>
<li>onClick은 인자로 함수를 받는다.
<ul>
<li>인자로 들어가는 함수는 &lsquo;event&rsquo; 객체를 인자로 받는다.</li>
<li>이 함수를 이벤트 함수라 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>      class App extends Component {
        constructor(props) {
          super(props);  
          this.state = {}
        }
        render() {
          return (
            &lt;div&gt;
              &lt;a href=&quot;/&quot; onClick={function(e) {
                console.log(e);       // 로그 찍는 방법
                e.preventDefault();   // 해당 태그의 기본 클릭동작을 수행하지 않도록 한다.
                // 'a' 태그의 경우 링크로 접속하는 동작을 막는다.
                }
              }&gt;Click_here&lt;/a&gt;        
            &lt;/div&gt;
          );
        }
      }
</code></pre><ul>
<li>
<p>이벤트 함수 안에서 <code>this.state.mode='write'</code>와 같이 state를 변경하면 react가 변경 여부를 확인하지 못해 render()함수를 다시 호출하지 않아 화면이 갱신되지 않는다.<br>
<code>this.setState({mode:'write'});</code>와 같이 state를 수정하도록 하자.</p>
<ol start="2">
<li>onChange</li>
</ol>
<ul>
<li>&lsquo;input&rsquo; 등 항목에서 내용이 변경되었을 경우</li>
<li>아래와 같이 사용 가능</li>
</ul>
<pre><code>const onChange = (event) =&gt; {
  // console.log(event.target.name);
  const {target: {name, value}} = event;  // get some values from 'event'
  ...
</code></pre></li>
</ul>
<p>+) bind</p>
<ul>
<li>이벤트 함수는 기본적으로 &lsquo;this&rsquo;를 가지지 않는다. 이때 강제로 this를 주입시키는 함수가 bind이다.</li>
<li>이벤트 함수 안에서는 기본적으로 &lsquo;this&rsquo;를 호출해도 아무것도 bind되어있지 않다.</li>
<li><code>onClick={function(e) { ... }.bind(this)}</code> 와 같이 this를 bind해주면 this를 사용할 수 있게된다.</li>
</ul>
<pre><code>  var obj = {name:'obj'};
  functiotn bindTest() {
    console.log(this.name);
  }
  bindTest(); // 아무 반응이 없다.
  bindTest.bind(obj); // obj가 bindTest의 this가 된다.
</code></pre><p>+) custom event</p>
<ul>
<li>함수를 하위 컴퍼넌트에 전달해 준다.</li>
</ul>
<pre><code>  class App extends Component {
    render() {
      return (
        &lt;div ClassName = &quot;APP&quot;&gt;
          &lt;Subject
            title={this.state.subject.title}
            content={this.state.subject.content}
            onChangePage={
              function(){
                alert(&quot;page chaged&quot;); // 경고창 출력
              }.bind(this);
            }
          &gt;
          &lt;/Subject&gt;
        &lt;/div&gt;
      );
    }
  }
  function Subject() {
      return (
  	    &lt;div&gt;
          &lt;a href=&quot;/&quot; onClick={ function(e) {
            e.preventDefault();
            this.props.onChangePage();  // 상위 컴퍼넌트로 부터 받은 함수 실행
          }
  		&lt;/div&gt;
  	);
  }
</code></pre><ul>
<li>하위 컴퍼넌트를 수정하지 않고 하위 컴퍼넌트의 태그 클릭시 수행할 작업을 변경할 수 있다.</li>
<li>하위 컴퍼넌트에서 상위 컴퍼넌트의 state를 변경할 수 있게 된다.</li>
</ul>
<hr>
<h2 id="라이프사이클">라이프사이클</h2>
<ul>
<li>컴퍼넌트는 &lsquo;마운트 -&gt; 업데이트 -&gt; 언마운트&rsquo; 생명주기를 갖는다.</li>
</ul>
<h3 id="마운트">마운트</h3>
<ul>
<li>마운트 단계 메서드로는 다음이 존재한다.
<ul>
<li><code>constructor</code> :  생성시 호출되는 메서드 (생성자)</li>
<li><code>getDerivedStateFromProps</code> : props 값을 state에 넣는 메서드</li>
<li><code>render</code> : UI를 렌더링 하는 메서드(화면 재구성)</li>
<li><code>componentDidMount</code> : 컴퍼넌트 랜더링 완료 후 호출되는 메서드</li>
</ul>
</li>
</ul>
<h3 id="업데이트">업데이트</h3>
<ul>
<li>
<p>컴퍼넌트가 업데이트 되는 경우는 아래의 경우들이 속한다.</p>
<ol>
<li>setProps를 이용한 props변경시</li>
<li>setState를 이용한 state변경시</li>
<li>부모 컴퍼넌트가 리렌더링 될 시</li>
<li>this.forceUpdate로 강제 렌더링시</li>
</ol>
</li>
<li>
<p>업데이트 단계의 메서드로는 다음이 존재한다.</p>
<ul>
<li><code>getDerivedStateFromProps</code> : props의 값을 state에 입력</li>
<li><code>shouldComponentUpdate</code> : 컴퍼넌트의 변화를 인지하고, 랜더링 필요 여부를 판단. true: 랜더링 필요, false: 랜더링 불필요.</li>
<li><code>render</code> : 컴퍼넌트 리렌더링</li>
<li><code>getSnapshotBeforeUpdate</code> : 컴퍼넌트 변화를 DOM에 반영하기 바로 직전에 호출되 메서드</li>
<li><code>componentDidUpdate</code> : 컴퍼넌트 업데이트 작업이 끝난 후 호출되 메서드</li>
</ul>
</li>
</ul>
<h3 id="언마운트">언마운트</h3>
<ul>
<li>언마운트 단계의 메서드로는 다음이 존재한다.
<ul>
<li><code>componentWillUnmount</code> : 컴퍼넌트가 브라우저상에서 사라지기 직전 호출되는 메서드</li>
</ul>
</li>
</ul>
<hr>
<h2 id="this">this</h2>
<ul>
<li>javascript 문법의 this와 동일하게 동작한다.</li>
<li>class 안에서는 this를 호출하면 class(컴퍼넌트)에 소속된 요소들에 접근할 수 있다.</li>
<li>일반 function 안에서 this를 호출하면 자신이 종속된 객체에 접근한다.</li>
<li>arrow function 안에서 this를 호출하면 자신이 종속된 인스턴스(컴퍼넌트)에 접근한다.</li>
</ul>
<pre><code>  function func1() {
    this.name = &quot;func1&quot;
    return {
        name : &quot;return&quot;
        arrow : () =&gt; {
          console.log(this.name) // 'func1' 출력
        }
        normal : function() {
          console.log(this.name) // 'return' 출력
        }
    }
  }
</code></pre><hr>
<h2 id="hook">hook</h2>
<ul>
<li>class component에는 this.state가 있지만 function component 에서는 this.state가 없다. 대신 hook을 사용하여 동일한 기능을 수행한다.</li>
<li>React에서는 built-in hook을 지원하고, 사용자가 직접 정의해서 사용할 수도 있다.</li>
</ul>
<h3 id="hook의-조건">hook의 조건</h3>
<ol>
<li>hook은 React 함수에서만 호출해야 한다. 일반 javascript 함수에서 호출하면 안된다.</li>
<li>hook은 반복문, 조건문, nested function에서 호출되면 안된다.</li>
</ol>
<blockquote>
<p>위 두 조건을 이해하려면 hook의 동작 원리를 이해해야한다.<br>
React는 컴퍼넌트를 처리할때 hook 함수들을 호출된 순서대로 관리한다.<br>
만약 컴퍼넌트를 업데이트할 때 hook 함수들의 순서가 변경된다면 React는 이를 정상적으로 처리하지 못한다.<br>
이때문에 hook은 항상 컴퍼넌트의 최상단에서 호출되어야 한다.</p>
</blockquote>
<h3 id="hook의-종류">hook의 종류</h3>
<ol>
<li>State Hooks</li>
</ol>
<ul>
<li><code>import { useState } from 'react'</code> 로 참조한다.</li>
<li><code>[state, updateState] = useState( VALUE )</code>: 컴퍼넌트에 VALUE값을 저장하고, 배열을 반환한다. &lsquo;state&rsquo; 는 VALUE 와 동일한 값이며, &lsquo;updateState&rsquo; 는 state값을 업데이트할 수 있는 함수 페어를 반환한다. &lsquo;updateState&rsquo; 는 <code>this.setState</code>와 유사한 효과를 가진다.</li>
<li>VALUE값으로는 숫자, 문자열, 객체 모두 수용 가능하다.</li>
</ul>
<ol start="2">
<li>Effect Hooks</li>
</ol>
<ul>
<li><code>import React, { useEffect } from 'react';</code>로 참조한다.</li>
<li>componentDidMount, componentWillUnmount 혹은 componentDidUpdate 와 유사한 효과를 발생시키며, 한 함수에서 여러번 선언 가능하다.</li>
<li>useEffect의 첫번째 인자로 함수가 들어가는데, 이 함수는 componentDidMount와 같은 시점에 동작된다.</li>
<li>useEffect의 첫번째 인자로 들어간 함수는 return값으로 함수를 반환하는데, 이 반환된 함수는 componentWillUnmount와 같은 시점에 동작된다.</li>
<li>useEffect의 두번째 인자로는 배열이 들어가고, 빈 배열을 넣을수도 있고, 값을 넣을수도 있다.
<ul>
<li>이 배열 요소의 값이 바뀔경우 useEffect의 첫번째 인자로 들어간 함수를 실행시킨다. (componentDidUpdate와 유사하게 특정 변수가 변할때 rerendering을 할 수 있다.)</li>
<li>또한, 이 배열 요소의 값이 바뀌기 직전, 첫번째 인자로 들어간 함수의 return 값이 실행된다.</li>
</ul>
</li>
</ul>
<pre><code>    // return 없는 함수만 오는 경우
    useEffect( () =&gt; {
      console.log(&quot;componentDidUpdate&quot;);
    }
    // return 이 포함된 함수가 오는 경우
    useEffect( () =&gt; {
      console.log(&quot;componentDidMount&quot;);
      return (
        () =&gt; { console.log(&quot;componentWillUnmount&quot;) }
      )
    })
    // 두번쨰 인자가 들어간 경우
    useEffect( () =&gt; {
      console.log(&quot;'value' changed&quot;);
      return (
        () =&gt; { console.log(&quot;value will be change&quot;)}
      )
    }, [value])

</code></pre><ul>
<li>class 의 componentdidMount와 같은 함수에 비해 간단하고 직관적으로 사용할 수 있다.</li>
</ul>
<ol start="3">
<li>Context Hooks</li>
</ol>
<ul>
<li><code>useContext</code></li>
</ul>
<ol start="4">
<li>Reducer Hooks</li>
</ol>
<ul>
<li><code>useReducer</code></li>
</ul>
<ol start="5">
<li>Custom Hooks</li>
</ol>
<ul>
<li>hook을 담고 있는 사용자 정의 함수를 custom hook이라 칭한다. 반복되는 hook 호출 + 일련의 처리 과정을 하나의 함수로 묶어서 사용할 수 있다.</li>
<li>통념적으로 &lsquo;use&rsquo;로 시작하는 이름을 붙여준다.</li>
<li>호출된 custom hook도 일반 hook과 마찬가지로 중복해서 사용이 가능하며 각 hook들 끼리는 독립적이다.</li>
</ul>
<hr>
<h2 id="각종-모듈">각종 모듈</h2>
<ul>
<li>package.json에 dependency를 기록해놓은 경우, <code>npm install --legacy-peer-deps</code> 명령으로 모든 dependency를 한번에 다운받을 수 있다. package.json에 기록되지 않는 모듈은 지워버리니 주의.</li>
</ul>
<h3 id="router">Router</h3>
<ul>
<li>SPA (Single Page Application) 에서 사용하지 않는 리소스를 로딩하느라 시간이 오래걸리는 것을 방지하기 위해, 소스를 분할처리하여 사용시에만 받을수 있게 하는 모듈</li>
<li>설치 : <code>npm install react-router-dom</code></li>
<li>사용 :</li>
</ul>
<pre><code>import { HashRouter, Route, Routes, BrowserRouter} from &quot;react-router-dom&quot;;
const sample = () =&gt; {
    return (
        &lt;HashRouter&gt;
          /* can add any components you want */
          &lt;Routes&gt;
          /* can only put 'Route' components in 'Routes' */
          &lt;Route path=&quot;/&quot; element={&lt;Home/&gt;} /&gt;  // '/' 주소 호출시 Home component를 호출
          &lt;Route path=&quot;/about/*&quot; element={&lt;About/&gt;} /&gt;  // 'about' 및 'about/...' 형태의 주소 호출시 About component 호출
          /* add as you wish */
          &lt;/Routes&gt;
        &lt;/HashRouter&gt;
    );
};
</code></pre><ul>
<li>Route는 위에서부터 순차적으로 적용된다. if-else if 구문으로 생각하면 편하다.</li>
<li>정규식 wild card <code>*</code>을 사용할 수 있다. (v5에서 exact 옵션 삭제되고 &lsquo;*&lsquo;로대체)</li>
<li>route 하는 대상에 props을 전달하고 싶다면,</li>
</ul>
<h3 id="link">Link</h3>
<ul>
<li>특정 페이지로 경로를 전환해 주는 기능을 한다.</li>
<li>react-router-dom 모듈 안에 포함되어있다.</li>
<li><code>&lt;a&gt;</code> 태그와 동일한 역할을 하지만, React에서는 <code>&lt;a&gt;</code>를 사용하면 페이지를 새로 호출하여 React가 지니고 있던 상태들이 모두 초기화되기 때문에 <code>&lt;a&gt;</code> 태그 대신 link를 사용하는것이 맞다.</li>
<li>link는 페이지의 개념이고, button은 operation의 개념이다. 모두 event를 발생시킬 수 있지만 구분을 하는게 좋다.</li>
<li>설치 : <code>npm install react-router-dom</code></li>
<li>사용 :</li>
</ul>
<pre><code>import { Link } from &quot;react-router-dom&quot;;
...
&lt;Link to=&quot;/&quot;&gt;Root&lt;/Link&gt; // 클릭하면 '/' 경로로 redirect 되는 Link 생성
</code></pre><h3 id="redirect">Redirect</h3>
<ul>
<li>react-router-dom에서 redirect를 지원하는 방법은 여러가지가 있다.</li>
</ul>
<ol>
<li>Navigate 모듈</li>
</ol>
<ul>
<li>사용 :</li>
</ul>
<pre><code>import { HashRouter, Routes, Route, Navigate } from &quot;react-router-dom&quot;;
...
&lt;HashRouter&gt;
  &lt;Routes&gt;
    &lt;Route path=&quot;/&quot; element={&lt;Home/&gt;}
    &lt;Route path=&quot;/about&quot; element={&lt;About/&gt;}
    /* add as you wish */
    &lt;Route path=&quot;/index&quot; element={&lt;Navigate replace to=&quot;/&quot; /&gt;} /&gt;  // 'index' 페이지를 '/' 경로로 redirect
    &lt;Route path=&quot;*&quot; element={&lt;Navigate to=&quot;/&quot; /&gt;} /&gt;  // 위에서 설정되지 않은 경로에 대해서는 모두 '/'로 redirect
  &lt;/Routes&gt;
&lt;/HashRouter&gt;
</code></pre><ol>
<li>useHistory</li>
</ol>
<ul>
<li>사용 :</li>
</ul>
<pre><code>const history = useHistory();
history.push(&quot;/&quot;);  // '/' 경로로 redirect
</code></pre><ol>
<li>useNavigation</li>
</ol>
<ul>
<li>사용 :</li>
</ul>
<pre><code>const navigation = useNavigation()
navigation(&quot;/&quot;);  // '/' 경로로 redirect
</code></pre><h3 id="cross-env">cross-env</h3>
<ul>
<li>운영체제마다 환경변수 제공 방식이 달라 절대경로 표시가 어려웠던 점을 해결해주는 모듈</li>
<li>설치 : <code>npm install cross-env --dev</code></li>
</ul>
<h3 id="typeof">typeof</h3>
<ul>
<li>react에서 기본적으로 제공하는 함수이다.
ex)</li>
</ul>
<pre><code>var x = 1;
if (typeof(x) === 'number') {
  ...
}
</code></pre><ul>
<li>반환하는 결과값은 다음과 같다.</li>
</ul>
<blockquote>
<p>undefined, object, number, boolean, bigint, string, symbol, function</p>
</blockquote>
<h2 id="정의되는-값-참조httpsdevelopermozillaorgkodocswebjavascriptreferenceoperatorstypeof"><a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/typeof"target="_blank">정의되는 값 참조</a></h2>
<h2 id="dom">DOM</h2>
<ul>
<li>JSX에서 DOM을 조작하는 내용을 살펴보자</li>
</ul>
<h3 id="script-참조">script 참조</h3>
<ul>
<li>
<p>javascript에서 아래와 같이 script를 추가할 수 있다.<br>
<code>&lt;script async defer src=&quot;https://apis.google.com/js/api.js&quot; onload=&quot;gapiLoaded()&quot;&gt;&lt;/script&gt;</code></p>
</li>
<li>
<p>react에서는 위 방식 대신, hook과 document 인자를 사용하여 아래와 같이 작성한다.</p>
</li>
</ul>
<pre><code>const [calendarApiLoaded, setCalendarApiLoaded] = useState(false);
useEffect( ()=&gt; {
  // check api is loaded
  const existingCheck = document.getElementById('gapi');
  // if not loaded, load
  if (!existingCheck) {
    const gapiScript = document.createElement('script');
    gapiScript.src = &quot;https://apis.google.com/js/api.js&quot;
    const gisScrpit = document.createElement('script');
    gisScrpit.src = &quot;https://accounts.google.com/gsi/client&quot;

    // merge two scripts
    gapiScript.append(gisScrpit);
    gapiScript.id = 'gapi';

    // append to body
    document.body.appendChild(gapiScript);

    // change state
    setCalendarApiLoaded(true);
  }
});
</code></pre><h3 id="window-변수">window 변수</h3>
<ul>
<li>window는 전역번수를 attach된 모든 script에서 접근할 수 있는 변수이며, react에서도 마찬가지로 <code>window.value</code> 혹은 <code>window['value']</code> 형태로 접근이 가능하다.</li>
</ul>
<h2 id="기타">기타</h2>
<ol>
<li>함수형, 클래스형</li>
</ol>
<ul>
<li>react는 함수형 방식과 클래스형 방식으로 작성할 수 있다. 최근에는 함수형 방식을 선호하는 추세이다.</li>
<li>함수형이 클래스형보다 메모리를 덜 사용한다.</li>
</ul>
<ol>
<li>다른 파일 참조</li>
</ol>
<ul>
<li>react에서 다른 파일을 참조할 때에는 &lsquo;import&rsquo;를 사용하며, 확장자가 없으면 &lsquo;.js&rsquo;가 생략된 것으로 본다.<br>
<code>import React, { Component } from &quot;react&quot;</code>는 기본으로 필요하다.</li>
</ul>
<ol>
<li>html에서 예약어로 사용하는 태그들은 &lsquo;synamtic tag&rsquo;라 한다.</li>
</ol>
<ul>
<li>&lsquo;h1&rsquo;, &lsquo;header&rsquo;, &lsquo;nav&rsquo;, &lsquo;article&rsquo; 등이 있다.</li>
</ul>
<ol>
<li><code>export</code> : 특정 객체를 다른 파일에서 import할 수 있도록 한다.<br>
ex) <code>export App</code></li>
<li><code>debugger</code>라는 예약어는, chrome에서 실행할 때 break point역할을 한다. 개발시 코드로 break point를 설정할 수 있다.</li>
</ol>
<hr>
<h2 id="추가-활용">추가 활용</h2>
<h3 id="이미지-첨부">이미지 첨부</h3>
<ul>
<li>이미지는 /resources 파일에 첨부하고, import로 가져와 사용할 수 있다.</li>
<li>확장자가 없으면 js파일로 취급하니 확장자도 꼭 적어주도록 한다.</li>
</ul>
<pre><code>import screen_img from '../resources/screen_img.webp'

...

    // INFO: React JSX에서 style 설정
    var _style = {
        'top': 0 //- scrollPos
    }
    var _style_img = {
        'background-image': &quot;url(&quot; + screen_img + &quot;)&quot;,
        'top': -694 - scrollPos * 4/5
    };
</code></pre><h3 id="key-숨기기">key 숨기기</h3>
<ul>
<li>API key 등 사용자에게 드러내지 않고싶은 정보들을 react가 아닌 다른 곳에 저장해야 한다. <strong>react app에 저장하게 되면 개발 도구를 사용해 Client에서 어떻게든 내용을 확인할 수 있다.</strong></li>
<li>다만, .env 파일에 따로 저장하게 되면 git에서는 나타나지 않게 설정할 수 있다.</li>
</ul>
<h3 id="env-파일-사용법">.env 파일 사용법</h3>
<ul>
<li>root 경로에 .env파일을 생성한다.</li>
<li>.gitignore에 .env파일을 예외처리 한다.</li>
<li>정의하고 싶은 내용을 <code>REACT_APP_</code> 뒤에 이어붙여 정의한다. (ex: REACT_APP_API_KEY)</li>
<li>정의한 내용은 react JSX에서 <code>process.env.REACT_APP_API_KEY</code> 형태로 사용 가능하다.</li>
</ul>
<h3 id="custom-tag">Custom Tag</h3>
<ul>
<li>Custom tag &lsquo;CAT&rsquo; 를 새로 만든다고 할때, <code>&lt;CAT name={name}/&gt;</code> 과 같이 생성하였다.</li>
<li>Custom tag 안에 다른 내용을 집어넣고 싶으면, <code>&lt;CAT name={name}&gt; {props.children} &lt;/CAT&gt;</code> 형태로 사용하면 된다.</li>
</ul>
<h2 id="참조">참조</h2>
<p><a href="https://yuddomack.tistory.com/entry/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%AC%B8%EB%B2%95-%EB%B9%84%EA%B5%AC%EC%A1%B0%ED%99%94-%ED%95%A0%EB%8B%B9"target="_blank">자바스크립트 문법</a>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#array_destructuring"target="_blank">문법 Document</a>
<a href="https://devowen.com/307?category=778540"target="_blank">React LifeCycle</a>
<a href="https://reactjs.org/docs/hooks-intro.html#motivation"target="_blank">What &amp; Why Hook</a></p>
</article><section class="article labels"><a class="category" href=/categories/dev/>dev</a><a class="category" href=/categories/basic/>basic</a><a class="tag" href=/tags/react/>react</a><a class="tag" href=/tags/javascript/>javascript</a><a class="tag" href=/tags/web-application/>web application</a></section><section class="article author"><img class="avatar" src="https://d33wubrfki0l68.cloudfront.net/ddf49425628d8aec7523db143916b34ae1641e11/b97e8/images/gopher-side_color.svg" alt><p class="name">gohugo</p><div class="bio">Hugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.</div><div class="details"><a class="item" href="https://github.com/gohugoio" target="_blank"><span class="iconfont icon-github"></span>&nbsp;gohugoio</a><a class="item" href="https://twitter.com/GoHugoIO" target="_blank"><span class="iconfont icon-twitter"></span>&nbsp;@GoHugoIO</a></div>
</section></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/post/gdb/"><span class="li iconfont icon-article"></span>GDB</a></p><p><a class="link" href="/post/c&#43;&#43;/"><span class="li iconfont icon-article"></span>C++ basic</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">©2020 Notepadium.</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section></body>

</html>